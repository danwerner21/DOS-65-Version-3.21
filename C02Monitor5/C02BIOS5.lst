  Fri Apr 11 2025  6:34                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*    C02BIOS 5.0 - Release version for Pocket SBC  (c)2013-2025 by Kevin E. Maier 10/04/2025     *
     3                        ;*                                                                                                *
     4                        ;* BIOS Version 5.0 supports the following 3.3V hardware specification:                           *
     5                        ;*                                                                                                *
     6                        ;*  - W65C02S with clock rate up to 8.0 MHz                                                       *
     7                        ;*  - AS6C1008 128KB Static RAM mapped to 56KB or 62KB                                            *
     8                        ;*  - SST39LF-010 128KB Flash ROM mapped to 2KB or 8KB                                            *
     9                        ;*  - ATF1504ASV Single Glue Logic                                                                *
    10                        ;*  - NXP SC28L92 DUART for Console Port / Aux Serial Port / Timer                                *
    11                        ;*  - MicroDrive IDE PATA interface with 16-bit data port                                         *
    12                        ;*  - DS1318 Realtime Clock - 32-bit binary Epoch time                                            *
    13                        ;*  - TL7533 Reset Circuit (positive & negative Reset signals)                                    *
    14                        ;*  - TL7533 Reset Circuit (positive & negative NMI/Panic signals)                                *
    15                        ;*                                                                                                *
    16                        ;* Hardware map is flexible via Glue logic                                                        *
    17                        ;*  - SC28L92 DUART mapped to $FE00 - $FE0F (16 bytes)                                            *
    18                        ;*  - $FE10 - $FE1F is currently unmapped                                                         *
    19                        ;*  - DS1318 RTC mapped to $FE20 - $FE1F (16 bytes)                                               *
    20                        ;*  - IDE Controller and 16-bit data port mapped to $FE30 - $FE3F (16 bytes)                      *
    21                        ;*                                                                                                *
    22                        ;* BIOS Functions are divided into groups as follows:                                             *
    23                        ;*                                                                                                *
    24                        ;* SC28L92 DUART functions:                                                                       *
    25                        ;* - Full duplex interrupt-driven/buffered I/O for both DUART Channels                            *
    26                        ;* - Precision timer services with 10ms accuracy                                                  *
    27                        ;* - RTC based Jiffy Clock, 32-bit count of seconds (EPOCH time)                                  *
    28                        ;* - Accurate delays from 10ms to ~46 hours                                                       *
    29                        ;* - 10ms Benchmark Timing to 65535.99 seconds                                                    *
    30                        ;*                                                                                                *
    31                        ;* IDE Controller Functions supporting PATA 16-bit Data Transfers:                                *
    32                        ;* - Uses Logical Block Addressing (LBA) Mode only                                                *
    33                        ;* - Multiple Block transfers are supported for Read/Write Block commands                         *
    34                        ;* - Reset IDE (recalibrate command)                                                              *
    35                        ;* - Get IDE Status and Extended Error codes                                                      *
    36                        ;* - Get IDE Identification Block                                                                 *
    37                        ;* - Read a Block from IDE device                                                                 *
    38                        ;* - Write a Block to IDE device                                                                  *
    39                        ;* - Set the LBA Block ID for Read/Write                                                          *
    40                        ;* - Set the Memory Address to transfer Block data to/from                                        *
    41                        ;* - Enable/Disable the Write Cache on IDE controller                                             *
    42                        ;*                                                                                                *
    43                        ;* Maxim DS1318 Realtime Clock functions:                                                         *
    44                        ;* - Detect RTC and Load software RTC variables                                                   *
    45                        ;*                                                                                                *
    46                        ;* BIOS Features:                                                                                 *
    47                        ;* - Extendable BIOS structure with soft vectors                                                  *
    48                        ;* - Soft config parameters for I/O devices                                                       *
    49                        ;* - Monitor cold/warm start soft vectored now optional                                           *
    50                        ;* - Panic Routine to restore Vectors and Reinitialize Console only                               *
    51                        ;* - Bootable default from IDE controller LBA 0                                                   *
    52                        ;* - Fully relocatable code (sans page $FF)                                                       *
    53                        ;* - JUMP Table at $FF00 - 32 functions                                                           *
    54                        ;* - Default memory allocation of 2KB (includes 64 bytes of I/O mapping)                          *
    55                        ;**************************************************************************************************
    56                                PL      66      ;Page Length
    57                                PW      132     ;Page Width (# of char/line)
  Fri Apr 11 2025  6:34                                                                                                    Page 2


    58                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    59                                PASS1   OFF     ;Set ON when used for debug
    60                                INCLIST ON      ;Set ON for listing Include files
    61                        ;**************************************************************************************************
    62                        ;C02BIOS Version 5.x is "loosely" based on C02BIOS Version 4.02.
    63                        ;
    64                        ; - Main changes are to support minimal ROM usage and add IDE Boot capability.
    65                        ; - Include Bencharking routines into BIOS.
    66                        ; - Provide DOS/65 Boot and usage without C02 Monitor code.
    67                        ; - Provide an additional 6KB of RAM space for DOS/65 TEA (removal of C02Monitor).
    68                        ; - Remove IDE LBA Verify routine (not used for DOS/65).
    69                        ; - Remove RTC NVRAM block read/write (DS1318 has no such NVRAM - replaces DS15x1).
    70                        ; - Add support for DS1318 RTC as 32-bit EPOCH time in 1-second increments.
    71                        ;
    72                        ; - Changes to Page Zero to condense usage for IDE Bootable BIOS (includes DOS/65 usage).
    73                        ; - Restructure BIOS Jump table for new hardware config (calls are different from 4.x releases).
    74                        ;
    75                        ;**************************************************************************************************
    76                        ;This BIOS uses a single source file for constants and variables.
    77                        ;
    78                                INCLUDE         C02Constants5.asm
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 5.x releases of C02BIOS5 / C02Monitor                  *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  10/04/2025 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ;                                                                                                 *
    10                        ; C02BIOS Version is now at 5.0                                                                   *
    11                        ; C02Monitor Version is now at 5.0                                                                *
    12                        ; - All Constants and Variables are now defined in a single source file (this one)                *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;                                                                                                 *
    18                        ;          - Page Zero locations $00 to $BF (192 bytes) reserved for user applications            *
    19                        ;                                                                                                 *
    20                        ;**************************************************************************************************
    21                        ;
    22             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Monitor Page 0 use ($A0-$CF, 48 bytes)
    23                        ;
    24             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    25                        ;
    26             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    27                        ;
    28                        ;       - 16-bit variables:
    29             000000A4   HEXDATAH        .EQU    PGZERO_ST+04            ;Hexadecimal input
    30             000000A5   HEXDATAL        .EQU    PGZERO_ST+05
    31             000000A6   COMLO           .EQU    PGZERO_ST+06            ;User command address
    32             000000A7   COMHI           .EQU    PGZERO_ST+07
    33             000000A8   INDEXL          .EQU    PGZERO_ST+08            ;Index for address - multiple routines
    34             000000A9   INDEXH          .EQU    PGZERO_ST+09
    35             000000AA   TEMP1L          .EQU    PGZERO_ST+10            ;Index for word temp value used by Memdump
    36             000000AB   TEMP1H          .EQU    PGZERO_ST+11
    37             000000AC   SRCL            .EQU    PGZERO_ST+12            ;Source address for memory operations
    38             000000AD   SRCH            .EQU    PGZERO_ST+13
    39             000000AE   TGTL            .EQU    PGZERO_ST+14            ;Target address for memory operations
    40             000000AF   TGTH            .EQU    PGZERO_ST+15
    41             000000B0   LENL            .EQU    PGZERO_ST+16            ;Length address for memory operations
    42             000000B1   LENH            .EQU    PGZERO_ST+17
  Fri Apr 11 2025  6:34                                                                                                    Page 3


    43                        ;
    44                        ;       - 8-bit variables and constants:
    45             000000B2   BUFIDX          .EQU    PGZERO_ST+18            ;Buffer index
    46             000000B3   BUFLEN          .EQU    PGZERO_ST+19            ;Buffer length
    47             000000B4   IDX             .EQU    PGZERO_ST+20            ;Temp Indexing
    48             000000B5   IDY             .EQU    PGZERO_ST+21            ;Temp Indexing
    49             000000B6   TEMP1           .EQU    PGZERO_ST+22            ;Temp - Code Conversion routines
    50             000000B7   TEMP2           .EQU    PGZERO_ST+23            ;Temp - Memory/SREC routines
    51             000000B8   CMDFLAG         .EQU    PGZERO_ST+24            ;Command Flag, bit specific, used by many routines
    52                        ;
    53                        ;       - Xmodem transfer variables
    54             000000B9   OPXMDM          .EQU    PGZERO_ST+25            ;Xmodem Flag variable
    55             000000BA   CRCHI           .EQU    PGZERO_ST+26            ;CRC hi byte  (two byte variable)
    56             000000BB   CRCLO           .EQU    PGZERO_ST+27            ;CRC lo byte - Operand in Disassembler
    57             000000BC   CRCCNT          .EQU    PGZERO_ST+28            ;CRC retry count - Operand in Disassembler
    58             000000BD   PTRL            .EQU    PGZERO_ST+29            ;Data pointer lo byte - Mnemonic in Disassembler
    59             000000BE   PTRH            .EQU    PGZERO_ST+30            ;Data pointer hi byte - Mnemonic in Disassembler
    60             000000BF   BLKNO           .EQU    PGZERO_ST+31            ;Block number
    61                        ;
    62             000000C0   BIOS_PG0        .EQU    $C0                     ;Start of BIOS Page 0 usage (64 bytes)
    63                        ;
    64                        ; Reserve 8 bytes of Page Zero for DOS/65 usage ($C0 - $C7).
    65                        ;
    66                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    67                        ;
    68             000000C8   DATABUFF        .EQU    BIOS_PG0+08             ;Data Buffer - 6 bytes ($C8-$CD)
    69                        ;
    70             000000CE   BINVALL         .EQU    BIOS_PG0+14             ;Binary Value for HEX2ASC
    71             000000CF   BINVALH         .EQU    BIOS_PG0+15
    72                        ;
    73             000000D0   STRINGL         .EQU    BIOS_PG0+16             ;Pointer for sending a text string low
    74             000000D1   STRINGH         .EQU    BIOS_PG0+17
    75                        ;
    76                        ;       - BRK handler routine
    77             000000D2   PCL             .EQU    BIOS_PG0+18             ;Program Counter Low index
    78             000000D3   PCH             .EQU    BIOS_PG0+19             ;Program Counter High index
    79             000000D4   PREG            .EQU    BIOS_PG0+20             ;Temp Status Reg
    80             000000D5   SREG            .EQU    BIOS_PG0+21             ;Temp Stack ptr
    81             000000D6   YREG            .EQU    BIOS_PG0+22             ;Temp Y Reg
    82             000000D7   XREG            .EQU    BIOS_PG0+23             ;Temp X Reg
    83             000000D8   AREG            .EQU    BIOS_PG0+24             ;Temp A Reg
    84                        ;
    85                        ;       - 28L92 IRQ handler pointers and status
    86             000000D9   ICNT_A          .EQU    BIOS_PG0+25             ;Input buffer count
    87             000000DA   IHEAD_A         .EQU    BIOS_PG0+26             ;Input buffer head pointer
    88             000000DB   ITAIL_A         .EQU    BIOS_PG0+27             ;Input buffer tail pointer
    89             000000DC   OCNT_A          .EQU    BIOS_PG0+28             ;Output buffer count
    90             000000DD   OHEAD_A         .EQU    BIOS_PG0+29             ;Output buffer head pointer
    91             000000DE   OTAIL_A         .EQU    BIOS_PG0+30             ;Output buffer tail pointer
    92                        ;
    93             000000DF   ICNT_B          .EQU    BIOS_PG0+31             ;Input buffer count
    94             000000E0   IHEAD_B         .EQU    BIOS_PG0+32             ;Input buffer head pointer
    95             000000E1   ITAIL_B         .EQU    BIOS_PG0+33             ;Input buffer tail pointer
    96             000000E2   OCNT_B          .EQU    BIOS_PG0+34             ;Output buffer count
    97             000000E3   OHEAD_B         .EQU    BIOS_PG0+35             ;Output buffer head pointer
    98             000000E4   OTAIL_B         .EQU    BIOS_PG0+36             ;Output buffer tail pointer
    99                        ;
   100             000000E5   UART_IRT        .EQU    BIOS_PG0+37             ;SC28L92 Interrupt Status byte
   101                        ;
   102                        ;       -RTC DS1318 Values:
   103                        ; These are the values used for the alternate RTC chip, which is simply a 32-bit interval counter
   104                        ; which is loaded with EPOCH time and incremented each second as a 32-bit integer.
   105                        ; This frees up 3 locations in Page Zero.
  Fri Apr 11 2025  6:34                                                                                                    Page 4


   106                        ;
   107             000000E6   TICKS           .EQU    BIOS_PG0+38             ;Number of timer countdowns = 1 second (100)
   108             000000E7   SECS_0          .EQU    BIOS_PG0+39             ;Seconds: bits 0-7
   109             000000E8   SECS_1          .EQU    BIOS_PG0+40             ;Seconds: bits 8-15
   110             000000E9   SECS_2          .EQU    BIOS_PG0+41             ;Seconds: bits 16-23
   111             000000EA   SECS_3          .EQU    BIOS_PG0+42             ;Seconds: bits 24-31
   112                        ;
   113                        ;       - Delay Timer variables
   114             000000EB   MSDELAY         .EQU    BIOS_PG0+43             ;Timer delay countdown byte (255 > 0)
   115             000000EC   SETMS           .EQU    BIOS_PG0+44             ;Set timeout for delay routines - BIOS use only
   116             000000ED   DELLO           .EQU    BIOS_PG0+45             ;Delay value BIOS use only
   117             000000EE   DELHI           .EQU    BIOS_PG0+46             ;Delay value BIOS use only
   118                        ;
   119                        ;       - Count variables for 10ms benchmark timing
   120             000000EF   MS10_CNT        .EQU    BIOS_PG0+47             ;10ms Count variable
   121             000000F0   SECL_CNT        .EQU    BIOS_PG0+48             ;Seconds Low byte count
   122             000000F1   SECH_CNT        .EQU    BIOS_PG0+49             ;Seconds High byte count
   123                        ;
   124                        ;       - Address and pointers for IDE Interface
   125             000000F2   LBA_ADDR_LOW    .EQU    BIOS_PG0+50             ;LBA Transfer Address low byte
   126             000000F3   LBA_ADDR_HIGH   .EQU    BIOS_PG0+51             ;LBA Transfer Address high byte
   127                        ;
   128             000000F4   LBA_XFER_CNT    .EQU    BIOS_PG0+52             ;LBA Transfer Count 1-xx (check RAM space!)
   129                        ;
   130             000000F5   LBA_LOW_BYTE    .EQU    BIOS_PG0+53             ;LBA Block number bits 0-7
   131             000000F6   LBA_HIGH_BYTE   .EQU    BIOS_PG0+54             ;LBA Block number bits 8-15
   132             000000F7   LBA_EXT_BYTE    .EQU    BIOS_PG0+55             ;LBA Block number bits 16-23
   133                        ;
   134             000000F8   BIOS_XFERL      .EQU    BIOS_PG0+56             ;BIOS Move Routine low byte
   135             000000F9   BIOS_XFERH      .EQU    BIOS_PG0+57             ;BIOS Move Routine high byte
   136             000000FA   BIOS_XFERC      .EQU    BIOS_PG0+58             ;BIOS Block Count moved (needs to be set)
   137                        ;
   138             000000FB   IDE_STATUS_RAM  .EQU    BIOS_PG0+59             ;IDE RAM-Based Status
   139                        ;
   140             000000FC   B_SPARE0        .EQU    BIOS_PG0+60             ;Spare BIOS byte page zero
   141             000000FD   B_SPARE1        .EQU    BIOS_PG0+61             ;Spare BIOS byte page zero
   142             000000FE   B_SPARE2        .EQU    BIOS_PG0+62             ;Spare BIOS byte page zero
   143                        ;
   144                        ;       - Timer/Counter Match flag for Delay/Benchmark and hardware support
   145             000000FF   MATCH           .EQU    BIOS_PG0+63             ;Bit 7 used for Delay
   146                                                                        ;Bit 6 used for Benchmark
   147                                                                        ;Bit 5 used to show IDE drive present
   148                                                                        ;Bit 4 used to show RTC chip present
   149                                                                        ;Bits 3,2 used for IDE Interrupt Handler
   150                                                                        ;Bits 1,0 reserved for future use
   151                        ;
   152                        ;**************************************************************************************************
   153                        ;
   154                        ; Default for RTC tick count - number of IRQs for 1 second
   155             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   156                        ;
   157                        ;**************************************************************************************************
   158                        ;
   159             00000200   SOFTVEC         .EQU    $0200                   ;Start of soft vectors
   160                        ;The Interrupt structure is vector based. During startup, Page $02 is loaded from ROM.
   161                        ; The soft vectors are structured to allow inserting additional routines either before
   162                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   163                        ;
   164                        ;The main set of vectors occupy the first 16 bytes of Page $02. The ROM handler for
   165                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   166                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   167                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   168                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 5


   169                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   170                        ; which occupy 16 bytes. They can be used as required.
   171                        ; Currently, VECINSRT0 will be used if an IDE Controller is detected.
   172                        ;
   173             00000200   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   174             00000202   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   175             00000204   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   176                        ;
   177             00000206   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   178             00000208   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   179             0000020A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   180                        ;
   181             0000020C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   182             0000020E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   183                        ;
   184             00000210   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   185             00000212   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   186             00000214   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   187             00000216   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   188             00000218   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   189             0000021A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   190             0000021C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   191             0000021E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   192                        ;
   193                        ;**************************************************************************************************
   194                        ;
   195                        ;Soft Config values below are loaded from ROM and are the default I/O setup Configuration data that
   196                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O Configuration
   197                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   198                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O Configuration.
   199                        ;
   200                        ;There are a total of 32 Bytes Configuration data reserved starting at $0220,
   201                        ; - 22 bytes are reserved for the NXP SC28L92 DUART.
   202                        ;
   203             00000220   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware Config parameters
   204                        ;
   205             00000220   LOAD_28L92      .EQU    SOFTCFG+00              ;SC28L92 Soft Config Data
   206                        ;
   207                        ; The configuration for the DUART consists of 14 parameters/commands stored in the following
   208                        ; - memory locations. Note that these are sent in reverse, i.e., $22E thru $220.
   209                        ;
   210                        ;       $220    .DB     %00000011       $03     ;Enable OP0/1 for RTS control Port A/B
   211                        ;       $221    .DB     %00001010       $A0     ;Disable Receiver/Disable Transmitter B
   212                        ;       $222    .DB     %00001001       $09     ;Enable Receiver/Disable Transmitter A
   213                        ;       $223    .DB     %00001111       $0F     ;Interrupt Mask Register setup
   214                        ;       $224    .DB     %11100000       $E0     ;Aux Register setup for Counter/Timer
   215                        ;       $225    .DB     %01001000       $48     ;Counter/Timer Upper Preset (18432 decimal)
   216                        ;       $226    .DB     %00000000       $00     ;Counter/Timer Lower Preset
   217                        ;       $227    .DB     %11001100       $CC     ;Baud Rate clock for B Rcv/Xmt - 115.2K
   218                        ;       $228    .DB     %11001100       $CC     ;Baud Rate clock for A Rcv/Xmt - 115.2K
   219                        ;       $229    .DB     %00110000       $30     ;Reset Transmitter B
   220                        ;       $22A    .DB     %00100000       $20     ;Reset Receiver B
   221                        ;       $22B    .DB     %00110000       $30     ;Reset Transmitter A
   222                        ;       $22C    .DB     %00100000       $20     ;Reset Receiver A
   223                        ;       $22D    .DB     %00000000       $00     ;Interrupt Mask Register setup (clear)
   224                        ;       $22E    .DB     %11110000       $F0     ;Command Register A - Disable Power Down
   225                        ;       $22F    .DB     %11111111       $FF     ;Spare Byte
   226                        ;
   227                        ; The MR registers of the DUART also have soft config data loaded here, but is separate from the
   228                        ; - main register config data, as these are all accessed via a single I/O port (auto-indexed).
   229                        ; - These are also sent in reverse order as above.
   230                        ;
   231                        ;       $230    .DB     %00010111       $17     ;Mode Register 2 data
  Fri Apr 11 2025  6:34                                                                                                    Page 6


   232                        ;       $231    .DB     %11010011       $D3     ;Mode Register 1 Data
   233                        ;       $232    .DB     %11111001       $F9     ;Mode Register 0 Data
   234                        ;
   235                        ;       $233    .DB     %00010111       $17     ;Mode Register 2 data
   236                        ;       $234    .DB     %11010011       $D3     ;Mode Register 1 Data
   237                        ;       $235    .DB     %11000001       $C1     ;Mode Register 0 Data
   238                        ;
   239                        ;       10 additional bytes are reserved for additional soft configuration data.
   240                        ;
   241                        ; The Microdrive is initialized and the total LBA count is saved here during startup.
   242                        ;  It is used by various utilities and allows drive capacity sensing without sending additional
   243                        ;  commands to the Microdrive. A total of 4 bytes are used for a 32-bit LBA count. These are saved
   244                        ;  at addresses $23C - $23F. Order is low-word/high-word. Each word is low-byte/high-byte.
   245                        ; Note: these 4 bytes are allocated from the 10 additional bytes noted above.
   246                        ;
   247             0000023C   LOAD_IDE        .EQU    SOFTCFG+28              ;IDE/CF-Card Soft Config Data
   248                        ;
   249                        ;       $23C    .DW                             ;Low order LBA count
   250                        ;       $23E    .DW                             ;High order LBA count
   251                        ;
   252                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   253                        ;
   254             00000240   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $02 following Hardware Config data
   255                        ;       $240                                    ;Start of search buffer (16 bytes)
   256                        ;
   257                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   258                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   259                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   260                        ; Xmodem/CRC Loader is 176 bytes
   261                        ;
   262                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   263                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   264                        ; a CR/LF to the end of each record for a total of 44 bytes.
   265                        ;
   266             00000250   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   267                        ;       $250                                    ;Start of S-Record buffer
   268                        ;
   269                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   270                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   271                        ;
   272             0000027C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   273                        ;       $27C                                    ;Start of Receive buffer for Xmodem
   274                        ;
   275                        ;Page $02 is completely allocated for Buffers, Config Data and Vector pointers.
   276                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   277                        ; being used concurrently.
   278                        ;
   279                        ;**************************************************************************************************
   280                        ;
   281             00000300   IBUF_A          .EQU    $0300                   ;Console Input Buffer - 128 bytes
   282             00000380   OBUF_A          .EQU    $0380                   ;Console Output Buffer - 128 bytes
   283                        ;
   284             00000400   IBUF_B          .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   285             00000480   OBUF_B          .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   286                        ;
   287                        ;**************************************************************************************************
   288                        ;
   289                        ;Page $05 is reserved for future hardware / software expansion
   290                        ;
   291                        ;**************************************************************************************************
   292                        ;
   293                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   294             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
  Fri Apr 11 2025  6:34                                                                                                    Page 7


   295                        ;
   296                        ;Pages $07 - $08 are used for the IDE device Boot Buffer (512 bytes)
   297             00000800   BOOT_BUFFER     .EQU    $0800                   ;Default IDE Boot Buffer address
   298                        ;
   299                        ;**************************************************************************************************
   300                        ;XMODEM Control Character Constants
   301             00000001   SOH             .EQU    $01                     ;Start of Block Header
   302             00000004   EOT             .EQU    $04                     ;End of Text marker
   303             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   304             00000015   NAK             .EQU    $15                     ;Bad Block Acknowledged
   305             00000018   CAN             .EQU    $18                     ;Cancel character
   306                        ;
   307                        ;**************************************************************************************************
   308                        ;
   309                        ;**************************************************************************************************
   310                        ;
   311                        ;DOS/65 can be called from the Monitor via the Ctrl-B command. - Temporary!
   312                        ;The start location is just added here for convenience, but should be changed if needed.
   313                        ;
   314             0000D400   DOS_65          .EQU    $D400                   ;Default SIM location to Boot DOS/65 (optional)
   315                        ;
   316                        ;**************************************************************************************************
   317                        ;
   318             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   319                        ;
   320                        ;**************************************************************************************************
   321                        ;
   322             0000FE00   SC28L92_BASE    .EQU    IOPAGE+$00              ;Beginning of Console UART address
   323                        ;
   324             0000FE00   UART_MODEREG_A  .EQU    SC28L92_BASE+$00        ;MR0/MR1/MR2 Port A sequential (READ/WRITE)
   325             0000FE01   UART_STATUS_A   .EQU    SC28L92_BASE+$01        ;UART Status Register Port A (READ)
   326             0000FE01   UART_CLKSEL_A   .EQU    SC28L92_BASE+$01        ;UART Clock Select Port A (WRITE)
   327             0000FE02   UART_RESERVE_A  .EQU    SC28L92_BASE+$02        ;UART Reserved Port A (READ)
   328             0000FE02   UART_COMMAND_A  .EQU    SC28L92_BASE+$02        ;UART Command Register Port A (WRITE)
   329             0000FE03   UART_RECEIVE_A  .EQU    SC28L92_BASE+$03        ;UART Receive Register Port A (READ)
   330             0000FE03   UART_TRANSMIT_A .EQU    SC28L92_BASE+$03        ;UART Transmit Register Port A (WRITE)
   331                        ;
   332             0000FE04   UART_PORT_CHG   .EQU    SC28L92_BASE+$04        ;UART Input Port Change Register (READ)
   333             0000FE04   UART_AUXCR      .EQU    SC28L92_BASE+$04        ;UART Aux Command Register (WRITE)
   334             0000FE05   UART_ISR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Status Register (READ)
   335             0000FE05   UART_IMR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Mask Register (WRITE)
   336                        ;
   337             0000FE06   UART_CNTU       .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Register (READ)
   338             0000FE06   UART_CNTUP      .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   339             0000FE07   UART_CNTL       .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Register (READ)
   340             0000FE07   UART_CNTLP      .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   341                        ;
   342             0000FE08   UART_MODEREG_B  .EQU    SC28L92_BASE+$08        ;MR0/MR1/MR2 Port B sequential (READ/WRITE)
   343             0000FE09   UART_STATUS_B   .EQU    SC28L92_BASE+$09        ;UART Status Register Port B (READ)
   344             0000FE09   UART_CLKSEL_B   .EQU    SC28L92_BASE+$09        ;UART Clock Select Port B (WRITE)
   345             0000FE0A   UART_RESERVE_B  .EQU    SC28L92_BASE+$0A        ;UART Reserved Port B (READ)
   346             0000FE0A   UART_COMMAND_B  .EQU    SC28L92_BASE+$0A        ;UART Command Register Port B (WRITE)
   347             0000FE0B   UART_RECEIVE_B  .EQU    SC28L92_BASE+$0B        ;UART Receive Register Port B (READ)
   348             0000FE0B   UART_TRANSMIT_B .EQU    SC28L92_BASE+$0B        ;UART Transmit Register Port B (WRITE)
   349                        ;
   350             0000FE0C   UART_MISC       .EQU    SC28L92_BASE+$0C        ;UART Miscellaneous Register Intel (READ/WRITE)
   351             0000FE0D   UART_INPUT_PORT .EQU    SC28L92_BASE+$0D        ;UART Input Port Register (READ)
   352             0000FE0D   UART_OUT_CFG    .EQU    SC28L92_BASE+$0D        ;UART Ouput Port Config Register (WRITE)
   353             0000FE0E   UART_START_CNT  .EQU    SC28L92_BASE+$0E        ;UART Start Counter Command (READ)
   354             0000FE0E   UART_SOPR_CMD   .EQU    SC28L92_BASE+$0E        ;UART Set Output Port Bits Register (WRITE)
   355             0000FE0F   UART_STOP_CNT   .EQU    SC28L92_BASE+$0F        ;UART Stop Counter Command (READ)
   356             0000FE0F   UART_ROPR_CMD   .EQU    SC28L92_BASE+$0F        ;UART Reset Output Port Bits Register (WRITE)
   357                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 8


   358                        ;Additional Hardware - DS-1318 RTC
   359                        ; Replacement for DS15x1 RTC
   360                        ; - this RTC uses a simple 32-bit counter implemented as 4 bytes
   361                        ; - this will be setup with EPOCH time as a 32-bit count.
   362                        ; - this greatly simplifies the BIOS routines to support.
   363                        ; - the setup will be done by a separate utility application
   364                        ; - reading the RTC and showing as Day/Month/Year will be done via a loadable application
   365                        ;
   366             0000FE20   RTC_BASE        .EQU    IOPAGE+$20              ;Start of RTC Regsters
   367                        ;
   368             0000FE20   RTC_SUB_SEC_0   .EQU    RTC_BASE+0              ;Sub-Seconds 0
   369             0000FE21   RTC_SUB_SEC_1   .EQU    RTC_BASE+1              ;Sub-Seconds 1
   370                        ;
   371             0000FE22   RTC_SECONDS_0   .EQU    RTC_BASE+2              ;Clock Seconds 0
   372             0000FE23   RTC_SECONDS_1   .EQU    RTC_BASE+3              ;Clock Seconds 1
   373             0000FE24   RTC_SECONDS_2   .EQU    RTC_BASE+4              ;Clock Seconds 2
   374             0000FE25   RTC_SECONDS_3   .EQU    RTC_BASE+5              ;Clock Seconds 3
   375                        ;
   376             0000FE26   RTC_ALARM_0     .EQU    RTC_BASE+6              ;Alarm Seconds 0
   377             0000FE27   RTC_ALARM_1     .EQU    RTC_BASE+7              ;Alarm Seconds 1
   378             0000FE28   RTC_ALARM_2     .EQU    RTC_BASE+8              ;Alarm Seconds 2
   379             0000FE29   RTC_ALARM_3     .EQU    RTC_BASE+9              ;Alarm Seconds 3
   380                        ;
   381             0000FE2A   RTC_CONTROL_A   .EQU    RTC_BASE+10             ;Control Register A
   382             0000FE2B   RTC_CONTROL_B   .EQU    RTC_BASE+11             ;Control Register B
   383                        ;
   384             0000FE2C   RTC_STATUS      .EQU    RTC_BASE+12             ;Status Register
   385                        ;
   386                        ; Adding BIOS definitions for 16-bit IDE interface
   387                        ; uses two addresses for Upper Byte Latch read / write
   388                        ; uses eight addresses for Command Block Registers
   389                        ; uses two addresses for Control Block Registers
   390                        ;
   391             0000FE20   RTC_IDE_BASE    .EQU    IOPAGE+$20              ;
   392                        ;
   393             0000FE34   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   394             0000FE35   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   395                        ;
   396                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   397                        ; Hardware Adapter provides a 16-bit IDE Port per:
   398                        ;  Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   399                        ;
   400                        ; Control Block Registers
   401             0000FE36   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   402             0000FE36   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   403             0000FE37   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   404                        ;
   405                        ; Command Block Registers
   406             0000FE38   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   407             0000FE39   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   408             0000FE39   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   409             0000FE3A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   410             0000FE3B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   411             0000FE3C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   412             0000FE3D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   413             0000FE3E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   414             0000FE3F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   415             0000FE3F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   416                        ;
   417                        ;**************************************************************************************************
   418                        ;
   419                                .END
    79                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 9


    80                        ;**************************************************************************************************
    81                        ;Monitor JUMP table: 32 JUMP calls are Defined, only two shown here are required.
    82                        ; Note: Monitor entry points are currently for debugging purposes.
    83                        ; - once the BIOS and Bootable hardware and software is completed, these will be changed.
    84                        ;
    85             0000F000   M_COLD_MON      .EQU    $F000           ;Call 00        Monitor Cold Start
    86             0000F003   M_WARM_MON      .EQU    $F003           ;Call 01        Monitor Warm Start
    87                        ;
    88                        ;**************************************************************************************************
    89                                .ORG    $F800   ;2KB reserved for BIOS, I/O device selects (48 bytes)                     *
    90                        ;**************************************************************************************************
    91                        ;                                    START OF BIOS CODE                                           *
    92                        ;**************************************************************************************************
    93                        ;C02BIOS version used here is 5.0 (new release with IDE bootable support)
    94                        ;
    95                        ; Contains the base BIOS routines in top 2KB of Flash ROM
    96                        ; - $F800 - $FDFF Core BIOS routines (1536 bytes)
    97                        ; - $FE00 - $FE3F reserved for hardware devices (64 bytes)
    98                        ; - $FE40 - $FEFF used for Vector and Hardware configuration and text data (192 bytes)
    99                        ; - $FF00 - $FFFF JMP table, startup, NMI/BRK/IRQ pre-post routines, init, BIOS msg (256 bytes)
   100                        ;
   101                        ; UPDATES:
   102                        ; NOTE: Version 5.x BIOS changes include:
   103                        ; - Vector and Config Data moved to Page $02
   104                        ; - Console I/O buffer moved to Page $03
   105                        ; - Second Serial port buffer moved to Page $04
   106                        ; - Page $05 reserved for future expansion/changes
   107                        ; - Disk LBA buffer is at Pages $06 - $07
   108                        ;
   109                        ;**************************************************************************************************
   110                        ; The following 32 functions are provided by BIOS via the JMP Table
   111                        ;
   112                        ; $FF00 IDE_RESET       ;Reset IDE Controller (Recalibrate Command)
   113                        ; $FF03 IDE_GET_STAT    ;Get Status and Error code
   114                        ; $FF06 IDE_IDENTIFY    ;Load IDE Identity Data to LBA Buffer
   115                        ; $FF09 IDE_READ_LBA    ;Read LBA into memory
   116                        ; $FF0C IDE_WRITE_LBA   ;Write LBA from memory
   117                        ; $FF0F IDE_SET_LBA     ;Set LBA number (24-bit support only)
   118                        ; $FF12 IDE_SET_ADDR    ;Set LBA transfer address (16-bit plus block count)
   119                        ; $FF15 IDE_EN_CACHE    ;Enable/Disable IDE Write Cache
   120                        ;
   121                        ; $FF18 CHR_STAT        ;Check Console Status
   122                        ; $FF1B CHRIN_NW        ;Data input from console (no waiting, clear carry if none)
   123                        ; $FF1E CHRIN           ;Data input from console
   124                        ; $FF21 CHROUT          ;Data output to console
   125                        ;
   126                        ; $FF24 CHRIN2          ;Data input from aux port
   127                        ; $FF27 CHROUT2         ;Data output to aux port
   128                        ;
   129                        ; $FF2A CNT_INIT        ;Reset Benchmark timing counters
   130                        ; $FF2D CNT_STRT        ;Start 10ms Benchmark timing counter
   131                        ; $FF30 CNT_STOP        ;Stop 10ms Benchmark timing counter
   132                        ; $FF33 CNT_DISP        ;Display Benchmark counter timing
   133                        ;
   134                        ; $FF36 SET_DLY         ;Set delay value for milliseconds and 16-bit counter
   135                        ; $FF39 EXE_MSDLY       ;Execute millisecond delay 1-256 * 10 milliseconds
   136                        ; $FF3C EXE_LGDLY       ;Execute long delay; millisecond delay * 16-bit count
   137                        ;
   138                        ; $FF3F PROMPTR         ;Print string to console
   139                        ;
   140                        ; $FF42 RTC_INIT        ;Initialize software RTC from DS1318 hardware RTC
   141                        ;
   142                        ; $FF45 PRSTAT          ;Display CPU registers to console
  Fri Apr 11 2025  6:34                                                                                                    Page 10


   143                        ;
   144                        ; $FF48 Reserved        ;Reserved for future expansion
   145                        ;
   146                        ; $FF4B INIT_VEC        ;Initialize soft vectors at $0200 from ROM
   147                        ; $FF4E INIT_CFG        ;Initialize soft config data at $0220 from ROM
   148                        ;
   149                        ; $FF51 INIT_28L92      ;Initialize SC28L92 - Port A as console at 115.2K, 8-N-1 RTS/CTS
   150                        ; $FF54 RESET_28L92     ;Reset SC28L92 - called before INIT_28L92
   151                        ;
   152                        ; $FF57 PANIC           ;Execute PANIC routine (disables IDE controller)
   153                        ; $FF5A BOOT_IDE        ;Boot IDE device - load LBA 0 to $0800 and jump to it
   154                        ;
   155                        ; $FF5D COLDSTRT        ;System cold start - RESET vector for W65C02S
   156                        ;**************************************************************************************************
   157                        ;                    Data In and Out routines for Console I/O buffer                              *
   158                        ;**************************************************************************************************
   159                        ;Data Input Port A routine:
   160                        ;
   161                        ; CHR_STAT checks to see if the input buffer has any characters and returns with the buffer count
   162                        ; in the A Reg. Any value from $00 - $7F is valid.
   163                        ;
   164                        ; CHRIN_NW uses CHRIN, returns if data is not available from the buffer with carry flag clear,
   165                        ; - else returns with data in A reg and carry flag set.
   166                        ;
   167                        ; CHRIN waits for data to be in the receive buffer, then returns with data in A reg.
   168                        ; Receive is IRQ driven/buffered with a size of 128 bytes.
   169                        ;
   170 00:F800: A5 D9        CHR_STAT        LDA     ICNT_A          ;Get Buffer Count (4)
   171 00:F802: 60                           RTS                     ;Return to caller (6)
   172                        ;
   173 00:F803: 18           CHRIN_NW        CLC                     ;Clear Carry flag for no data (2)
   174 00:F804: A5 D9                        LDA     ICNT_A          ;Get buffer count (4)
   175 00:F806: D0 05                        BNE     GET_CH          ;Branch if buffer is not empty (2/3)
   176 00:F808: 60                           RTS                     ;Or return to caller (6)
   177                        ;
   178 00:F809: A5 D9        CHRIN           LDA     ICNT_A          ;Get data count (3)
   179 00:F80B: F0 FC                        BEQ     CHRIN           ;If zero (no data, loop back) (2/3)
   180                        ;
   181 00:F80D: 5A           GET_CH          PHY                     ;Save Y Reg (3)
   182 00:F80E: A4 DA                        LDY     IHEAD_A         ;Get the buffer head pointer (3)
   183 00:F810: B9 00 03                     LDA     IBUF_A,Y        ;Get the data from the buffer (4)
   184 00:F813: E6 DA                        INC     IHEAD_A         ;Increment head pointer (5)
   185 00:F815: 77 DA                        RMB7    IHEAD_A         ;Strip off bit 7, 128 bytes only (5)
   186 00:F817: C6 D9                        DEC     ICNT_A          ;Decrement the buffer count (5)
   187                        ;
   188 00:F819: 7A                           PLY                     ;Restore Y Reg (4)
   189 00:F81A: 38                           SEC                     ;Set Carry flag for data available (2)
   190 00:F81B: 60                           RTS                     ;Return to caller with data in A Reg (6)
   191                        ;
   192                        ;Data Output Port A routine:
   193                        ; CHROUT puts the data in the A Reg into the xmit buffer, data in A Reg is preserved on exit.
   194                        ; Transmit is IRQ driven/buffered with a size of 128 bytes.
   195                        ;
   196 00:F81C: 5A           CHROUT          PHY                     ;Save Y Reg (3)
   197 00:F81D: A4 DC        OUTCH           LDY     OCNT_A          ;Get data output count in buffer (3)
   198 00:F81F: 30 FC                        BMI     OUTCH           ;Check against limit, loop back if full (2/3)
   199                        ;
   200 00:F821: A4 DE                        LDY     OTAIL_A         ;Get the buffer tail pointer (3)
   201 00:F823: 99 80 03                     STA     OBUF_A,Y        ;Place data in the buffer (5)
   202 00:F826: E6 DE                        INC     OTAIL_A         ;Increment Tail pointer (5)
   203 00:F828: 77 DE                        RMB7    OTAIL_A         ;Strip off bit 7, 128 bytes only (5)
   204 00:F82A: E6 DC                        INC     OCNT_A          ;Increment data count (5)
   205                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 11


   206 00:F82C: A0 04                        LDY     #%00000100      ;Get mask for xmit on (2)
   207 00:F82E: 8C 02 FE                     STY     UART_COMMAND_A  ;Turn on xmit (4)
   208                        ;
   209 00:F831: 7A                           PLY                     ;Restore Y Reg (4)
   210 00:F832: 60                           RTS                     ;Return to caller (6)
   211                        ;
   212                        ;Data Input Port B routine:
   213                        ; CHRIN2 waits for data to be in the receive buffer, then returns with data in A reg.
   214                        ; Receive is IRQ driven/buffered with a size of 128 bytes.
   215                        ;
   216 00:F833: A5 DF        CHRIN2          LDA     ICNT_B          ;Get data count (3)
   217 00:F835: F0 FC                        BEQ     CHRIN2          ;If zero (no data, loop back) (2/3)
   218                        ;
   219 00:F837: 5A                           PHY                     ;Save Y Reg (3)
   220 00:F838: A4 DA                        LDY     IHEAD_A         ;Get the buffer head pointer (3)
   221 00:F83A: B9 00 04                     LDA     IBUF_B,Y        ;Get the data from the buffer (4)
   222 00:F83D: E6 E0                        INC     IHEAD_B         ;Increment head pointer (5)
   223 00:F83F: 77 E0                        RMB7    IHEAD_B         ;Strip off bit 7, 128 bytes only (5)
   224 00:F841: C6 DF                        DEC     ICNT_B          ;Decrement the buffer count (5)
   225                        ;
   226 00:F843: 7A                           PLY                     ;Restore Y Reg (4)
   227 00:F844: 60                           RTS                     ;Return to caller with data in A Reg (6)
   228                        ;
   229                        ;Data Output Port B routine:
   230                        ; CHROUT2 puts the data in the A Reg into the xmit buffer, data in A Reg is preserved on exit.
   231                        ; Transmit is IRQ driven/buffered with a size of 128 bytes.
   232                        ;
   233 00:F845: 5A           CHROUT2         PHY                     ;Save Y Reg (3)
   234 00:F846: A4 E2        OUTCH2          LDY     OCNT_B          ;Get data output count in buffer (3)
   235 00:F848: 30 FC                        BMI     OUTCH2          ;Check against limit, loop back if full (2/3)
   236                        ;
   237 00:F84A: A4 E4                        LDY     OTAIL_B         ;Get the buffer tail pointer (3)
   238 00:F84C: 99 80 04                     STA     OBUF_B,Y        ;Place data in the buffer (5)
   239 00:F84F: E6 E4                        INC     OTAIL_B         ;Increment Tail pointer (5)
   240 00:F851: 77 E4                        RMB7    OTAIL_B         ;Strip off bit 7, 128 bytes only (5)
   241 00:F853: E6 E2                        INC     OCNT_B          ;Increment data count (5)
   242                        ;
   243 00:F855: A0 04                        LDY     #%00000100      ;Get mask for xmit on (2)
   244 00:F857: 8C 0A FE                     STY     UART_COMMAND_B  ;Turn on xmit (4)
   245                        ;
   246 00:F85A: 7A                           PLY                     ;Restore Y Reg (4)
   247 00:F85B: 60                           RTS                     ;Return to caller (6)
   248                        ;
   249                        ;**************************************************************************************************
   250                        ;START of IDE Data Transfer Routines for Hitachi 3K8 MicroDrive
   251                        ; These routines requires loading the requested LBA into the appropriate registers and
   252                        ; issuing the READ or WRITE command. The LBA limit supported for the BIOS are bits 0-23,
   253                        ; so bits 24-27 are always set to 0. This provides access to IDE devices up to 8GB.
   254                        ;
   255                        ; Once the registers/parameters are setup, the Read or Write Block command is issued.
   256                        ; This results in an interrupt being generated. The ISR handles the transfer of LBA
   257                        ; data from the IDE Drive to memory. Write operations move data from memory to IDE Drive here,
   258                        ; but uses an interrupt to finalize the transfer.
   259                        ;
   260                        ; The registers used are the same for read/write. These are:
   261                        ;
   262                        ;       IDE_COMMAND = function requested (20h = READ LBA command - 30h = WRITE LBA command)
   263                        ;       IDE_DRV_HEAD = (Upper 4 bits) used as:
   264                        ;               bit 7 = 1 per Seagate documentation
   265                        ;               bit 6 = 1 for LBA mode
   266                        ;               bit 5 = 1 per Seagate documentation
   267                        ;               bit 4 = 0 for Drive 0
   268                        ;       IDE_DRV_HEAD = LBA Address bits 27-24 (lower 4 bits) - not used, always 0000
  Fri Apr 11 2025  6:34                                                                                                    Page 12


   269                        ;       IDE_CYL_HIGH = LBA Address bits 23-16
   270                        ;       IDE_CYL_LOW = LBA Address bits 15-8
   271                        ;       IDE_SCT_NUM = LBA Address bits 7-0
   272                        ;       IDE_SCT_CNT = number of blocks to read
   273                        ;**************************************************************************************************
   274                        ;
   275                        IDE_READ_LBA                            ;Read a Block of data from IDE device
   276                        ;
   277 00:F85C: 20 D5 F8                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   278 00:F85F: A9 20                        LDA     #$20            ;Get Read LBA command (2)
   279                        IDENT_READ                              ;Identify Command jumps here to complete
   280 00:F861: B7 FF                        SMB3    MATCH           ;Set Read LBA bit (5)
   281 00:F863: 8D 3F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   282                        ;
   283                        LBA_RD_CMD
   284 00:F866: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   285 00:F869: 30 FB                        BMI     LBA_RD_CMD      ;Loop until IDE controller not Busy (2/3)
   286                        ;
   287                        LBA_RD_WAIT
   288 00:F86B: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   289 00:F86E: C9 50                        CMP     #$50            ;Compare for ready (2)
   290 00:F870: D0 04                        BNE     LBA_RD_ERR      ;If not, check for error condition (2/3)
   291                        LBA_RD_OK
   292 00:F872: BF FF FD                     BBS3    MATCH,LBA_RD_OK ;Wait for Read completed via ISR (5/6,7)
   293 00:F875: 60                           RTS                     ;Return to caller (status in A Reg) (6)
   294                        LBA_RD_ERR
   295 00:F876: 4A                           LSR     A               ;Shift error bit to carry (2)
   296 00:F877: 90 F2                        BCC     LBA_RD_WAIT     ;If clear, loop back and continue waiting (2/3)
   297                        ;
   298 00:F879: 37 FF                        RMB3    MATCH           ;Reset Read LBA bit (no ISR invoked) (5)
   299                        IDE_RWV_FIN
   300 00:F87B: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   301 00:F87E: 85 FB                        STA     IDE_STATUS_RAM  ;Update RAM Status Register (3)
   302 00:F880: 60                           RTS                     ;Return to caller (6)
   303                        ;**************************************************************************************************
   304                        ;
   305                        IDE_WRITE_LBA                           ;Write a block of data to LBA
   306                        ;
   307 00:F881: 20 D5 F8                     JSR     IDE_SET_PARMS   ;Setup required parameters (6)
   308                        ;
   309 00:F884: A7 FF                        SMB2    MATCH           ;Set Write LBA bit (5)
   310 00:F886: A9 30                        LDA     #$30            ;Get Write LBA command (2)
   311 00:F888: 8D 3F FE                     STA     IDE_COMMAND     ;Send command to IDE Controller (4)
   312                        LBA_WR_CMD
   313 00:F88B: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   314 00:F88E: 30 FB                        BMI     LBA_WR_CMD      ;Loop until IDE controller not Busy (2/3)
   315 00:F890: 4A                           LSR     A               ;Shift Error bit into Carry flag (2)
   316 00:F891: B0 30                        BCS     IDE_WRITE_ERR   ;If Carry set, IDE error (2/3)
   317                        ;
   318                        ; Write Block routine integrated into IDE_WRITE_LBA
   319                        ; - High byte needs to be loaded into the latch before the
   320                        ;   low byte is loaded into the Data Register!
   321                        ;
   322                        IDE_WRITE_BLK                           ;Write a block of data
   323 00:F893: 5A                           PHY                     ;Save Y reg (3)
   324 00:F894: A0 01                        LDY     #$01            ;Set offset for high byte latch (2)
   325                        ;
   326                        IDE_WRITE_LOOP
   327 00:F896: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   328 00:F899: 29 08                        AND     #%00001000      ;Check for DRQ active (2)
   329 00:F89B: F0 18                        BEQ     IDE_WR_FIN      ;If not active, exit (below) (2/3)
   330                        IDE_WR_WBLK
   331 00:F89D: B1 F8                        LDA     (BIOS_XFERL),Y  ;Get first byte of buffer+1 (5)
  Fri Apr 11 2025  6:34                                                                                                    Page 13


   332 00:F89F: 8D 35 FE                     STA     IDE_16_WRITE    ;Place into high byte latch (4)
   333 00:F8A2: B2 F8                        LDA     (BIOS_XFERL)    ;Get first byte of buffer (5)
   334 00:F8A4: 8D 38 FE                     STA     IDE_DATA        ;Write buffer to IDE (writes a word) (4)
   335                        ;
   336                        ; - Buffer index needs to be incremented twice
   337                        ;
   338 00:F8A7: E6 F8                        INC     BIOS_XFERL      ;Increment pointers once (5)
   339 00:F8A9: D0 02                        BNE     IDE_WR_BLK1     ; (2/3)
   340 00:F8AB: E6 F9                        INC     BIOS_XFERH      ; (5)
   341                        IDE_WR_BLK1
   342 00:F8AD: E6 F8                        INC     BIOS_XFERL      ;Increment pointers again (5)
   343 00:F8AF: D0 E5                        BNE     IDE_WRITE_LOOP  ; (2/3)
   344 00:F8B1: E6 F9                        INC     BIOS_XFERH      ; (5)
   345 00:F8B3: 80 E1                        BRA     IDE_WRITE_LOOP  ;Loop back for 256 words (3)
   346                        ;
   347                        IDE_WR_FIN
   348                        ; When DRQ ends, 512 bytes have been sent to IDE controller. Controller then sets BUSY,
   349                        ; when finished processing data, controller clears BUSY and generates an interrupt.
   350                        ; So, we test for BUSY first and wait until the block is written.
   351                        ;
   352 00:F8B5: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   353 00:F8B8: 30 FB                        BMI     IDE_WR_FIN      ;Loop until BUSY bit is clear (2/3)
   354                        ;
   355 00:F8BA: C6 FA                        DEC     BIOS_XFERC      ;Decrement Block Count to transfer (5)
   356 00:F8BC: D0 D8                        BNE     IDE_WRITE_LOOP  ;If not zero, branch back to write next LBA (2/3)
   357                        ;
   358                        WR_WAIT
   359 00:F8BE: AF FF FD                     BBS2    MATCH,WR_WAIT   ;Wait for Write completed via ISR (5/6,7)
   360 00:F8C1: 7A                           PLY                     ;Restore Y reg (4)
   361 00:F8C2: 60                           RTS                     ;Return to caller (6)
   362                        IDE_WRITE_ERR
   363 00:F8C3: 27 FF                        RMB2    MATCH           ;Reset Write LBA bit (no ISR) (5)
   364 00:F8C5: 80 B4                        BRA     IDE_RWV_FIN     ;Branch and finish up (3)
   365                        ;**************************************************************************************************
   366                        ;
   367                        IDE_SET_ADDRESS                         ;Set Address for LBA (read/write)
   368                        ;
   369                        ;This routine uses the A,Y,X registers to setup the address in memory that a block
   370                        ; will be read to or written from (16-bit address), along with the block count.
   371                        ; The Register usage is as follows:
   372                        ;       A Register = Memory address low byte
   373                        ;       Y Register = Memory address high byte
   374                        ;       X Register = Block count to transfer
   375 00:F8C7: 85 F2                        STA     LBA_ADDR_LOW    ;Set LBA low byte address (3)
   376 00:F8C9: 84 F3                        STY     LBA_ADDR_HIGH   ;Set LBA high byte address (3)
   377 00:F8CB: 86 F4                        STX     LBA_XFER_CNT    ;Set LBA Block count for xfer (3)
   378 00:F8CD: 60                           RTS                     ;Return to caller (6)
   379                        ;**************************************************************************************************
   380                        ;
   381                        IDE_SET_LBA                             ;Set LBA block for transfer (read/write)
   382                        ;
   383                        ;This routine sets the variables used to select the starting LBA for transfer.
   384                        ; The Register usage is as follows:
   385                        ;       A Register = LBA Address bits 7-0
   386                        ;       Y Register = LBA Address bits 15-8
   387                        ;       X Register = LBA Address bits 23-16
   388 00:F8CE: 85 F5                        STA     LBA_LOW_BYTE    ;Store Address bits 0-7 (3)
   389 00:F8D0: 84 F6                        STY     LBA_HIGH_BYTE   ;Store Address bits 8-15 (3)
   390 00:F8D2: 86 F7                        STX     LBA_EXT_BYTE    ;Store Address bits 16-23 (3)
   391 00:F8D4: 60                           RTS                     ;Return to caller (6)
   392                        ;**************************************************************************************************
   393                        ;
   394                        IDE_SET_PARMS                           ;Set All parameters for LBA transfers
  Fri Apr 11 2025  6:34                                                                                                    Page 14


   395                        ;
   396                        ;This routine sets the LBA number used for all transfers.
   397                        ; The IDE Controller is checked first to ensure it's ready to receive parameters, then the
   398                        ; the requested LBA (stored in Page Zero variables) are loaded into the IDE Controller registers,
   399                        ; followed by the required Mode parameters. The transfer address is then setup which points to
   400                        ; the memory location for the start of the data transfer.
   401                        ;
   402 00:F8D5: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   403 00:F8D8: 30 FB                        BMI     IDE_SET_PARMS   ;Loop until BUSY bit is clear (2/3)
   404                        ;
   405                        ; Transfer parameters from working memory to IDE drive
   406                        ;
   407 00:F8DA: A5 F7                        LDA     LBA_EXT_BYTE    ;Set LBA bits 23-16 (3)
   408 00:F8DC: 8D 3D FE                     STA     IDE_CYL_HIGH    ;Send to IDE (4)
   409 00:F8DF: A5 F6                        LDA     LBA_HIGH_BYTE   ;Set LBA bits 15-8 (3)
   410 00:F8E1: 8D 3C FE                     STA     IDE_CYL_LOW     ;Send to IDE (4)
   411 00:F8E4: A5 F5                        LDA     LBA_LOW_BYTE    ;Get LBA bits 7-0 (3)
   412 00:F8E6: 8D 3B FE                     STA     IDE_SCT_NUM     ;Send to IDE (4)
   413 00:F8E9: A5 F4                        LDA     LBA_XFER_CNT    ;Get Block count to read (3)
   414 00:F8EB: 8D 3A FE                     STA     IDE_SCT_CNT     ;Send to IDE (4)
   415                        ;
   416                        IDE_SET_PARMS2                          ;Set partial parameters (non LBA xfer commands)
   417                        ;
   418 00:F8EE: A9 E0                        LDA     #%11100000      ;Set Drive 0, LBA mode, LBA bits 27-24 as 0 (2)
   419 00:F8F0: 8D 3E FE                     STA     IDE_DRV_HEAD    ;Send to IDE controller (4)
   420                        ;
   421 00:F8F3: A5 F2                        LDA     LBA_ADDR_LOW    ;Setup buffer address (3)
   422 00:F8F5: 85 F8                        STA     BIOS_XFERL      ;Store low byte (3)
   423 00:F8F7: A5 F3                        LDA     LBA_ADDR_HIGH   ;Block Buffer Address (3)
   424 00:F8F9: 85 F9                        STA     BIOS_XFERH      ;Store high byte (3)
   425 00:F8FB: A5 F4                        LDA     LBA_XFER_CNT    ;Get Block count to read (3)
   426 00:F8FD: 85 FA                        STA     BIOS_XFERC      ;Set BIOS Block count to Xfer (3)
   427 00:F8FF: 64 FB                        STZ     IDE_STATUS_RAM  ;Clear RAM Status Register, ISR updates it (3)
   428 00:F901: 60                           RTS                     ;Return to caller (6)
   429                        ;**************************************************************************************************
   430                        ;
   431                        TST_IDE_RDY
   432                        ;
   433                        ;Test for IDE Controller Ready
   434                        ;
   435                        ;This routine tests that the IDE Controller is ready and can accept a command for execution.
   436                        ; There are two bits in the status to qualify this:
   437                        ; Bit 6 is for Ready and bit 4 is for Seek Complete. Both should be active to qualify the
   438                        ; drive as being ready (per Hitachi Microdrive documentation).
   439                        ; Note: It's also possible that bit 0 might be set, which indicates an error condition.
   440                        ; If an error has occurred, we should test for this as well, and set the carry flag to
   441                        ; ensure proper drive sensing.
   442                        ;
   443 00:F902: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
   444 00:F905: C9 51                        CMP     #$51            ;Test for Ready and Error bits on (2)
   445 00:F907: F0 3D                        BEQ     IDE_RD_ERR      ;If yes, branch to error routine (2/3)
   446 00:F909: C9 50                        CMP     #$50            ;Test for Ready bits on (2)
   447 00:F90B: D0 F5                        BNE     TST_IDE_RDY     ;If not, loop back until ready (2/3)
   448 00:F90D: 60                           RTS                     ;Return to Caller (6)
   449                        ;**************************************************************************************************
   450                        ;
   451                        IDE_BOOT
   452                        ;
   453                        ;IDE Controller Boot routine
   454                        ;
   455                        ;This routine sets up the IDE Controller to load the first logical block from the disk.
   456                        ; This should be the partition record. Once loaded, the IDE controller is checked for any
   457                        ; error condition, then the partition record data is checked for the proper signature.
  Fri Apr 11 2025  6:34                                                                                                    Page 15


   458                        ; If the signature is correct, control is turned over to the partition record code,
   459                        ; otherwise, the appropiate error message is displayed and the system is halted.
   460                        ;
   461 00:F90E: 5F FF 35                     BBR5    MATCH,IDE_RD_ERR        ;Check for Drive Present, branch if not (5/6)
   462                        ;
   463 00:F911: A9 00                        LDA     #$00            ;Load low byte LBA address (2)
   464 00:F913: A8                           TAY                     ;Same for high LBA address (2)
   465 00:F914: AA                           TAX                     ;Same for extended LBA address (2)
   466 00:F915: 20 CE F8                     JSR     IDE_SET_LBA     ;Call BIOS to setup LBA number (6)
   467                        ;
   468 00:F918: A9 00                        LDA     #<LBA_BUFFER    ;Set Address low byte (2)
   469 00:F91A: A0 06                        LDY     #>LBA_BUFFER    ;Set Address high byte (2)
   470 00:F91C: A2 01                        LDX     #$01            ;Set Block count to 1 (2)
   471 00:F91E: 20 C7 F8                     JSR     IDE_SET_ADDRESS ;Set Xfer address and block count (6)
   472                        ;
   473 00:F921: 20 5C F8                     JSR     IDE_READ_LBA    ;Read Block Zero to Buffer (6)
   474 00:F924: A5 FB                        LDA     IDE_STATUS_RAM  ;Get Status from BIOS call (3)
   475 00:F926: 4A                           LSR     A               ;Shift error bit to carry (2)
   476 00:F927: B0 1D                        BCS     IDE_RD_ERR      ;Branch if error (2/3)
   477                        ;
   478 00:F929: A2 FC                        LDX     #252            ;Get offset to signature (2)
   479 00:F92B: BD 00 06                     LDA     LBA_BUFFER,X    ;Get signature byte (4)
   480 00:F92E: C9 02                        CMP     #$02            ;Compare to $02 (2)
   481 00:F930: D0 0B                        BNE     BAD_PART_BLK    ;Branch if incorrect (2/3)
   482 00:F932: E8                           INX                     ;Increment index to next signature byte (2)
   483 00:F933: BD 00 06                     LDA     LBA_BUFFER,X    ;Get signature byte (4)
   484 00:F936: C9 65                        CMP     #$65            ;Compare to $65 (2)
   485 00:F938: D0 03                        BNE     BAD_PART_BLK    ;Branch if incorrect (2/3)
   486                        ;
   487                        ;Signature is good! Now just jump to the Partition Record in LBA_BUFFER
   488                        ;
   489                        ; For now, we just jump to the Monitor Cold Start vector. Once the Boot Record code is
   490                        ; completed, we'll manage a user timeout feature to either default boot the IDE device
   491                        ; or allow the user to interrupt the IDE boot and jump to the Monitor.
   492                        ;
   493                        ;                JMP     LBA_BUFFER      ;We're done, execute partition code
   494 00:F93A: 4C 00 F0                     JMP     M_COLD_MON      ;Safety for debug (3)
   495                        ;
   496                        BAD_PART_BLK
   497 00:F93D: A9 C0                        LDA     #<BPART_MSG     ;Bad Partition message (2)
   498 00:F93F: A0 FE                        LDY     #>BPART_MSG     ; (2)
   499 00:F941: 20 E6 F9                     JSR     PROMPTR         ;Send Message to console (6)
   500                        ;
   501 00:F944: 80 10                        BRA     IDE_NO_BOOT     ;Enter Monitor Cold Start (3)
   502                        ;
   503                        IDE_RD_ERR
   504 00:F946: A9 B1                        LDA     #<DRIVE_MSG     ;Microdrive Error message (2)
   505 00:F948: A0 FE                        LDY     #>DRIVE_MSG     ; (2)
   506 00:F94A: 20 E6 F9                     JSR     PROMPTR         ;Send Message to console (6)
   507                        ;
   508 00:F94D: 80 07                        BRA    IDE_NO_BOOT      ;Enter Monitor Cold Start (3)
   509                        ;
   510                        IDE_NOT_FOUND
   511 00:F94F: A9 A0                        LDA     #<NO_DRIVE_MSG  ;No Microdrive Error message (2)
   512 00:F951: A0 FE                        LDY     #>NO_DRIVE_MSG  ; (2)
   513 00:F953: 20 E6 F9                     JSR     PROMPTR         ;Send Message to console (6)
   514 00:F956: 4C 00 F0     IDE_NO_BOOT     JMP     M_COLD_MON      ;Enter Monitor Cold Start (3)   
   515                        ;**************************************************************************************************
   516                        ;Delay Routines: SET_DLY sets up the MSDELAY value and also sets the 16-bit Long Delay
   517                        ; On entry, A Reg = 10-millisecond count, X Reg = High multiplier, Y Reg = Low multiplier
   518                        ; these values are used by the EXE_MSDLY and EXE_LGDLY routines. Minimum delay is 10ms
   519                        ; values for MSDELAY are $00-$FF ($00 = 256 times)
   520                        ; values for Long Delay are $0000-$FFFF (0-65535 times MSDELAY)
  Fri Apr 11 2025  6:34                                                                                                    Page 16


   521                        ; longest delay is 65,535*256*10ms = 16,776,960 * 0.01 = 167,769.60 seconds
   522                        ;
   523                        ;NOTE: All delay execution routines preserve registers (EXE_MSDLY, EXE_LGDLY, EXE_XLDLY)
   524                        ;
   525 00:F959: 85 EC        SET_DLY         STA     SETMS           ;Save Millisecond count (3)
   526 00:F95B: 84 ED                        STY     DELLO           ;Save Low multiplier (3)
   527 00:F95D: 86 EE                        STX     DELHI           ;Save High multiplier (3)
   528 00:F95F: 60                           RTS                     ;Return to caller (6)
   529                        ;
   530                        ;EXE MSDELAY routine is the core delay routine. It sets the MSDELAY count value from the
   531                        ; SETMS variable, enables the MATCH flag, then waits for the MATCH flag to clear.
   532                        ;
   533 00:F960: 48           EXE_MSDLY       PHA                     ;Save A Reg (3)
   534 00:F961: F7 FF                        SMB7    MATCH           ;Set MATCH flag bit (5)
   535 00:F963: A5 EC                        LDA     SETMS           ;Get delay seed value (3)
   536 00:F965: 85 EB                        STA     MSDELAY         ;Set MS delay value (3)
   537                        ;
   538 00:F967: FF FF FD     MATCH_LP        BBS7    MATCH,MATCH_LP  ;Test MATCH flag, loop until cleared (5/6,7)
   539 00:F96A: 68                           PLA                     ;Restore A Reg (4)
   540 00:F96B: 60                           RTS                     ;Return to caller (6)
   541                        ;
   542                        ;EXE LONG Delay routine is the 16-bit multiplier for the MSDELAY routine.
   543                        ; It loads the 16-bit count from DELLO/DELHI, then loops the MSDELAY routine
   544                        ; until the 16-bit count is decremented to zero.
   545                        ;
   546 00:F96C: DA           EXE_LGDLY       PHX                     ;Save X Reg (3)
   547 00:F96D: 5A                           PHY                     ;Save Y Reg (3)
   548 00:F96E: A6 EE                        LDX     DELHI           ;Get high byte count (3)
   549 00:F970: E8                           INX                     ;Increment by one (checks for $00 vs $FF) (2)
   550 00:F971: A4 ED                        LDY     DELLO           ;Get low byte count (3)
   551 00:F973: F0 06                        BEQ     SKP_DLL         ;If zero, skip to high count (2/3)
   552 00:F975: 20 60 F9     DO_DLL          JSR     EXE_MSDLY       ;Call millisecond delay (6)
   553 00:F978: 88                           DEY                     ;Decrement low count (2)
   554 00:F979: D0 FA                        BNE     DO_DLL          ;Branch back until done (2/3)
   555                        ;
   556 00:F97B: CA           SKP_DLL         DEX                     ;Decrement high byte index (2)
   557 00:F97C: D0 F7                        BNE     DO_DLL          ;Loop back to D0_DLL (will run 256 times) (2/3)
   558 00:F97E: 7A                           PLY                     ;Restore Y Reg (4)
   559 00:F97F: FA                           PLX                     ;Restore X Reg (4)
   560 00:F980: 60                           RTS                     ;Return to caller (6)
   561                        ;
   562                        ;**************************************************************************************************
   563                        ;COUNTER BENCHMARK TIMING ROUTINES
   564                        ; To enable a level of benchmarking, the following routines are part of C02BIOS version 5.x
   565                        ;
   566                        ; - CNT_INIT is used to zero the timing variables
   567                        ; - CNT_STRT is used to start the timing by setting bit 6 of the MATCH flag
   568                        ; - CNT_STOP is used to stop the timing by clearing bit 6 of the MATCH flag
   569                        ; - CNT_DISP is used to display the benchmark counter output (also stops the timing)
   570                        ;
   571                        ; Using the existing 10ms Jiffy Clock, three bytes of Page zero are used to hold variables;
   572                        ; - MS10_CNT - a 10ms count variable for 0.01 resolution of timing - resets at 100 counts (1 second)
   573                        ; - SECL_CNT - a low byte seconds count
   574                        ; - SECH_CNT - a high byte seconds count
   575                        ; This provides up to 65,535.99 seconds of timing with 0.01 seconds resolution
   576                        ; - NOTE: the count variables reset to zero after 65,535.99 seconds!
   577                        ;
   578                        ; The interrupt handler for the DUART timer increments the timing variables when bit 6 of the
   579                        ; MATCH flag is active.
   580                        ;
   581 00:F981: 67 FF        CNT_INIT        RMB6    MATCH           ;Clear bit 6 of MATCH flag, ensure timing is disabled (5)
   582 00:F983: 64 EF                        STZ     MS10_CNT        ;Zero 10ms timing count (3)
   583 00:F985: 64 F0                        STZ     SECL_CNT        ;Zero low byte of seconds timing count (3)
  Fri Apr 11 2025  6:34                                                                                                    Page 17


   584 00:F987: 64 F1                        STZ     SECH_CNT        ;Zero high byte of seconds timing count (3)
   585 00:F989: 60                           RTS                     ;Return to caller (6)
   586                        ;
   587 00:F98A: E7 FF        CNT_STRT        SMB6    MATCH           ;Set bit 6 of MATCH flag to enable timing (5)
   588 00:F98C: 60                           RTS                     ;Return to caller (6)
   589                        ;
   590 00:F98D: 67 FF        CNT_STOP        RMB6    MATCH           ;Clear bit 6 of MATCH flag to disable timing (5)
   591 00:F98F: 60                           RTS                     ;Return to caller (6)
   592                        ;
   593                        ;Display Benchmark timer:
   594                        ; Benchmark timer is stopped by clearing bit 6 of MATCH flag. Once the Benchmark counter is
   595                        ; stopped, the HEX2ASC routine prints the 16-bit seconds count, followed by a period,
   596                        ; then the HEX8ASC routine prints the hundreds count followed by the "Seconds" message.
   597                        ;
   598 00:F990: 67 FF        CNT_DISP        RMB6    MATCH           ;Stop Benchmark Counter (5)
   599 00:F992: A5 F0                        LDA     SECL_CNT        ;Get seconds low count (3)
   600 00:F994: A4 F1                        LDY     SECH_CNT        ;Get seconds high count (3)
   601 00:F996: 20 BC F9                     JSR     HEX2ASC         ;Print 16-bit decimal value (6)
   602                        ;
   603 00:F999: A9 2E                        LDA     #"."            ;Get period character (2)
   604 00:F99B: 20 1C F8                     JSR     CHROUT          ;Send "." to console (6)
   605 00:F99E: A5 EF                        LDA     MS10_CNT        ;Get hundreds of seconds (3)
   606                        ;
   607                        ; Drop into HEX8ASC
   608                        ;
   609                        ;HEX8ASC - Accepts 8-bit Hexadecimal value (00-99 decimal) and converts to ASCII numeric values.
   610                        ; A Register contains the single byte value on entry and outputs the two ASCII numeric values.
   611                        ; leading zero is output as it is used for showing hundredths of a second after a decimal point.
   612 00:F9A0: A0 FF        HEX8ASC         LDY     #$FF            ;Load Y Reg with "-1" (2)
   613 00:F9A2: 38                           SEC                     ;Set carry for subtraction (2)
   614 00:F9A3: C8           HEX8LP1         INY                     ;Increment 10's count (starts at zero) (2)
   615 00:F9A4: E9 0A                        SBC     #10             ;Subtract 10 decimal (2)
   616 00:F9A6: B0 FB                        BCS     HEX8LP1         ;Branch back if >10 (2/3)
   617 00:F9A8: 69 3A                        ADC     #$3A            ;Add the last 10 back plus $30 (ASCII "0") (2)
   618 00:F9AA: 48                           PHA                     ;Save 1's count to the Stack (3)
   619 00:F9AB: 98                           TYA                     ;Get the 10's count (2)
   620 00:F9AC: 18                           CLC                     ;Clear carry for add (2)
   621 00:F9AD: 69 30                        ADC     #$30            ;Add $30 for ASCII digit (3)
   622 00:F9AF: 20 1C F8                     JSR     CHROUT          ;Print the first digit (10's)
   623 00:F9B2: 68                           PLA                     ;Get 1's count from the Stack (4)
   624 00:F9B3: 20 1C F8                     JSR     CHROUT          ;Print the second digit, return (6)
   625                        ;
   626 00:F9B6: A9 D1                        LDA     #<MSG_SEC       ;Get message for " Seconds" (2)
   627 00:F9B8: A0 FE                        LDY     #>MSG_SEC       ; (2)
   628 00:F9BA: 80 2A        PRMPT_SC        BRA     PROMPTR         ;Send to console, return (3)
   629                        ;
   630                        ;HEX2ASC - Accepts 16-bit Hexadecimal value and converts to an ASCII decimal string. Input is
   631                        ; via the A and Y Registers and output is up to 5 ASCII digits in DATABUFF. The High Byte is in
   632                        ; the Y Register and Low Byte is in the A Register. Output data is placed in variable DATABUFF
   633                        ; and terminated with a null character.
   634                        ; Note: leading zeros are suppressed. PROMPTR routine is used to print the ASCII decimal value.
   635                        ; Core routine based on Michael Barry's code. Saves many bytes with two updates/changes ;-)
   636 00:F9BC: 85 CE        HEX2ASC         STA     BINVALL         ;Save Low byte (3)
   637 00:F9BE: 84 CF                        STY     BINVALH         ;Save High byte (3)
   638 00:F9C0: A2 05                        LDX     #5              ;Get ASCII buffer offset (2)
   639 00:F9C2: 74 C8                        STZ     DATABUFF,X      ;Zero last buffer byte for null end (4)
   640                        ;
   641 00:F9C4: A9 00        CNVERT          LDA     #$00            ;Clear remainder (2)
   642 00:F9C6: A0 10                        LDY     #16             ;Set loop count for 16-bits (2)
   643                        ;
   644 00:F9C8: C9 05        DVLOOP          CMP     #$05            ;Partial remainder >= 10/2 (2)
   645 00:F9CA: 90 02                        BCC     DVLOOP2         ;Branch if less (2/3)
   646 00:F9CC: E9 05                        SBC     #$05            ;Update partial (carry set) (2)
  Fri Apr 11 2025  6:34                                                                                                    Page 18


   647                        ;
   648 00:F9CE: 26 CE        DVLOOP2         ROL     BINVALL         ;Shift carry into dividend (4)
   649 00:F9D0: 26 CF                        ROL     BINVALH         ;Which will be quotient (4)
   650 00:F9D2: 2A                           ROL     A               ;Rotate A Reg (3)
   651 00:F9D3: 88                           DEY                     ;Decrement count (2)
   652 00:F9D4: D0 F2                        BNE     DVLOOP          ;Branch back until done (2/3)
   653 00:F9D6: 09 30                        ORA     #$30            ;OR in $30 for ASCII (2)
   654                        ;
   655 00:F9D8: CA                           DEX                     ;Decrement buffer offset (2)
   656 00:F9D9: 95 C8                        STA     DATABUFF,X      ;Store digit into buffer (3)
   657                        ;
   658 00:F9DB: A5 CE                        LDA     BINVALL         ;Get the Low byte (3)
   659 00:F9DD: 05 CF                        ORA     BINVALH         ;OR in the High byte (check for zero) (3)
   660 00:F9DF: D0 E3                        BNE     CNVERT          ;Branch back until done (2/3)
   661                        ;
   662                        ;Conversion is complete, get the string address, add offset, then call prompt routine and return
   663                        ; note DATABUFF is fixed location in Page 0, carry flag need not be cleared as result can never
   664                        ; set flag after ADC instruction.
   665 00:F9E1: 8A                           TXA                     ;Get buffer offset (2)
   666 00:F9E2: 69 C8                        ADC     #<DATABUFF      ;Add Low byte address (2)
   667 00:F9E4: A0 00                        LDY     #>DATABUFF      ;Get High byte address (2)
   668                        ;
   669                        ;Drop into Prompt routine to print the 16-bit seconds count to console
   670                        ;
   671                        ;PROMPTR routine: takes message address in Y/A and prints via PROMPT2 routine
   672 00:F9E6: 85 D0        PROMPTR         STA     STRINGL         ;Store low byte (3)
   673 00:F9E8: 84 D1                        STY     STRINGH         ;Store high byte (3)
   674                        ;
   675                        ;PROMPT2 routine: prints message at address (PROMPTL) till null character found
   676 00:F9EA: B2 D0        PROMPT2         LDA     (STRINGL)       ;Get string data (5)
   677 00:F9EC: F0 0B                        BEQ     PR_EXIT         ;If null character, exit (2/3)
   678 00:F9EE: 20 1C F8                     JSR     CHROUT          ;Send character to terminal (6)
   679 00:F9F1: E6 D0                        INC     STRINGL         ;Increment low byte index (5)
   680 00:F9F3: D0 F5                        BNE     PROMPT2         ;Loop back for next character (2/3)
   681 00:F9F5: E6 D1                        INC     STRINGH         ;Increment high byte index (5)
   682 00:F9F7: 80 F1                        BRA     PROMPT2         ;Loop back and continue printing (3)
   683 00:F9F9: 60           PR_EXIT         RTS                     ;Return to caller
   684                        ;
   685                        ;**************************************************************************************************
   686                        ;Initializing the SC28L92 DUART as a Console.
   687                        ;An anomaly in the W65C02 processor requires a different approach in programming the SC28L92
   688                        ; for proper setup/operation. The SC28L92 uses three Mode Registers which are accessed at the same
   689                        ; register in sequence. There is a command that Resets the Mode Register pointer (to MR0) that is
   690                        ; issued first. Then MR0/1/2 are loaded in sequence. The problem with the W65C02 is a false read of
   691                        ; the register when using indexed addressing (i.e., STA UART_REGISTER,X). This results in the Mode
   692                        ; Register pointer being moved to the next register, so the write to next MRx never happens. While
   693                        ; the indexed list works fine for all other register functions/commands, the loading of the
   694                        ; Mode Registers need to be handled separately.
   695                        ;
   696                        ;NOTE: the W65C02 will function normally "if" a page boundary is crossed as part of the STA
   697                        ; (i.e., STA $FDFF,X) where the value of the X Register is high enough to cross the page boundary.
   698                        ; Programming in this manner would be confusing and require modification if the base I/O address
   699                        ; is changed for a different hardware I/O map.
   700                        ;
   701                        ;There are two routines called to setup the 28L92 DUART:
   702                        ;
   703                        ;The first routine is a RESET of the DUART.
   704                        ; It issues the following sequence of commands:
   705                        ;  1- Reset Break Change Interrupts
   706                        ;  2- Reset Receivers
   707                        ;  3- Reset Transmitters
   708                        ;  4- Reset All errors
   709                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 19


   710                        ;The second routine initializes the 28L92 DUART for operation. It uses two tables of data; one for
   711                        ; the register offset and the other for the register data. The table for register offsets is
   712                        ; maintained in ROM. The table for register data is copied to page $02, making it soft data. If
   713                        ; needed, operating parameters can be altered and the DUART re-initialized via the ROM routine.
   714                        ;
   715                        ; Note: A hardware reset will reset the SC28L92 and the default ROM config will be initialized.
   716                        ; Also note that the Panic routine invoked by a NMI trigger will also reset the DUART to the
   717                        ; default ROM config.
   718                        ;
   719 00:F9FA: 20 2E FA     INIT_IO         JSR     RESET_28L92     ;Reset of SC28L92 DUART (both channels) (6)
   720 00:F9FD: A9 64                        LDA     #DF_TICKS       ;Get divider for jiffy clock (100x10ms = 1 second) (2)
   721 00:F9FF: 85 E6                        STA     TICKS           ;Preload TICK count (3)
   722                        ;
   723                        ;This routine sets the initial operating mode of the DUART
   724                        ;
   725 00:FA01: 78           INIT_28L92      SEI                     ;Disable interrupts (2)
   726                        ;
   727 00:FA02: A2 0F                        LDX     #INIT_DUART_E-INIT_DUART ;Get the Init byte count (2)
   728 00:FA04: BD 1F 02     28L92_INT       LDA     LOAD_28L92-1,X  ;Get Data for 28L92 Register (4)
   729 00:FA07: BC 84 FE                     LDY     INIT_OFFSET-1,X ;Get Offset for 28L92 Register (4)
   730 00:FA0A: 99 00 FE                     STA     SC28L92_BASE,Y  ;Store Data to selected register (5)
   731 00:FA0D: CA                           DEX                     ;Decrement count (2)
   732 00:FA0E: D0 F4                        BNE     28L92_INT       ;Loop back until all registers are loaded (2/3)
   733                        ;
   734                        ; Mode Registers are NOT reset to MR0 by above INIT_28L92!
   735                        ; The following resets the MR pointers for both channels, then sets the MR registers
   736                        ; for each channel. Note: the MR index is incremented to the next location after the write.
   737                        ; NOTE: These writes can NOT be done via indexed addressing modes!
   738                        ;
   739 00:FA10: A9 B0                        LDA     #%10110000      ;Get mask for MR0 Reset (2)
   740 00:FA12: 8D 02 FE                     STA     UART_COMMAND_A  ;Reset Pointer for Port A (4)
   741 00:FA15: 8D 0A FE                     STA     UART_COMMAND_B  ;Reset Pointer for Port B (4)
   742                        ;
   743 00:FA18: A2 03                        LDX     #$03            ;Set index for 3 bytes to xfer (2)
   744 00:FA1A: BD 2F 02     MR_LD_LP        LDA     LOAD_28L92+15,X ;Get MR data for Port A (4)
   745 00:FA1D: 8D 00 FE                     STA     UART_MODEREG_A  ;Send to 28L92 Port A (4)
   746 00:FA20: BD 32 02                     LDA     LOAD_28L92+18,X ;Get MR data for Port B (4)
   747 00:FA23: 8D 08 FE                     STA     UART_MODEREG_B  ;Send to 28L92 Port B (4)
   748 00:FA26: CA                           DEX                     ;Decrement index to next data (2)
   749 00:FA27: D0 F1                        BNE     MR_LD_LP        ;Branch back till done (2/3)
   750                        ;
   751 00:FA29: 58                           CLI                     ;Enable interrupts (2)
   752                        ;
   753                        ; Start Counter/Timer
   754                        ;
   755 00:FA2A: AD 0E FE                     LDA     UART_START_CNT  ;Read register to start counter/timer (4)
   756 00:FA2D: 60                           RTS                     ;Return to caller (6)
   757                        ;
   758                        ; This routine does a Reset of the SC28L92 - both channels
   759                        ;
   760 00:FA2E: A2 04        RESET_28L92     LDX     #UART_RDATAE-UART_RDATA1 ;Get the Reset commands byte count (2)
   761 00:FA30: BD 80 FE     UART_RES1       LDA     UART_RDATA1-1,X ;Get Reset commands (4)
   762 00:FA33: 8D 02 FE                     STA     UART_COMMAND_A  ;Send to UART A CR (4)
   763 00:FA36: 8D 0A FE                     STA     UART_COMMAND_B  ;Send to UART B CR (4)
   764 00:FA39: CA                           DEX                     ;Decrement the command list index (2)
   765 00:FA3A: D0 F4                        BNE     UART_RES1       ;Loop back until all are sent (2/3)
   766 00:FA3C: 60                           RTS                     ;Return to caller (6)
   767                        ;
   768                        ;**************************************************************************************************
   769                        ;START OF PANIC ROUTINE
   770                        ;The Panic routine is for debug of system problems, i.e., a crash. The hardware design requires a
   771                        ; debounced NMI trigger button which is manually operated when the system crashes or malfunctions.
   772                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 20


   773                        ;User presses the NMI (panic) button. The NMI vectored routine will perform the following tasks:
   774                        ; 1- Save CPU registers in page zero locations
   775                        ; 2- Reset the MicroDrive and disable interrupts
   776                        ; 3- Clear all Console I/O buffer pointers
   777                        ; 4- Call the ROM routines to init the vectors and config data (page $02)
   778                        ; 5- Call the ROM routines to reset/init the DUART (SC28L92)
   779                        ; 6- Enter the Monitor via the warm start vector **
   780                        ;
   781                        ; Note: The additional hardware detection (RTC/IDE) are NOT executed with the Panic routine!
   782                        ; The interrupt vectors are restored without including the additional ISR for the IDE controller.
   783                        ; The Microdrive Reset_Off command is also set to disable any bus activity.
   784                        ;
   785                        ; Note: no memory is cleared except the required pointers/vectors to restore the system.
   786                        ;
   787 00:FA3D: 78           NMI_VECTOR      SEI                     ;Disable interrupts (2)
   788 00:FA3E: 85 D8                        STA     AREG            ;Save A Reg (3)
   789 00:FA40: 86 D7                        STX     XREG            ;Save X Reg (3)
   790 00:FA42: 84 D6                        STY     YREG            ;Save Y Reg (3)
   791 00:FA44: 68                           PLA                     ;Get Processor Status (4)
   792 00:FA45: 85 D4                        STA     PREG            ;Save in PROCESSOR STATUS preset/result (3)
   793 00:FA47: BA                           TSX                     ;Get Stack pointer (4)
   794 00:FA48: 86 D5                        STX     SREG            ;Save STACK POINTER (3)
   795 00:FA4A: 68                           PLA                     ;Pull RETURN address from STACK (4)
   796 00:FA4B: 85 D2                        STA     PCL             ;Store Low byte (3)
   797 00:FA4D: 68                           PLA                     ;Pull high byte (4)
   798 00:FA4E: 85 D3                        STA     PCH             ;Store High byte (3)
   799                        ;
   800 00:FA50: A9 06                        LDA     #%00000110      ;Get mask for MicroDrive Reset/IRQ disable (2)
   801 00:FA52: 8D 36 FE                     STA     IDE_DEV_CTRL    ;Send to MicroDrive (4)
   802                        ;
   803 00:FA55: 9C 05 FE                     STZ     UART_IMR        ;Disable ALL interrupts from UART (4)
   804                        ;
   805 00:FA58: A2 0C                        LDX     #$0C            ;Set count for 12 (2)
   806 00:FA5A: 74 D8        PAN_LP1         STZ     ICNT_A-1,X      ;Clear DUART I/O pointers (3)
   807 00:FA5C: CA                           DEX                     ;Decrement index (2)
   808 00:FA5D: D0 FB                        BNE     PAN_LP1         ;Branch back till done (2/3)
   809                        ;
   810 00:FA5F: 20 9C FF                     JSR     INIT_PG02       ;Xfer default Vectors/HW Config to $0200 (6)
   811 00:FA62: 20 FA F9                     JSR     INIT_IO         ;Reset and Init the UART for Console (6)
   812                        ;
   813 00:FA65: A9 02                        LDA     #%00000010      ;Get mask for MicroDrive Reset off (2)
   814 00:FA67: 8D 36 FE                     STA     IDE_DEV_CTRL    ;Send to MicroDrive (4)
   815                        ;
   816 00:FA6A: 6C 06 02                     JMP     (NMIRTVEC0)     ;Jump to NMI Return Vector (Monitor Warm Start) (6)
   817                        ;
   818                        ;**************************************************************************************************
   819                        ;BRK/IRQ Interrupt service routines
   820                        ;The pre-process routine located in page $FF soft-vectors to INTERUPT0/BRKINSTR0 below
   821                        ;       These are the routines that handle BRK and IRQ functions
   822                        ;       The BRK handler saves CPU details for register display
   823                        ;       - A Monitor can provide a disassembly of the last executed instruction
   824                        ;       - A Received Break is also handled here (ExtraPutty/Windows or Serial/OSX)
   825                        ;
   826                        ; SC28L92 handler
   827                        ;       The 28L92 IRQ routine handles Transmit, Receive, Timer and Received-Break interrupts
   828                        ;       - Transmit and Receive each have a 128 byte circular FIFO buffer in memory per channel
   829                        ;       - Xmit IRQ is controlled (On/Off) by the handler and the CHROUT(2) routine
   830                        ;
   831                        ; The 28L92 Timer resolution is 10ms and used as a Jiffy Clock for RTC, delays and benchmarking
   832                        ;**************************************************************************************************
   833                        ;BIOS routines to handle interrupt-driven I/O for the SC28L92
   834                        ; NOTE: IP0 Pin is used for RTS, which is automatically handled in the chip. As a result,
   835                        ; the upper 2 bits of the ISR are not used in the handler. The Lower 5 bits are used, but
  Fri Apr 11 2025  6:34                                                                                                    Page 21


   836                        ; the lower two are used to determine when to disable transmit after the buffer is empty.
   837                        ;
   838                        ;The DUART_ISR bits are defined as follows:
   839                        
   840                        ; Bit7          ;Input Change Interrupt
   841                        ; Bit6          ;Change Break B Interrupt
   842                        ; Bit5          ;RxRDY B Interrupt
   843                        ; Bit4          ;TxRDY B Interrupt
   844                        ; Bit3          ;Counter Ready Interrupt
   845                        ; Bit2          ;Change Break A Interrupt
   846                        ; Bit1          ;RxRDY A Interrupt
   847                        ; Bit0          ;TxRDY A Interrupt
   848                        ;
   849                        ; SC8L92 uses all bits in the Status Register!
   850                        ; - for Receive Buffer full, we set a bit in the SC28L92 Misc. Register, one for each Port.
   851                        ; Note that the Misc. Register in the SC28L92 is a free byte for storing the flags, as it's
   852                        ; not used when the DUART is configured in Intel mode! Freebie Register for us to use ;-)
   853                        ;
   854                        ; NOTE: The entry point for the BRK/IRQ handler is below at label INTERUPT0
   855                        ;**************************************************************************************************
   856                        ;ISR Routines for SC28L92 Port B
   857                        ;
   858                        ; The operation is the same as Port A below, sans the fact that the Break detection only resets
   859                        ; the DUART channel and returns, while Port A uses Break detection for other functions within
   860                        ; the BIOS structure, and processes the BRK routine shown further down.
   861                        ;
   862 00:FA6D: A4 DF        UARTB_RCV       LDY     ICNT_B          ;Get input buffer count (3)
   863 00:FA6F: 30 41                        BMI     BUFFUL_B        ;Check against limit ($80), branch if full (2/3)
   864                        ;
   865 00:FA71: AD 09 FE     UARTB_RCVLP     LDA     UART_STATUS_B   ;Get Status Register (4)
   866 00:FA74: 89 01                        BIT     #%00000001      ;Check RxRDY active (2)
   867 00:FA76: F0 10                        BEQ     UARTB_CXMT      ;If RxRDY not set, FIFO is empty, check Xmit (2/3)
   868                        
   869 00:FA78: AD 0B FE                     LDA     UART_RECEIVE_B  ;Else, get data from 28L92 (4)
   870 00:FA7B: A4 E1                        LDY     ITAIL_B         ;Get the tail pointer to buffer (3)
   871 00:FA7D: 99 00 04                     STA     IBUF_B,Y        ;Store into buffer (5)
   872 00:FA80: E6 E1                        INC     ITAIL_B         ;Increment tail pointer (5)
   873 00:FA82: 77 E1                        RMB7    ITAIL_B         ;Strip off bit 7, 128 bytes only (5)
   874 00:FA84: E6 DF                        INC     ICNT_B          ;increment data count (5)
   875 00:FA86: 10 E9                        BPL     UARTB_RCVLP     ;If input buffer not full, check for more FIFO data (2/3)
   876                        ;
   877 00:FA88: AD 05 FE     UARTB_CXMT      LDA     UART_ISR        ;Get 28L92 ISR Reg (4)
   878 00:FA8B: 89 10                        BIT     #%00010000      ;Check for Xmit B active (2)
   879 00:FA8D: F0 20                        BEQ     REGEXT_B        ;Exit if inactive (2/3)
   880                        ;
   881                        ; To take advantage of the onboard FIFO, we test the TxRDY bit in the Status Register. If the
   882                        ; bit is set, then there is more room in the FIFO. The ISR routine here will attempt to fill
   883                        ; the FIFO from the Output Buffer. This saves processing time in the ISR itself.
   884                        ;
   885 00:FA8F: A5 E2        UARTB_XMT       LDA     OCNT_B          ;Get output buffer count, any data to xmit? (3)
   886 00:FA91: F0 17                        BEQ     NODATA_B        ;If zero, no data left, turn off xmit (2/3)
   887                        ;
   888 00:FA93: AD 09 FE     UARTB_XMTLP     LDA     UART_STATUS_B   ;Get Status Register (4)
   889 00:FA96: 89 04                        BIT     #%00000100      ;Check TxRDY active (2)
   890 00:FA98: F0 15                        BEQ     REGEXT_B        ;If TxRDY not set, FIFO is full, exit ISR (2/3)
   891                        ;
   892 00:FA9A: A4 E3                        LDY     OHEAD_B         ;Get the head pointer to buffer (3)
   893 00:FA9C: B9 80 04                     LDA     OBUF_B,Y        ;Get the next data (4)
   894 00:FA9F: 8D 0B FE                     STA     UART_TRANSMIT_B ;Send the data to 28L92 (4)
   895 00:FAA2: E6 E3                        INC     OHEAD_B         ;Increment head pointer (5)
   896 00:FAA4: 77 E3                        RMB7    OHEAD_B         ;Strip off bit 7, 128 bytes only (5)
   897 00:FAA6: C6 E2                        DEC     OCNT_B          ;Decrement counter (5)
   898 00:FAA8: D0 E9                        BNE     UARTB_XMTLP     ;If more data, loop back to send it (2/3)
  Fri Apr 11 2025  6:34                                                                                                    Page 22


   899                        ;
   900                        ;No more buffer data to send, check SC28L92 TxEMT and disable transmit if empty.
   901                        ; Note: If the TxEMT bit is set, then the FIFO is empty and all data has been sent.
   902                        ;
   903 00:FAAA: A0 08        NODATA_B        LDY     #%00001000      ;Else, get mask for xmit off (2)
   904 00:FAAC: 8C 0A FE                     STY     UART_COMMAND_B  ;Turn off xmit (4)
   905 00:FAAF: 6C 0A 02     REGEXT_B        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
   906                        ;
   907 00:FAB2: A0 10        BUFFUL_B        LDY     #%00010000      ;Get Mask for Buffer full (2)
   908 00:FAB4: 8C 0C FE                     STY     UART_MISC       ;Save into 28L92 Misc. Register (4)
   909 00:FAB7: 80 F6                        BRA     REGEXT_B        ;Exit IRQ handler (3)
   910                        ;
   911                        ;Received Break handler for Port B
   912                        ;
   913 00:FAB9: AD 09 FE     UARTB_BRK       LDA     UART_STATUS_B   ;Get DUART Status Register (4)
   914 00:FABC: 30 0D                        BMI     BREAKEY_B       ;If bit 7 set, received Break was detected (2/3)
   915                        ;
   916                        ; If a received Break was not the cause, we should reset the DUART Port as the cause
   917                        ; could have been a receiver error, i.e., parity or framing
   918                        ;
   919 00:FABE: A2 05                        LDX     #UART_RDATAE-UART_RDATA ;Get index count (2)
   920 00:FAC0: BD 7F FE     UARTB_RST1      LDA     UART_RDATA-1,X  ;Get Reset commands (4)
   921 00:FAC3: 8D 0A FE                     STA     UART_COMMAND_B  ;Send to DUART CR (4)
   922 00:FAC6: CA                           DEX                     ;Decrement the command list (2)
   923 00:FAC7: D0 F7                        BNE     UARTB_RST1      ;Loop back until all are sent (2/3)
   924 00:FAC9: 80 E4                        BRA     REGEXT_B        ;Exit (3)
   925                        ;
   926                        ; A received Break was the cause. Just reset the receiver and return.
   927                        ;
   928 00:FACB: A9 40        BREAKEY_B       LDA     #%01000000      ;Get Reset Received Break command (2)
   929 00:FACD: 8D 0A FE                     STA     UART_COMMAND_B  ;Send to DUART to reset (4)
   930 00:FAD0: A9 50                        LDA     #%01010000      ;Get Reset Break Interrupt command (2)
   931 00:FAD2: 8D 0A FE                     STA     UART_COMMAND_B  ;Send to DUART to reset (4)
   932 00:FAD5: 80 D8                        BRA     REGEXT_B        ;Exit (3)
   933                        ;
   934                        ;**************************************************************************************************
   935                        ;This is the IRQ handler entry point for the SC28L92 DUART.
   936                        ; This is the first IRQ handler unless an IDE device is found during cold start. By default, it
   937                        ; will take 25 clock cycles to arrive here after an interrupt is generated. If an IDE device is
   938                        ; present, the IDE handler will be processed first. If no IDE interrupt is active, it will take
   939                        ; an additional 33 cycles to arrive here.
   940                        ;
   941                        ; The ISR checks for interrupt sources as follows:
   942                        ; - Timer/Counter, to ensure accurate software RTC and benchmark/delay timings
   943                        ; - Serial Port 2, to provide fast data transfers to a separate device
   944                        ; - Serial Port 1, for standard Console access
   945                        ;
   946                        INTERUPT0                               ;Interrupt 0 to handle the SC28L92 DUART
   947 00:FAD7: AD 05 FE                     LDA     UART_ISR        ;Get the UART Interrupt Status Register (4)
   948 00:FADA: F0 1E                        BEQ     REGEXT_0        ;If no bits are set, exit handler (2/3)
   949                        ;
   950 00:FADC: 89 08                        BIT     #%00001000      ;Test for Counter ready (RTC) (2)
   951 00:FADE: D0 1D                        BNE     UART_RTC        ;If yes, go increment RTC variables (2/3)
   952                        ;
   953 00:FAE0: 89 40                        BIT     #%01000000      ;Test for Break on B (2)
   954 00:FAE2: D0 D5                        BNE     UARTB_BRK       ;If yes, Reset the DUART receiver (2/3)
   955                        ;
   956 00:FAE4: 89 20                        BIT     #%00100000      ;Test for RHR B having data (2)
   957 00:FAE6: D0 85                        BNE     UARTB_RCV       ;If yes, put the data in the buffer (2/3)
   958                        ;
   959 00:FAE8: 89 10                        BIT     #%00010000      ;Test for THR B ready to receive data (2)
   960 00:FAEA: D0 A3                        BNE     UARTB_XMT       ;If yes, get data from the buffer (2/3)
   961                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 23


   962 00:FAEC: 89 04                        BIT     #%00000100      ;Test for Break on A (2)
   963 00:FAEE: D0 5C                        BNE     UARTA_BRK       ;If yes, Reset the DUART receiver (2/3)
   964                        ;
   965 00:FAF0: 89 02                        BIT     #%00000010      ;Test for RHR A having data (2)
   966 00:FAF2: D0 0C                        BNE     UARTA_RCV       ;If yes, put the data in the buffer (2/3)
   967                        ;
   968 00:FAF4: 89 01                        BIT     #%00000001      ;Test for THR A ready to receive data (2)
   969 00:FAF6: D0 2A                        BNE     UARTA_XMT       ;If yes, get data from the buffer (2/3)
   970                        ;
   971                        ; if none of the above bits caused the IRQ, the only bit left is the change input port.
   972                        ; just save it in the temp IRT register in page zero and exit.
   973                        ;
   974 00:FAF8: 85 E5                        STA     UART_IRT        ;Save the 28L92 ISR for later use (3)
   975 00:FAFA: 6C 0A 02     REGEXT_0        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
   976                        ;
   977 00:FAFD: 4C 00 FC     UART_RTC        JMP     UART_RTC0       ;Jump to RTC handler (3)
   978                        ;
   979                        ;**************************************************************************************************
   980                        ;ISR Routines for SC28L92 Port A
   981                        ;
   982                        ; The Receive Buffer is checked first to ensure there is open space in the buffer.
   983                        ; By loadng the input count, bit7 will be set if it is full, which will set the "N"
   984                        ; flag in the CPU status register. If this is the case, we exit to BUFFUL_A and set
   985                        ; a bit the SC28L92 Misc. Register. If the buffer has space, we continue.
   986                        ; 
   987                        ; To take advantage of the onboard FIFO, we test the RxRDY bit in the Status Register.
   988                        ; If the bit is set, the FIFO has data and the routine moves data from the FIFO into
   989                        ; the Receive buffer. We loop back and contnue moving data from the FIFO to the buffer
   990                        ; until the RxRDY bit is cleared (FIFO empty). If the FIFO is empty, we branch and
   991                        ; check for a pending Transmit interrupt, just to save some ISR time.
   992                        ;
   993                        ; NOTE: the receiver is configured to use the Watchdog function. This will generate a
   994                        ; receiver interrupt within 64 bit times once data is received (and the FIFO has not
   995                        ; reached it's configured fill level). This provides the required operation for use
   996                        ; as a console, as single character commands are common and would not fill the FIFO,
   997                        ; which generates an interrupt based on the configured FIFO fill level.
   998                        ;
   999 00:FB00: A4 D9        UARTA_RCV       LDY     ICNT_A          ;Get input buffer count (3)
  1000 00:FB02: 30 41                        BMI     BUFFUL_A        ;Check against limit ($80), branch if full (2/3)
  1001                        ;
  1002 00:FB04: AD 01 FE     UARTA_RCVLP     LDA     UART_STATUS_A   ;Get Status Register (4)
  1003 00:FB07: 89 01                        BIT     #%00000001      ;Check RxRDY active (2)
  1004 00:FB09: F0 10                        BEQ     UARTA_CXMT      ;If RxRDY not set, FIFO is empty, check Xmit (2/3)
  1005                        
  1006 00:FB0B: AD 03 FE                     LDA     UART_RECEIVE_A  ;Else, get data from 28L92 (4)
  1007 00:FB0E: A4 DB                        LDY     ITAIL_A         ;Get the tail pointer to buffer (3)
  1008 00:FB10: 99 00 03                     STA     IBUF_A,Y        ;Store into buffer (5)
  1009 00:FB13: E6 DB                        INC     ITAIL_A         ;Increment tail pointer (5)
  1010 00:FB15: 77 DB                        RMB7    ITAIL_A         ;Strip off bit 7, 128 bytes only (5)
  1011 00:FB17: E6 D9                        INC     ICNT_A          ;Increment input bufffer count (5)
  1012 00:FB19: 10 E9                        BPL     UARTA_RCVLP     ;If input buffer not full, check for more FIFO data (2/3)
  1013                        ;
  1014 00:FB1B: AD 05 FE     UARTA_CXMT      LDA     UART_ISR        ;Get 28L92 ISR Reg (4)
  1015 00:FB1E: 89 01                        BIT     #%00000001      ;Check for Xmit A active (2)
  1016 00:FB20: F0 20                        BEQ     REGEXT_A        ;Exit if inactive, else drop into Xmit code (2/3)
  1017                        ;
  1018                        ;To take advantage of the onboard FIFO, we test the TxRDY bit in the Status Register.
  1019                        ; If the bit is set, then there is more room in the FIFO. The ISR routine here will attempt to
  1020                        ; fill the FIFO from the Output Buffer. This saves processing time in the ISR itself.
  1021                        ;
  1022 00:FB22: A5 DC        UARTA_XMT       LDA     OCNT_A          ;Get output buffer count, any data to xmit? (3)
  1023 00:FB24: F0 17                        BEQ     NODATA_A        ;If zero, no data left, turn off xmit (2/3)
  1024                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 24


  1025 00:FB26: AD 01 FE     UARTA_XMTLP     LDA     UART_STATUS_A   ;Get Status Register (4)
  1026 00:FB29: 89 04                        BIT     #%00000100      ;Check TxRDY active (2)
  1027 00:FB2B: F0 15                        BEQ     REGEXT_A        ;If TxRDY not set, FIFO is full, exit ISR (2/3)
  1028                        ;
  1029 00:FB2D: A4 DD                        LDY     OHEAD_A         ;Get the head pointer to buffer (3)
  1030 00:FB2F: B9 80 03                     LDA     OBUF_A,Y        ;Get the next data (4)
  1031 00:FB32: 8D 03 FE                     STA     UART_TRANSMIT_A ;Send the data to 28L92 (4)
  1032 00:FB35: E6 DD                        INC     OHEAD_A         ;Increment head pointer (5)
  1033 00:FB37: 77 DD                        RMB7    OHEAD_A         ;Strip off bit 7, 128 bytes only (5)
  1034 00:FB39: C6 DC                        DEC     OCNT_A          ;Decrement output buffer count (5)
  1035 00:FB3B: D0 E9                        BNE     UARTA_XMTLP     ;If more data, loop back to send it (2/3)
  1036                        ;
  1037                        ;No more buffer data to send, check SC28L92 TxEMT and disable transmit if empty.
  1038                        ; Note: If the TxEMT bit is set, then the FIFO is empty and all data has been sent.
  1039                        ;
  1040 00:FB3D: A0 08        NODATA_A        LDY     #%00001000      ;Else, get mask for xmit off (2)
  1041 00:FB3F: 8C 02 FE                     STY     UART_COMMAND_A  ;Turn off xmit (4)
  1042 00:FB42: 6C 0A 02     REGEXT_A        JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)
  1043                        ;
  1044 00:FB45: A0 01        BUFFUL_A        LDY     #%00000001      ;Get Mask for Buffer full (2)
  1045 00:FB47: 8C 0C FE                     STY     UART_MISC       ;Save into 28L92 Misc. Register (4)
  1046 00:FB4A: 80 F6                        BRA     REGEXT_A        ;Exit IRQ handler (3)
  1047                        ;
  1048                        ;Received Break handler for Port A
  1049                        ;
  1050 00:FB4C: AD 01 FE     UARTA_BRK       LDA     UART_STATUS_A   ;Get DUART Status Register (4)
  1051 00:FB4F: 30 0D                        BMI     BREAKEY_A       ;If bit 7 set, received Break was detected (2/3)
  1052                        ;
  1053                        ; If a received Break was not the cause, we should reset the DUART Port as the cause
  1054                        ; could have been a receiver error, i.e., parity or framing
  1055                        ;
  1056 00:FB51: A2 05                        LDX     #UART_RDATAE-UART_RDATA ;Get index count (2)
  1057 00:FB53: BD 7F FE     UARTA_RST1      LDA     UART_RDATA-1,X  ;Get Reset commands (4)
  1058 00:FB56: 8D 02 FE                     STA     UART_COMMAND_A  ;Send to DUART CR (4)
  1059 00:FB59: CA                           DEX                     ;Decrement the command list (2)
  1060 00:FB5A: D0 F7                        BNE     UARTA_RST1      ;Loop back until all are sent (2/3)
  1061 00:FB5C: 80 E4                        BRA     REGEXT_A        ;Exit (3)
  1062                        ;
  1063                        ; A received Break was the cause. Reset the receiver and process the BRK routine.
  1064                        ;
  1065 00:FB5E: A9 40        BREAKEY_A       LDA     #%01000000      ;Get Reset Received Break command (2)
  1066 00:FB60: 8D 02 FE                     STA     UART_COMMAND_A  ;Send to DUART to reset (4)
  1067 00:FB63: A9 50                        LDA     #%01010000      ;Get Reset Break Interrupt command (2)
  1068 00:FB65: 8D 02 FE                     STA     UART_COMMAND_A  ;Send to DUART to reset (4)
  1069                        ;
  1070 00:FB68: 58           BREAKEY         CLI                     ;Enable IRQ, drop into BRK handler (2)
  1071                        ;
  1072                        ;**************************************************************************************************
  1073                        ;
  1074                        ; BRK Vector defaults to here
  1075                        ;
  1076 00:FB69: 7A           BRKINSTR0       PLY                     ;Restore Y Reg (4)
  1077 00:FB6A: FA                           PLX                     ;Restore X Reg (4)
  1078 00:FB6B: 68                           PLA                     ;Restore A Reg (4)
  1079 00:FB6C: 85 D8                        STA     AREG            ;Save A Reg (3)
  1080 00:FB6E: 86 D7                        STX     XREG            ;Save X Reg (3)
  1081 00:FB70: 84 D6                        STY     YREG            ;Save Y Reg (3)
  1082 00:FB72: 68                           PLA                     ;Get Processor Status (4)
  1083 00:FB73: 85 D4                        STA     PREG            ;Save in PROCESSOR STATUS preset/result (3)
  1084 00:FB75: BA                           TSX                     ;Xfer STACK pointer to X Reg (2)
  1085 00:FB76: 86 D5                        STX     SREG            ;Save STACK pointer (3)
  1086                        ;
  1087 00:FB78: FA                           PLX                     ;Pull Low RETURN address from STACK then save it (4)
  Fri Apr 11 2025  6:34                                                                                                    Page 25


  1088 00:FB79: 86 D2                        STX     PCL             ;Store program counter Low byte (3)
  1089 00:FB7B: 7A                           PLY                     ;Pull High RETURN address from STACK then save it (4)
  1090 00:FB7C: 84 D3                        STY     PCH             ;Store program counter High byte (3)
  1091 00:FB7E: 4F D4 03                     BBR4    PREG,DO_NULL    ;Check for BRK bit set (5/6,7)
  1092                        ;
  1093                        ; This call simply shows CPU Register contents and invoked by a BRK opcode.
  1094                        ;
  1095 00:FB81: 20 91 FB                     JSR     PRSTAT          ;Display CPU status (6)
  1096                        ;
  1097                        ; Note: This routine only clears Port A, as it is used for the Console
  1098                        ;
  1099 00:FB84: A9 00        DO_NULL         LDA     #$00            ;Clear all Processor Status Register bits (2)
  1100 00:FB86: 48                           PHA                     ;Push it to Stack (3)
  1101 00:FB87: 28                           PLP                     ;Pull it to Processor Status (4)
  1102 00:FB88: 64 DB                        STZ     ITAIL_A         ;Clear input buffer pointers (3)
  1103 00:FB8A: 64 DA                        STZ     IHEAD_A         ; (3)
  1104 00:FB8C: 64 D9                        STZ     ICNT_A          ; (3)
  1105 00:FB8E: 6C 08 02                     JMP     (BRKRTVEC0)     ;Done BRK service process, re-enter monitor (6)
  1106                        ;
  1107                        PRSTAT          
  1108 00:FB91: A9 DC                        LDA     #<PSTAT_MSG     ;CPU Status message (2)
  1109 00:FB93: A0 FE                        LDY     #>PSTAT_MSG     ; (2)
  1110 00:FB95: 20 E6 F9                     JSR     PROMPTR         ;Send to console (6)
  1111 00:FB98: A5 D2                        LDA     PCL             ;Get PC Low byte (3)
  1112 00:FB9A: A4 D3                        LDY     PCH             ;Get PC High byte (3)
  1113 00:FB9C: 20 E1 FB                     JSR     PRWORD          ;Print 16-bit word (6)
  1114 00:FB9F: 20 CD FB                     JSR     SPC             ;Send 1 space (6)
  1115                        ;
  1116 00:FBA2: A2 04                        LDX     #$04            ;Set for count of 4 (2)
  1117 00:FBA4: B5 D4        REGPLOOP        LDA     PREG,X          ;Start with A Reg variable (4)
  1118 00:FBA6: 20 D2 FB                     JSR     PRBYTE          ;Print it (6)
  1119 00:FBA9: 20 CD FB                     JSR     SPC             ;Send 1 space (6)
  1120 00:FBAC: CA                           DEX                     ;Decrement count (2)
  1121 00:FBAD: D0 F5                        BNE     REGPLOOP        ;Loop back till all 4 are sent (2/3)
  1122                        ;
  1123 00:FBAF: A5 D4                        LDA     PREG            ;Get Status Register preset (3)
  1124 00:FBB1: A2 08                        LDX     #$08            ;Get the index count for 8 bits (2)
  1125 00:FBB3: 0A           SREG_LP         ASL     A               ;Shift bit into Carry (2)
  1126 00:FBB4: 48                           PHA                     ;Save current (shifted) SR value (3)
  1127 00:FBB5: A9 30                        LDA     #$30            ;Load an Ascii zero (2)
  1128 00:FBB7: 69 00                        ADC     #$00            ;Add zero (with Carry) (2)
  1129 00:FBB9: 20 1C F8                     JSR     CHROUT          ;Print bit value (0 or 1) (6)
  1130 00:FBBC: 68                           PLA                     ;Get current (shifted) SR value (4)
  1131 00:FBBD: CA                           DEX                     ;Decrement bit count (2)
  1132 00:FBBE: D0 F3                        BNE     SREG_LP         ;Loop back until all 8 printed, drop to CROUT (2/3)
  1133                        ;
  1134                        ;Send CR/LF to terminal
  1135 00:FBC0: 48           CROUT           PHA                     ;Save A Reg (3)
  1136 00:FBC1: A9 0D                        LDA     #$0D            ;Get ASCII Return (2)
  1137 00:FBC3: 20 1C F8                     JSR     CHROUT          ;Send to terminal (6)
  1138 00:FBC6: A9 0A                        LDA     #$0A            ;Get ASCII Linefeed (2)
  1139 00:FBC8: 20 1C F8     SENDIT          JSR     CHROUT          ;Send to terminal (6)
  1140 00:FBCB: 68                           PLA                     ;Restore A Reg (4)
  1141 00:FBCC: 60                           RTS                     ;Return to caller (6)
  1142                        ;
  1143 00:FBCD: 48           SPC             PHA                     ;Save character in A Reg (3)
  1144 00:FBCE: A9 20                        LDA     #$20            ;Get ASCII Space (2)
  1145 00:FBD0: 80 F6                        BRA     SENDIT          ;Branch to send (3)
  1146                        ;
  1147                        ;PRBYTE subroutine: Converts a single Byte to 2 HEX ASCII characters and sends to console on
  1148                        ; entry, A Reg contains the Byte to convert/send. Register contents are preserved on entry/exit.
  1149 00:FBD2: 48           PRBYTE          PHA                     ;Save A Register (3)
  1150 00:FBD3: 5A                           PHY                     ;Save Y Register (3)
  Fri Apr 11 2025  6:34                                                                                                    Page 26


  1151 00:FBD4: 20 EB FB     PRBYT2          JSR     BIN2ASC         ;Convert A Reg to 2 ASCII Hex characters (6)
  1152 00:FBD7: 20 1C F8                     JSR     CHROUT          ;Print high nibble from A Reg (6)
  1153 00:FBDA: 98                           TYA                     ;Transfer low nibble to A Reg (2)
  1154 00:FBDB: 20 1C F8                     JSR     CHROUT          ;Print low nibble from A Reg (6)
  1155 00:FBDE: 7A                           PLY                     ;Restore Y Register (4)
  1156 00:FBDF: 68                           PLA                     ;Restore A Register (4)
  1157 00:FBE0: 60                           RTS                     ;Return to caller (6)
  1158                        ;
  1159                        ;PRWORD subroutine: Converts a 16-bit word to 4 HEX ASCII characters and sends to console. On
  1160                        ; entry, A Reg contains Low Byte, Y Reg contains High Byte. Registers are preserved on entry/exit.
  1161                        ; NOTE: Routine changed for consistency; A Reg = Low byte, Y Reg = High byte on 2nd May 2020
  1162 00:FBE1: 48           PRWORD          PHA                     ;Save A Register (Low) (3)
  1163 00:FBE2: 5A                           PHY                     ;Save Y Register (High) (3)
  1164 00:FBE3: 48                           PHA                     ;Save Low byte again (3)
  1165 00:FBE4: 98                           TYA                     ;Xfer High byte to A Reg (2)
  1166 00:FBE5: 20 D2 FB                     JSR     PRBYTE          ;Convert and print one HEX character (00-FF) (6)
  1167 00:FBE8: 68                           PLA                     ;Get Low byte value (4)
  1168 00:FBE9: 80 E9                        BRA     PRBYT2          ;Finish up Low Byte and exit (3)
  1169                        ;
  1170                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
  1171                        ; Enter: A Register contains byte value to convert
  1172                        ; Return: A Register = high digit, Y Register = low digit
  1173 00:FBEB: 48           BIN2ASC         PHA                     ;Save A Reg on stack (3)
  1174 00:FBEC: 29 0F                        AND     #$0F            ;Mask off high nibble (2)
  1175 00:FBEE: 20 F7 FB                     JSR     ASCII           ;Convert nibble to ASCII HEX digit (6)
  1176 00:FBF1: A8                           TAY                     ;Move to Y Reg (2)
  1177 00:FBF2: 68                           PLA                     ;Get character back from stack (3)
  1178 00:FBF3: 4A                           LSR     A               ;Shift high nibble to lower 4 bits (2)
  1179 00:FBF4: 4A                           LSR     A               ; (2)
  1180 00:FBF5: 4A                           LSR     A               ; (2)
  1181 00:FBF6: 4A                           LSR     A               ; (2)
  1182                        ;
  1183 00:FBF7: C9 0A        ASCII           CMP     #$0A            ;Check for 10 or less (2)
  1184 00:FBF9: 90 02                        BCC     ASCOK           ;Branch if less than 10 (2/3)
  1185 00:FBFB: 69 06                        ADC     #$06            ;Add $06+CF ($07) for A-F (2)
  1186 00:FBFD: 69 30        ASCOK           ADC     #$30            ;Add $30 for ASCII (2)
  1187 00:FBFF: 60                           RTS                     ;Return to caller (6)
  1188                        ;
  1189                        ;**************************************************************************************************
  1190                        ;
  1191                        ;Entry for ISR to service the timer/counter interrupt.
  1192                        ;
  1193                        ; NOTE: Stop timer cmd resets the interrupt flag, counter continues to generate interrupts.
  1194                        ; NOTE: 38 clock cycles to here from INTERUPT0 - 68 in total, sans IDE ISR if active.
  1195                        ;
  1196 00:FC00: AD 0F FE     UART_RTC0       LDA     UART_STOP_CNT   ;Get Command mask for stop timer (4)
  1197                        ;
  1198                        ; Check the MATCH flag bit7 to see if a Delay is active. If yes, decrement the MSDELAY
  1199                        ; variable once each pass until it is zero, then clear the MATCH flag bit7
  1200                        ;
  1201 00:FC03: 7F FF 06                     BBR7    MATCH,SKIP_DLY  ;Skip Delay if bit7 is clear (5/6,7)
  1202 00:FC06: C6 EB                        DEC     MSDELAY         ;Decrement Millisecond delay variable (5)
  1203 00:FC08: D0 02                        BNE     SKIP_DLY        ;If not zero, skip (2/3)
  1204 00:FC0A: 77 FF                        RMB7    MATCH           ;Else clear MATCH flag (5)
  1205                        ;
  1206                        ; Check the MATCH flag bit6 to see if Benchmarking is active. If yes, increment the
  1207                        ; variables once each pass until the MATCH flag bit6 is inactive.
  1208                        ;
  1209 00:FC0C: 6F FF 10     SKIP_DLY        BBR6    MATCH,SKIP_CNT  ;Skip Count if bit6 is clear (5/6,7)
  1210 00:FC0F: E6 EF                        INC     MS10_CNT        ;Else, increment 10ms count (5)
  1211 00:FC11: A5 EF                        LDA     MS10_CNT        ;Load current value (3)
  1212 00:FC13: C9 64                        CMP     #100            ;Compare for 1 second elapsed time (2)
  1213 00:FC15: 90 08                        BCC     SKIP_CNT        ;If not, skip to RTC update (2/3)
  Fri Apr 11 2025  6:34                                                                                                    Page 27


  1214 00:FC17: 64 EF                        STZ     MS10_CNT        ;Else, zero 10ms count (3)
  1215 00:FC19: E6 F0                        INC     SECL_CNT        ;Increment low byte elapsed seconds (5)
  1216 00:FC1B: D0 02                        BNE     SKIP_CNT        ;If no overflow, skip to RTC update (2/3)
  1217 00:FC1D: E6 F1                        INC     SECH_CNT        ;Else, increment high byte elapsed seconds (5)
  1218                        ;
  1219 00:FC1F: C6 E6        SKIP_CNT        DEC     TICKS           ;Decrement RTC tick count (5)
  1220 00:FC21: D0 12                        BNE     REGEXT_RTC      ;Exit if not zero (2/3)
  1221 00:FC23: A9 64                        LDA     #DF_TICKS       ;Get default tick count (2)
  1222 00:FC25: 85 E6                        STA     TICKS           ;Reset tick count (3)
  1223                        ;
  1224 00:FC27: E6 E7                        INC     SECS_0          ;Increment lower clock byte (5)
  1225 00:FC29: D0 0A                        BNE     SKIP_1          ;If not zero, skip next update (2/3)
  1226                        ;
  1227 00:FC2B: E6 E8                        INC     SECS_1          ;Increment second clock byte (5)
  1228 00:FC2D: D0 06                        BNE     SKIP_1          ;If not zero, skip next update (2/3)
  1229                        ;
  1230 00:FC2F: E6 E9                        INC     SECS_2          ;Increment third clock byte (5)
  1231 00:FC31: D0 02                        BNE     SKIP_1          ;If not zero, skip next update (2/3)
  1232                        ;
  1233 00:FC33: E6 EA                        INC     SECS_3          ;Increment fourth clock byte (5)
  1234                        SKIP_1
  1235 00:FC35: 6C 0A 02     REGEXT_RTC      JMP     (IRQRTVEC0)     ;Return to Exit/ROM IRQ handler (6)     
  1236                        ;
  1237                        ;**************************************************************************************************
  1238                        ;
  1239                        ;Core routines that are used to detect and configure additional I/O devices.
  1240                        ; The I/O devices supported by the 5.x Release of C02BIOS contains two I/O devices:
  1241                        ; - A Maxim DS1318 Realtime Clock - new device!
  1242                        ; - An IDE Device, i.e., IBM/Hitachi MicroDrive
  1243                        ;
  1244                        ;The first routine detects the DS1318 RTC, followed by the routine to detect the IDE device.
  1245                        ;
  1246                        ;**************************************************************************************************
  1247                        ;
  1248                        ;This routine detects the DS1318 RTC.
  1249                        ;
  1250                        ; According to the datasheet, the TE and ENOSC bits in register offset 0Ah will be set to "1"
  1251                        ; for normal update operation and the CCFG1 and CCFG0 bits will be "0" for normal operation.
  1252                        ;
  1253                        ; Note: With the W65C02 CPU, when an empty address is read by the CPU, the data that comes back
  1254                        ; will be a phantom of the upper byte of the address, or FEh for our hardware.
  1255                        ; This technique is used to detect both the DS1318 and the IDE device.
  1256                        ; If the TE and ENOSC are "1" and the CCFG1 and CCFG0 bits are "0", then the RTC is present and
  1257                        ; functioning. Only the upper 4 bits are needed to sense this, so we mask off the lower 4 bits
  1258                        ; and compare to "%11000000" to confirm the RTC.
  1259                        ;
  1260                        DETECT_RTC
  1261 00:FC38: AD 2A FE                     LDA     RTC_CONTROL_A   ;Get RTC Control Reg A (3)
  1262 00:FC3B: 29 F0                        AND     #%11110000      ;Mask off bits for TE, ENOSC, CCFG1/0 (2)
  1263 00:FC3D: C9 00                        CMP     #$11000000      ;Bits 7/6 should be on, 5/4 should be off (2)
  1264 00:FC3F: F0 01                        BEQ     FOUND_RTC       ;If bits are off, RTC is present (2/3)
  1265 00:FC41: 60                           RTS                     ;Else Return, RTC not found (6)
  1266                        ;
  1267                        FOUND_RTC
  1268 00:FC42: C7 FF                        SMB4    MATCH           ;Set Match Bit 4 for RTC present (5)
  1269 00:FC44: A2 00                        LDX     #$00            ;Zero Index for RTC message (2)
  1270                        RTC_MSG_LP
  1271 00:FC46: BD B4 FF                     LDA     RTC_MSG,X       ;Get BIOS init msg (4)
  1272 00:FC49: F0 09                        BEQ     INIT_RTC_NC     ;If zero, msg done, go Init RTC (2/3)
  1273 00:FC4B: 20 1C F8                     JSR     CHROUT          ;Send to console (6)
  1274 00:FC4E: E8                           INX                     ;Increment Index
  1275 00:FC4F: 80 F5                        BRA     RTC_MSG_LP      ;Loop back until done (3)
  1276                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 28


  1277                        ;This routine reads the Binary data registers from the DS1318 RTC. Note that the DS1318 does not
  1278                        ; keep time and date variables, but a 32-bit binary number held in 4 registers. The 32-bit value
  1279                        ; is set by a separate program that considers "0000h" as Epoch time. As a result, if no RTC is
  1280                        ; present, the BIOS 32-bit RTC count starts at "0000h".
  1281                        ;
  1282                        INIT_RTC
  1283 00:FC51: 4F FF 21                     BBR4    MATCH,NO_RTC    ;Check for RTC present, else exit (5/6,7)
  1284                        ;
  1285                        INIT_RTC_NC
  1286 00:FC54: A2 64                        LDX     #DF_TICKS       ;Get BIOS default Tick count (2)
  1287 00:FC56: 86 E6                        STX     TICKS           ;Reset the Tick count (3)
  1288                        ;
  1289                        RTC_UIP_LP
  1290 00:FC58: AD 2C FE                     LDA     RTC_STATUS      ;Get RTC Status register (3)
  1291 00:FC5B: 29 40                        AND     #%01000000      ;Mask UIP bit (2)
  1292 00:FC5D: D0 F9                        BNE     RTC_UIP_LP      :Loop back util update is finished (2/3)
  1293                        ;
  1294 00:FC5F: A2 00                        LDX     #$00            ;Set X reg to zero for data xfer (2)
  1295 00:FC61: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
  1296 00:FC63: 1C 2A FE                     TRB     RTC_CONTROL_A   ;Turn off TE Bit to disable update (6)
  1297                        ;
  1298                        RTC_LOAD_LOOP
  1299 00:FC66: BD 22 FE                     LDA     RTC_SECONDS_0,X ;Get data from RTC (4)
  1300 00:FC69: 95 E7                        STA     SECS_0,X        ;Store into RAM (4)
  1301 00:FC6B: E8                           INX                     ;Increment index
  1302 00:FC6C: E0 04                        CPX     #$04            ;Check for all 4 moved (2)
  1303 00:FC6E: D0 F6                        BNE     RTC_LOAD_LOOP   ;Loop back until done (2/3)
  1304                        ;
  1305 00:FC70: A9 80                        LDA     #%10000000      ;Get TE Bit mask (2)
  1306 00:FC72: 0C 2A FE                     TSB     RTC_CONTROL_A   ;Turn on TE Bit to enable update (6)
  1307 00:FC75: 60           NO_RTC          RTS                     ;Return to caller (6)
  1308                        ;
  1309                        ;**************************************************************************************************
  1310                        ;
  1311                        ;This routine detects the IDE Port
  1312                        ; To detect the IDE controller, it can be a bit tricky. It might take several seconds from a
  1313                        ; physical Reset of the IDE Controller before the Busy flag goes off. During this time, any
  1314                        ; commands sent to the IDE controller will fail. As I like to say, "timing is everything". After
  1315                        ; quite a bit of testing, the easy way to detect the IDE controller present is to load the
  1316                        ; IDE_STATUS register. If an IDE Controller is not present, the A Reg will show a phantom address
  1317                        ; of $FE (high order IDE hardware address) and any initialization can be bypassed.
  1318                        ;
  1319                        ; If the IDE controller is present, the IDE_STATUS read may be invalid, so it's necessary
  1320                        ; to test the BUSY flag of the status register. Once the IDE Controller is no longer busy,
  1321                        ; the controller can be initialized. This does create an obvious pause in the startup, but
  1322                        ; ensures that the IDE controller can be reliably detected and initialized at boot time.
  1323                        ;
  1324                        ; As interrupts are disabled on the IDE Controller initially, it needs to be enabled before the
  1325                        ; setup is completed. A routine does this is also called by the Reset-Diag function (JMP $FF00).
  1326                        ;
  1327                        DETECT_IDE
  1328 00:FC76: AD 3F FE                     LDA     IDE_STATUS      ;Get the IDE Status (4)
  1329 00:FC79: C9 FE                        CMP     #$FE            ;Check for an empty (phantom) address (2)
  1330 00:FC7B: D0 01                        BNE     IDE_INIT        ;If not #$FE, try to Init the IDE controller (2/3)
  1331 00:FC7D: 60                           RTS                     ;Return to caller, no IDE controller found (6)
  1332                        ;
  1333                        ;Init the IDE controller
  1334                        ; First, test for the IDE controller ready. If that works, execute the IDE device Diagnostics and
  1335                        ; check for successful completion. If it fails, exit without linking the IDE controller into the
  1336                        ; IRQ chain. Else, link IRQ chain and show message that the IDE device is found.
  1337                        ;
  1338                        IDE_INIT
  1339 00:FC7E: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  Fri Apr 11 2025  6:34                                                                                                    Page 29


  1340 00:FC81: 30 FB                        BMI     IDE_INIT        ;Loop until BUSY bit is clear (2/3)
  1341                        ;
  1342 00:FC83: 20 0F FD                     JSR     IDE_DIAG        ;Run the self diagnostic (6)
  1343 00:FC86: C9 50                        CMP     #$50            ;Check for $50 on A reg (drive ready) (2)
  1344 00:FC88: D0 11                        BNE     NO_IDE          ;If not, no IDE present (2/3)
  1345 00:FC8A: E0 01                        CPX     #$01            ;X Reg will show #$01 if diags successful (2)
  1346 00:FC8C: D0 0D                        BNE     NO_IDE          ;If failed, exit (2/3)
  1347                        ;
  1348                        ; IDE Controller found and passed initial self diagnostics test.
  1349                        ; Send IDE Found message to terminal, note: X reg = $01.
  1350                        ;
  1351 00:FC8E: D7 FF                        SMB5    MATCH           ;Set Match Bit 5 for IDE present (5)
  1352 00:FC90: BD BF FF     IDE_MSG_LP      LDA     IDE_MSG-1,X     ;Get BIOS init msg (minus 1 for X reg=1) (4)
  1353 00:FC93: F0 09                        BEQ     IDE_SETUP       ;If zero, msg done, go setup IDE (2/3)
  1354 00:FC95: 20 1C F8                     JSR     CHROUT          ;Send to console (6)
  1355 00:FC98: E8                           INX                     ;Increment Index (2)
  1356 00:FC99: 80 F5                        BRA     IDE_MSG_LP      ;Loop back until done (3)
  1357                        ;
  1358 00:FC9B: 4C 46 F9     NO_IDE          JMP     IDE_RD_ERR      ;Jump to drive error message (3)
  1359                        ;
  1360                        ;IDE Setup
  1361                        ; This will insert the IDE Controller ISR into the Interrupt Handler chain.
  1362                        ;
  1363                        ; First, disable interrupts, capture the current IRQ exit vector address
  1364                        ; and save it to the first Insert Vector. Second, load the IDE ISR routine
  1365                        ; address and store it to the main IRQ exit vector, then re-enable interrupts.
  1366                        ;
  1367                        ; Second, this routine will execute an Identify IDE command to load the Soft
  1368                        ; Config Data for the maximum LBA Count accessible by the current IDE device.
  1369                        ;
  1370                        ; Note: For performnce, the IDE ISR will be inserted before the DUART ISR!
  1371                        ;
  1372                        IDE_SETUP                               ;Insert IDE ISR into IRQ chain
  1373                        ;
  1374                        ; To load the IDE ISR Handler BEFORE the existing DUART ISR Handler:
  1375 00:FC9E: 78                           SEI                     ;Disable interrupts (2)
  1376                        ;
  1377 00:FC9F: AD 04 02                     LDA     IRQVEC0         ;Get low byte of current IRQ Exit (4)
  1378 00:FCA2: AC 05 02                     LDY     IRQVEC0+1       ;Get high byte of current IRQ Exit (4)
  1379 00:FCA5: 8D 10 02                     STA     VECINSRT0       ;Save low byte of IRQ Exit to insert 0 (4)
  1380 00:FCA8: 8C 11 02                     STY     VECINSRT0+1     ;Save high byte of IRQ Exit to insert 0 (4)
  1381                        ;
  1382 00:FCAB: A9 3D                        LDA     #<INTERUPT1     ;Get low byte of IDE ISR (2)
  1383 00:FCAD: A0 FD                        LDY     #>INTERUPT1     ;Get high byte of IDE ISR (2)
  1384 00:FCAF: 8D 04 02                     STA     IRQVEC0         ;Save low byte of IRQ Exit (4)
  1385 00:FCB2: 8C 05 02                     STY     IRQVEC0+1       ;Save high byte of IRQ Exit (4)
  1386                        ;
  1387 00:FCB5: 58                           CLI                     ;Enable interrupts (2)
  1388 00:FCB6: 20 34 FD                     JSR     IDE_EN_IRQ      ;Enable IDE Controller interrupt (6)
  1389                        ;
  1390                        ; Drop into Identify Drive routine
  1391                        ;
  1392                        IDE_IDENTIFY                            ;Identify Device
  1393                        ;
  1394                        ; This requests a 512-byte block of data that shows capabilities, CHS (not used), LBA Count, etc.
  1395                        ; The format is similar to Read LBA, except no LBA parameter is required. It effectively works as
  1396                        ; a Read Block operation and the data transferred is handled by the ISR for a Read Block.
  1397                        ; NOTE: The Identify Command is coded to load into LBA_BUFFER (address $0600).
  1398                        ;
  1399 00:FCB9: A9 00                        LDA     #<LBA_BUFFER    ;Set Address low byte (2)
  1400 00:FCBB: A0 06                        LDY     #>LBA_BUFFER    ;Set Address high byte (2)
  1401 00:FCBD: A2 01                        LDX     #$01            ;Set Block count to 1 (2)
  1402 00:FCBF: 20 C7 F8                     JSR     IDE_SET_ADDRESS ;Set Xfer address and block count (6)
  Fri Apr 11 2025  6:34                                                                                                    Page 30


  1403                        IDENT_WAIT
  1404 00:FCC2: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1405 00:FCC5: 30 FB                        BMI     IDENT_WAIT      ;Loop until BUSY bit is clear (2/3)
  1406                        
  1407                        
  1408 00:FCC7: 20 EE F8                     JSR     IDE_SET_PARMS2  ;Setup required parameters (no LBA parameter) (6)
  1409                        ;
  1410 00:FCCA: A9 EC                        LDA     #$EC            ;Get Identify Command (2)
  1411 00:FCCC: 20 61 F8                     JSR     IDENT_READ      ;Use READ_LBA routine to finish (6)
  1412                        ;
  1413                        ; Identify data loaded in buffer. Now extract LBA count and store to Soft Config Data for usage
  1414                        ; by access routines (Read/Write). Four bytes are used and the format from the Identify
  1415                        ; Command are Low-order Word / High-order Word, where each word is in Big Endian. We will store
  1416                        ; the LBA count as Little Endian, Low-order Word / High-order Word.
  1417                        ; The offset from the buffer are Words 60-61 (decimal).
  1418                        ;
  1419                        ; A table is used to index the offset of bytes to move into consecutive soft data.
  1420                        ;
  1421 00:FCCF: A2 04                        LDX     #$04            ;Set count for 4 bytes (2)
  1422 00:FCD1: BC CB FF     LBA_SIZE        LDY     LBA_OFFSET-1,X  ;Get Offset to LBA count (4)
  1423 00:FCD4: B1 F2                        LDA     (LBA_ADDR_LOW),Y        ;Load LBA Data (5)
  1424 00:FCD6: 9D 3B 02                     STA     LOAD_IDE-1,X    ;Store to Soft Config Data (5)
  1425 00:FCD9: CA                           DEX                     ;Decrement count (2)
  1426 00:FCDA: D0 F5                        BNE     LBA_SIZE        ;Loop back until done (2/3)
  1427 00:FCDC: A9 02                        LDA     #$02            ;Command for set write cache (2)
  1428                        ;
  1429                        ; Enable/Disable Write Cache for Microdrive (single call)
  1430                        ; - to use: A Reg contains $02 to enable or $82 to disable
  1431                        ;
  1432                        IDE_SET_CACHE
  1433 00:FCDE: 8D 39 FE                     STA     IDE_FEATURE     ;Send to IDE controller (4)
  1434 00:FCE1: A9 E0                        LDA     #%11100000      ;Get Drive 0, LBA. mode, etc. (2)
  1435 00:FCE3: 8D 3E FE                     STA     IDE_DRV_HEAD    ;Send to IDE controller (4)
  1436 00:FCE6: A9 EF                        LDA     #$EF            ;Get Set Features Command (2)
  1437 00:FCE8: 8D 3F FE                     STA     IDE_COMMAND     ;Send Command to set feature (4)
  1438 00:FCEB: 20 02 F9                     JSR     TST_IDE_RDY     ;Test for Drive ready (6)
  1439 00:FCEE: AD 3F FE                     LDA     IDE_STATUS      ;Get Status (4)
  1440 00:FCF1: AE 39 FE                     LDX     IDE_ERROR       ;Get Error (if any) (4)
  1441 00:FCF4: 60                           RTS                     ;Return to Caller (6)
  1442                        ;
  1443                        ; Reset IDE Controller and run Diagnostics
  1444                        ; The RECAL routine disables the IRQ function, so the routine to enable the IRQ
  1445                        ; is called, then drops into the get status routine before returning.
  1446                        ;
  1447                        IDE_RESET                               ;Do a Reset of IDE device
  1448 00:FCF5: 20 13 FD                     JSR     IDE_RECAL       ;Call IDE_RESET (set LBA mode) (6)
  1449 00:FCF8: A9 02                        LDA     #$02            ;Set A Reg to enable Write Cache (2)
  1450 00:FCFA: 20 DE FC                     JSR     IDE_SET_CACHE   ;Enable Write Cache (6)
  1451 00:FCFD: 20 02 F9                     JSR     TST_IDE_RDY     ;Wait until Drive ready (6)
  1452 00:FD00: 20 34 FD                     JSR     IDE_EN_IRQ      ;Re-enable IDE Controller interrupt (6)
  1453                        ;
  1454                        ; Drop into Get Status routine after Diagnostics are run
  1455                        ;
  1456                        IDE_GET_STATUS                          ;Get Status/Error registers from the IDE controller
  1457                        ;
  1458                        ; This routine gets the current status of the IDE Controller and can be issued at any time.
  1459                        ; It does not rely on any interrupt capability as it's a simple read of the Status and the
  1460                        ; Error registers from the IDE Controller.
  1461                        ;
  1462                        ; Note: This routine should be called whenever an Error has occurred. It returns the contents of
  1463                        ; the Error Register in the X Register and the contents of the Status Register in the A Register.
  1464                        ;
  1465                        ; Details for the Registers are:
  Fri Apr 11 2025  6:34                                                                                                    Page 31


  1466                        ;
  1467                        ; Error Register:
  1468                        ;Bit 7 - CRC Error or Bad Block error
  1469                        ;Bit 6 - Uncorrectable Data Error
  1470                        ;Bit 5 - 0 (not used) MC (used for Removable-Media drives)
  1471                        ;Bit 4 - ID Not Found
  1472                        ;Bit 3 - 0 (not used) MCR (used for Removable-Media drives)
  1473                        ;Bit 2 - Aborted Command error
  1474                        ;Bit 1 - Track Zero not found error
  1475                        ;Bit 0 - Data Address Mark Not Found
  1476                        ;
  1477                        ; Status Register:
  1478                        ;Bit 7 - Busy - IDE Controller is Busy (all other bits invalid)
  1479                        ;Bit 6 - Drive Ready (IDE Controller Ready to accept Commands)
  1480                        ;Bit 5 - Drive Write Fault - Write Fault error has occurred
  1481                        ;Bit 4 - Drive Seek Complete - is active when the drive is not seeking
  1482                        ;Bit 3 - Data Request - bit set when the IDE Controller has Data to transfer (R/W)
  1483                        ;Bit 2 - Correctable Data - bit set when bad data was found and corrected (ECC)
  1484                        ;Bit 1 - Index - bit toggled from 0 to 1 once per disk revolution
  1485                        ;Bit 0 - Error - bit set when previous command ended with some sort of error
  1486                        ;
  1487 00:FD03: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1488 00:FD06: 30 FB                        BMI     IDE_GET_STATUS  ;Loop until BUSY bit is clear (2/3)
  1489                        ;
  1490 00:FD08: AD 3F FE                     LDA     IDE_STATUS      ;Get IDE Status Register (4)
  1491 00:FD0B: AE 39 FE                     LDX     IDE_ERROR       ;Get IDE Error Register (4)
  1492 00:FD0E: 60                           RTS                     ;Return to Caller (6)
  1493                        ;
  1494                        IDE_DIAG                                ;Run internal Diagnostics on the IDE controller
  1495                        ;
  1496                        ;This is a basic self test for the IDE controller. This runs some internal tests for the
  1497                        ; IDE controller and returns with drive ready bits active ($50) and the error register as
  1498                        ; $01 if successful. For Diagnostics, the Error Register contains unique codes as follows:
  1499                        ;
  1500                        ;01h - No error Detected
  1501                        ;02h - Formatter device error
  1502                        ;03h - Sector Buffer error
  1503                        ;04h - ECC Circuitry error
  1504                        ;05h - Controller Microprocessor error
  1505                        ;8xH - Device 1 failed (not valid with a single drive system)
  1506                        ;       Note: 80h OR’ed in for the Slave Drive, lower bit definitions are the same!
  1507                        ;
  1508 00:FD0F: A9 90                        LDA     #$90            ;Get Diagnostic Command (2)
  1509 00:FD11: 80 02                        BRA     IDE_SEND_CMD    ;Branch and send Command to IDE (3)
  1510                        ;
  1511                        IDE_RECAL                               ;Recalibrate Command
  1512                        ;
  1513                        ;This is the Recalibrate Command ($1x). Upon issue the IDE controller will move the heads to
  1514                        ; Cylinder 0 and read Head 0, Sector 1. If unsuccessful, an error will be posted.
  1515                        ;
  1516 00:FD13: A9 10                        LDA     #$10            ;Get Recalibrate Command (2)
  1517                        ;
  1518                        IDE_SEND_CMD                            ;Send a Command to the IDE controller
  1519                        ;
  1520                        ;Accepts a Command code via the A reg and sets up the necessary IDE Controller
  1521                        ; registers to accept it. It also tests to ensure the controller is ready
  1522                        ; to accept the command and get the Status and Error registers on return.
  1523                        ;
  1524                        ; NOTE: this routine turns off the interrupt capability as it is called
  1525                        ; during initial setup, where the interrupt handler has not been setup yet.
  1526                        ; A separate routine is called to enable the interrupt capability.
  1527                        ;
  1528 00:FD15: 78                           SEI                     ;Disable Interrupts (2)
  Fri Apr 11 2025  6:34                                                                                                    Page 32


  1529 00:FD16: AA                           TAX                     ;Save Command to X Reg (2)
  1530 00:FD17: 20 02 F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready (6)
  1531 00:FD1A: A9 0A                        LDA     #%00001010      ;Get Mask to disable IRQ (2)
  1532 00:FD1C: 8D 36 FE                     STA     IDE_DEV_CTRL    ;Send to control register (4)
  1533 00:FD1F: A9 E0                        LDA     #%11100000      ;Get Select Mask (LBA Mode, Drive 0) (2)
  1534 00:FD21: 8D 3E FE                     STA     IDE_DRV_HEAD    ;Select Drive 0 (4)
  1535                        ;
  1536 00:FD24: 8E 3F FE                     STX     IDE_COMMAND     ;Send command to IDE (4)
  1537                        SEND_CMD_LP
  1538 00:FD27: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get IDE Alternate Status register (4)
  1539 00:FD2A: 30 FB                        BMI     SEND_CMD_LP     ;Loop until BUSY bit is clear (2/3)
  1540                        ;
  1541 00:FD2C: AD 3F FE                     LDA     IDE_STATUS      ;Get IDE Status Register (4)
  1542 00:FD2F: AE 39 FE                     LDX     IDE_ERROR       ;Get IDE Error Register (4)
  1543 00:FD32: 58                           CLI                     ;Enable interrupts (2)
  1544 00:FD33: 60                           RTS                     ;Return to caller (6)
  1545                        ;
  1546                        ; Enable Interrupts on the IDE Controller. This needs to be executed during initial setup
  1547                        ; and anytime the Reset/Diag BIOS function is called.
  1548                        ;
  1549                        IDE_EN_IRQ                              ;Enable IDE Controller interrupt
  1550 00:FD34: 20 02 F9                     JSR     TST_IDE_RDY     ;Wait for IDE to be ready (6)
  1551 00:FD37: A9 08                        LDA     #%00001000      ;Get Mask to enable IRQ (2)
  1552 00:FD39: 8D 36 FE                     STA     IDE_DEV_CTRL    ;Send to control register (4)
  1553 00:FD3C: 60                           RTS                     ;Return to caller (6)
  1554                        ;
  1555                        ;**************************************************************************************************
  1556                        ;
  1557                        ;Interrupt 1 - This is the ISR which is responsible for servicing the IDE controller.
  1558                        ; The RTC does not require any ISR capabilities as no Alarm functions are being used in the BIOS.
  1559                        ; There are extra inserts which can be used if needed at a later date.
  1560                        ; The only functions that might make sense would be to add the Alarm function at a future date.
  1561                        ;
  1562                        ;The ISR for the IDE controller will handle the data transfer for LBA read/write functions
  1563                        ; and handle any error functions. By design, the 16-bit Data Transfer feature is used for:
  1564                        ; Reading and Writing of all LBA block data and the IDE Identification data.
  1565                        ;
  1566                        ;The BIOS is using the Alternate Status register to determine if DRQ (Data Request) is active.
  1567                        ; This works as a handshake for 16-bit data transfers without issue. Note that the normal Status
  1568                        ; register resets the interrupt when read, so this is only done once in the ISR per loop.
  1569                        ;
  1570                        ;Update: This ISR has been moved to the front of the ISR chain, i.e., this ISR routine gets
  1571                        ; serviced first, then jumps to the next ISR, which services the DUART. This makes a noticeable
  1572                        ; improvement in data transfer from the IDE controller. Note that overhead for this routine will
  1573                        ; add 33 clock cycles if it just exits (IDE controller did not generate an interrupt).
  1574                        ;
  1575                        ;To check if an interrupt has been generated by the IDE controller, the Alternate Status register
  1576                        ; will be read. This contains the same information as the standard Status register but will NOT
  1577                        ; reset the interrupt on the IDE controller. By reading the Alternate Status register first, we
  1578                        ; can determine what the status of the IDE controller is and take action if required.
  1579                        ; Note that not all bit settings imply an interrupt was generated. Specifically, looking at the
  1580                        ; bit definitions below, Bits 6 and 4 are set when the IDE is ready, hence a normal condition
  1581                        ; where nothing requires any attention. Also, a Busy condition can imply the IDE controller is
  1582                        ; working on a command but may not have generated an interrupt yet. If The Busy bit (7) is set,
  1583                        ; then all other bits are invalid per Seagate documentation, so we test for that first.
  1584                        ;
  1585                        ;One annoying feature of IDE is "when" interrupts are generated. For any Read operation, once
  1586                        ; the command has been accepted, data is placed into the IDE buffer, followed by generating
  1587                        ; an interrupt to the system. Once this is done, the system will read the data. By accessing the
  1588                        ; Status register, the interrupt will be reset. This is normal operation. For a write operation,
  1589                        ; The command is sent, then DRQ goes active, which requires the data be sent to the IDE Device.
  1590                        ; Once the data is written, an interrupt is generated after it's writing is completed.
  1591                        ; As a result, there's little value of having an ISR for servicing the write function.
  Fri Apr 11 2025  6:34                                                                                                    Page 33


  1592                        ; As interrupts are enabled for the IDE Controller, all generated interrupts must be handled.
  1593                        ;
  1594                        ; Status Register bits as defined as follows:
  1595                        ;       - Bit 7 = Busy (a Command has been accepted)
  1596                        ;       - Bit 6 = Ready (IDE controller is ready to accept a command)
  1597                        ;       - Bit 5 = Write Fault (A write command failed against the media)
  1598                        ;       - Bit 4 = DSC (is set when a Seek is completed)
  1599                        ;       - Bit 3 = Data Request (set when there is data to transfer, read or write)
  1600                        ;       - Bit 2 = Correction (set when a recoverable data error was corrected)
  1601                        ;       - Bit 1 = 0 (not used)
  1602                        ;       - Bit 0 = Error (set when the previous command had an unrecoverable error)
  1603                        ;
  1604                        ;       NOTE: 25 clock cycles to here if DUART ISR is second!
  1605                        ;
  1606                        INTERUPT1                               ;Interrupt 1 (IDE)
  1607 00:FD3D: AD 36 FE                     LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1608 00:FD40: 30 39                        BMI     REGEXT01        ;If Busy bit active, just exit (2/3)
  1609                        ;
  1610                        ; - Check for Data Request (DRQ), as the Read LBA operation is the main function
  1611                        ;   of the ISR, which will handle the data transfer from the IDE controller to store the
  1612                        ;   data into memory. This ISR will handle single and multiple block transfers.
  1613                        ;
  1614 00:FD42: AD 3F FE                     LDA     IDE_STATUS      ;Get Status (resets IRQ) (4)
  1615 00:FD45: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1616 00:FD47: D0 05                        BNE     IDE_READ_BLK    ;Branch if active (2/3)
  1617                        ;
  1618                        ;If no DRQ is sensed, the other possibility is a LBA Write has occurred and an IRQ
  1619                        ; was generated after the transfer. So we check for this and branch accordingly.
  1620                        ;
  1621 00:FD49: AF FF 32                     BBS2    MATCH,IDE_WRIT_BLK      ;If Bit 2 set, Write operation (5/6,7)
  1622 00:FD4C: 80 2D                        BRA     REGEXT01        ;Exit ISR handler (3)
  1623                        ;
  1624                        IDE_READ_BLK                            ;IDE Read a Block of data
  1625                        ;
  1626                        ;Note: Arrival here means that the DRQ bit in the status register is active.
  1627                        ; This implies that:
  1628                        ;  1- A LBA Block Read is in progress. If so, the data transfer will be handled below.
  1629                        ;     This also handles multiple LBA Reads and manages the pointers and such. It also
  1630                        ;     clears the LBA Read bit in the MATCH Flag when completed.
  1631                        ;
  1632                        ;  2- A LBA Block Write with multilpe blocks is in progress. If so, the actual data
  1633                        ;     transfer is handled via the IDE WRITE Block routine. An interrupt is generated
  1634                        ;     at the end of each LBA transfer, so that is monitored here and the LBA Write bit
  1635                        ;     in the MATCH Flag is cleared when there are no more blocks to transfer.
  1636                        ;
  1637                        ;Also realize that this ISR will be executed every time the DUART generates an interrupt.
  1638                        ; This will happen every 10ms for the Jiffy-Clock timer and for character transmit and receive.
  1639                        ;
  1640 00:FD4E: 3F FF 2A                     BBR3    MATCH,REGEXT01  ;If Bit 3 clear, IDE Write (5/6,7)
  1641                        ;
  1642 00:FD51: AD 36 FE     LBA_XFER        LDA     IDE_ALT_STATUS  ;Get Status (clears IRQ) (4)
  1643 00:FD54: 29 08                        AND     #%00001000      ;Check for DRQ (2)
  1644 00:FD56: F0 18                        BEQ     IDE_RD_DONE     ;If not active, done, exit (2/3)
  1645                        ;
  1646                        IDE_RD_RBLK
  1647 00:FD58: AD 38 FE                     LDA     IDE_DATA        ;Read low byte (high byte in latch) (4)
  1648 00:FD5B: 92 F8                        STA     (BIOS_XFERL)    ;Store low byte (5)
  1649 00:FD5D: E6 F8                        INC     BIOS_XFERL      ;Increment pointers (5)
  1650 00:FD5F: D0 02                        BNE     IDE_RD_BLK1     ; (2/3)
  1651 00:FD61: E6 F9                        INC     BIOS_XFERH      ; (5)
  1652                        IDE_RD_BLK1
  1653 00:FD63: AD 34 FE                     LDA     IDE_16_READ     ;Read high byte from latch (4)
  1654 00:FD66: 92 F8                        STA     (BIOS_XFERL)    ;Store high byte (5)
  Fri Apr 11 2025  6:34                                                                                                    Page 34


  1655 00:FD68: E6 F8                        INC     BIOS_XFERL      ;Increment pointers (5)
  1656 00:FD6A: D0 E5                        BNE     LBA_XFER        ;Loop back to Xfer, saves 3 clock cycles (2/3)
  1657 00:FD6C: E6 F9                        INC     BIOS_XFERH      ; (5)
  1658                        IDE_RD_BLK2
  1659 00:FD6E: 80 E1                        BRA     LBA_XFER        ;Loop back till no more DRQs (3)
  1660                        ;
  1661 00:FD70: C6 FA        IDE_RD_DONE     DEC     BIOS_XFERC      ;Decrement Block Count to transfer (5)
  1662 00:FD72: D0 02                        BNE     IDE_ALL_DONE    ;Branch around Flag Reset until all blocks moved (2/3)
  1663 00:FD74: 37 FF                        RMB3    MATCH           ;Clear Read Block flag (5)
  1664                        ;
  1665 00:FD76: AD 36 FE     IDE_ALL_DONE    LDA     IDE_ALT_STATUS  ;Get Alternate Status Register (4)
  1666 00:FD79: 85 FB                        STA     IDE_STATUS_RAM  ;Save it to RAM location (3)
  1667 00:FD7B: 6C 10 02     REGEXT01        JMP     (VECINSRT0)     ;Exit ISR handler (6)
  1668                        ;
  1669                        IDE_WRIT_BLK                            ;IDE Write a Block of data
  1670 00:FD7E: A5 FA                        LDA     BIOS_XFERC      ;Check Block Count to transfer (3)
  1671 00:FD80: D0 F4                        BNE     IDE_ALL_DONE    ;Branch to exit if more blocks need to be moved (2/3)
  1672 00:FD82: 27 FF                        RMB2    MATCH           ;Clear Write Block flag (5)
  1673 00:FD84: 80 F0                        BRA     IDE_ALL_DONE    ;Branch and finish ISR (3)
  1674                        ;
  1675                        ;END OF BIOS CODE for Pages $F8 through $FD
  1676                        ;**************************************************************************************************
  1677                                .ORG    $FE00   ;Reserved for I/O space - do NOT put code here
  1678                        ;
  1679                        ;There are limited I/O selects for the C02 Pocket V3 hardware as below:
  1680                        ;
  1681                        ; I/O-0 = $FE00-$FE0F  NXP SC28L92 DUART (16 bytes)
  1682                        ; I/O-1 = $FE10-$FE1F  Maxim DS1318 Binary RTC (16 bytes)
  1683                        ; I/O-2 = $FE20-$FE2F  MicroDrive PATA with 16-bit Data Latch (16 bytes)
  1684                        ; I/O-3 = $FE30-$FE3F  Available for future hardware if needed (16 bits)
  1685                        ;
  1686                        ;**************************************************************************************************
  1687                        ;
  1688                                .ORG    $FE40   ;Reserved space for Soft Vector and I/O initialization data
  1689                        ;
  1690                        ;START OF BIOS DEFAULT VECTOR DATA AND HARDWARE CONFIGURATION DATA
  1691                        ;
  1692                        ;There are 192 bytes of ROM space remaining on page $FE from $FE40 - $FEFF
  1693                        ; 64 bytes of this are copied to page $02 and used for soft vectors/hardware soft configuration.
  1694                        ; 32 bytes are for vectors and 32 bytes are for hardware config. The last 32 bytes are only held
  1695                        ; in ROM and are used for hardware configuration that should not be changed.
  1696                        ;
  1697                        ;The default location for the NMI/BRK/IRQ Vector data is at $0200. They are defined at the top of
  1698                        ; the source file. There are 8 defined vectors and 8 vector inserts, all are free for base config.
  1699                        ;
  1700                        ;The default location for the hardware configuration data is at $0220. It is a freeform table which
  1701                        ; is copied from ROM to page $02. The allocated size for the hardware config table is 32 bytes.
  1702                        ;
  1703                        VEC_TABLE      ;Vector table data for default ROM handlers
  1704                        ;
  1705 00:FE40: 3D FA                        .DW     NMI_VECTOR      ;NMI Location in ROM
  1706 00:FE42: 69 FB                        .DW     BRKINSTR0       ;BRK Location in ROM
  1707 00:FE44: D7 FA                        .DW     INTERUPT0       ;IRQ Location in ROM
  1708                        ;
  1709 00:FE46: 03 F0                        .DW     M_WARM_MON      ;NMI return handler in ROM
  1710 00:FE48: 03 F0                        .DW     M_WARM_MON      ;BRK return handler in ROM
  1711 00:FE4A: 98 FF                        .DW     IRQ_EXIT0       ;IRQ return handler in ROM
  1712                        ;
  1713 00:FE4C: 00 F0                        .DW     M_COLD_MON      ;Monitor Cold start
  1714 00:FE4E: 03 F0                        .DW     M_WARM_MON      ;Monitor Warm start
  1715                        ;
  1716                        ;Vector Inserts (total of 8)
  1717                        ; These can be used as required. Note that the IDE init routine will use Insert 0 if a valid
  Fri Apr 11 2025  6:34                                                                                                    Page 35


  1718                        ; IDE controller is found and successfully initialized.
  1719                        ; Also, the NMI/BRK/IRQ and the Monitor routines are vectored, so these can also be extended,
  1720                        ; if needed, by using reserved vector locations.
  1721                        ;
  1722 00:FE50: FF FF                        .DW     $FFFF           ;Insert 0 Location (used if IDE is found)
  1723 00:FE52: FF FF                        .DW     $FFFF           ;Insert 1 Location
  1724 00:FE54: FF FF                        .DW     $FFFF           ;Insert 2 Location
  1725 00:FE56: FF FF                        .DW     $FFFF           ;Insert 3 Location
  1726 00:FE58: FF FF                        .DW     $FFFF           ;Insert 4 Location
  1727 00:FE5A: FF FF                        .DW     $FFFF           ;Insert 5 Location
  1728 00:FE5C: FF FF                        .DW     $FFFF           ;Insert 6 Location
  1729 00:FE5E: FF FF                        .DW     $FFFF           ;Insert 7 Location
  1730                        ;
  1731                        ;Configuration Data - The following tables contains the default data used for:
  1732                        ; - Reset of the SC28L92 (RESET_28L92 routine)
  1733                        ; - Init of the SC28L92 (INIT_28L92 routine)
  1734                        ; - Basic details for register definitions are below, consult SC28L92 DataSheet
  1735                        ; - Note: Output Port bits OP0/OP1 must be set for RTS to work on Ports A and B
  1736                        ;
  1737                        ;Mode Register 0 definition
  1738                        ; Bit7          ;Rx Watchdog Control
  1739                        ; Bit6          ;RX-Int(2) Select
  1740                        ; Bit5/4        ;Tx-Int fill level
  1741                        ; Bit3          ;FIFO size
  1742                        ; Bit2          ;Baud Rate Extended II
  1743                        ; Bit1          ;Test 2 (don't use)
  1744                        ; Bit0          ;Baud Rate Extended I
  1745                        ;
  1746                        ;Mode Register 1 definition
  1747                        ; Bit7          ;RxRTS Control - 1 = Yes
  1748                        ; Bit6          ;RX-Int(1) Select
  1749                        ; Bit5          ;Error Mode - 0 = Character
  1750                        ; Bit4/3        ;Parity Mode - 10 = No Parity
  1751                        ; Bit2          ;Parity Type - 0 = Even (doesn't matter)
  1752                        ; Bit1/0        ;Bits Per Character - 11 = 8
  1753                        ;
  1754                        ;Mode Register 2 Definition
  1755                        ; Bit7/6        ;Channel Mode   - 00 = Normal
  1756                        ; Bit5          ;TxRTS Control - 0 = Yes
  1757                        ; Bit4          ;TxCTS Enable - 1 = Yes
  1758                        ; Bit3-0        ;Stop Bits - 0111 = 1 Stop Bit
  1759                        ;
  1760                        ;Baud Rate Clock Definition (Extended Mode I)
  1761                        ; Upper 4 bits = Receive Baud Rate
  1762                        ; Lower 4 bits = Transmit Baud Rate
  1763                        ; for 115.2K setting is %11001100
  1764                        ; Also set ACR Bit7 = 1 for extended rates (115.2K)
  1765                        ;
  1766                        ;Command Register Definition
  1767                        ; Bit7-4        ;Special commands
  1768                        ; Bit3          ;Disable Transmit
  1769                        ; Bit2          ;Enable Transmit
  1770                        ; Bit1          ;Disable Receive
  1771                        ; Bit0          ;Enable Receive
  1772                        ;
  1773                        ;Aux Control Register Definition
  1774                        ; Bit7          ;BRG Set Select - 1 = Extended
  1775                        ; Bit6-5-4      ;Counter/Timer operating mode 110 = Counter mode from XTAL
  1776                        ; Bit3-2-1-0    ;Enable IP3-2-1-0 Change Of State (COS) IRQ
  1777                        ;
  1778                        ;Interrupt Mask Register Definition
  1779                        ; Bit7          ;Input Change Interrupt 1 = On
  1780                        ; Bit6          ;Change Break B Interrupt 1 = On
  Fri Apr 11 2025  6:34                                                                                                    Page 36


  1781                        ; Bit5          ;RxRDY B Interrupt 1 = On
  1782                        ; Bit4          ;TxRDY B Interrupt 1 = On
  1783                        ; Bit3          ;Counter Ready Interrupt 1 = On
  1784                        ; Bit2          ;Change Break A Interrupt 1 = On
  1785                        ; Bit1          ;RxRDY A Interrupt 1 = On
  1786                        ; Bit0          ;TxRDY A Interrupt 1 = On
  1787                        ;
  1788                        CFG_TABLE       ;Configuration table for hardware devices
  1789                        ;
  1790                        ;Data commands are sent in reverse order from list. This list is the default initialization for
  1791                        ; the DUART as configured for use as a Console connected to either ExtraPutty(WIN) or Serial(OSX)
  1792                        ; The data here is copied to page $02 and is used to configure the DUART during boot up. The soft
  1793                        ; data can be changed and the core INIT_28L92 routine can be called to reconfigure the DUART.
  1794                        ; NOTE: the register offset data is not kept in soft config memory as the initialization
  1795                        ; sequence should not be changed!
  1796                        ;
  1797                        ; Both serial ports are configured at startup!
  1798                        ; - Port A is used as the console.
  1799                        ; - Port B is in idle mode or used for Reader/Punch (DOS/65).
  1800                        ;
  1801                        INIT_DUART       ;Start of DUART Initialization Data
  1802 00:FE60: 03                           .DB     %00000011       ;Enable OP0/1 for RTS control Port A/B
  1803 00:FE61: 0A                           .DB     %00001010       ;Disable Receiver/Disable Transmitter B
  1804 00:FE62: 09                           .DB     %00001001       ;Enable Receiver/Disable Transmitter A
  1805 00:FE63: 0F                           .DB     %00001111       ;Interrupt Mask Register setup
  1806 00:FE64: E0                           .DB     %11100000       ;Aux Register setup for Counter/Timer
  1807 00:FE65: 48                           .DB     %01001000       ;Counter/Timer Upper Preset
  1808 00:FE66: 00                           .DB     %00000000       ;Counter/Timer Lower Preset
  1809 00:FE67: CC                           .DB     %11001100       ;Baud Rate clock for Rcv/Xmt - 115.2K B
  1810 00:FE68: CC                           .DB     %11001100       ;Baud Rate clock for Rcv/Xmt - 115.2K A
  1811 00:FE69: 30                           .DB     %00110000       ;Reset Transmitter B
  1812 00:FE6A: 20                           .DB     %00100000       ;Reset Receiver B
  1813 00:FE6B: 30                           .DB     %00110000       ;Reset Transmitter A
  1814 00:FE6C: 20                           .DB     %00100000       ;Reset Receiver A
  1815 00:FE6D: 00                           .DB     %00000000       ;Interrupt Mask Register setup
  1816 00:FE6E: F0                           .DB     %11110000       ;Command Register A - disable Power Down
  1817                        INIT_DUART_E    ;End of DUART Initialization Data
  1818                        ;
  1819 00:FE6F: FF                           .DB     $FF             ;Spare byte for offset to MR data
  1820                        ;
  1821                        ;Mode Register Data is defined separately. Using the loop routine above to send this data to
  1822                        ; the DUART does not work properly. See the description of the problem using Indexed addressing
  1823                        ; to load the DUART registers above. This data is also kept in soft config memory in page $02.
  1824                        ; Note that this data is also in reverse order for loading into MRs!
  1825                        ;
  1826 00:FE70: 17           MR2_DAT_A       .DB     %00010111       ;Mode Register 2 data
  1827 00:FE71: D3           MR1_DAT_A       .DB     %11010011       ;Mode Register 1 Data
  1828 00:FE72: F9           MR0_DAT_A       .DB     %11111001       ;Mode Register 0 Data
  1829                        ;
  1830 00:FE73: 17           MR2_DAT_B       .DB     %00010111       ;Mode Register 2 data
  1831 00:FE74: D3           MR1_DAT_B       .DB     %11010011       ;Mode Register 1 Data
  1832 00:FE75: C1           MR0_DAT_B       .DB     %11000001       ;Mode Register 0 Data
  1833                        ;
  1834                        ;Reserved for additional I/O devices (10 bytes free)
  1835                        ;
  1836 00:FE76: FF FF FF FF                  .DB     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
       00:FE7A: FF FF FF FF 
       00:FE7E: FF FF 
  1837                        ;
  1838                        ;Reset DUART Data is listed here. The sequence and commands do not require changes for any reason.
  1839                        ; These are maintained in ROM only. A total of 32 bytes are available for hard configuration data.
  1840                        ; These are the Register Offsets and Reset Data for the DUART.
  1841                        ;
  Fri Apr 11 2025  6:34                                                                                                    Page 37


  1842                        UART_RDATA      ;DUART Reset Data for Received Break (ExtraPutty/Serial Break)
  1843 00:FE80: 01                           .DB     %00000001       ;Enable Receiver
  1844                        ;
  1845                        UART_RDATA1     ;Smaller list for entry level Reset (RESET_28L92)
  1846 00:FE81: 40                           .DB     %01000000       ;Reset All Errors
  1847 00:FE82: 30                           .DB     %00110000       ;Reset Transmitter
  1848 00:FE83: 20                           .DB     %00100000       ;Reset Receiver
  1849 00:FE84: 50                           .DB     %01010000       ;Reset Break Change Interrupt
  1850                        UART_RDATAE     ;End of DUART Reset Data
  1851                        ;
  1852                        INIT_OFFSET     ;Start of DUART Initialization Register Offsets
  1853 00:FE85: 0E                           .DB     $0E             ;Set Output Port bits
  1854 00:FE86: 0A                           .DB     $0A             ;Command Register B
  1855 00:FE87: 02                           .DB     $02             ;Command Register A
  1856 00:FE88: 05                           .DB     $05             ;Interrupt Mask Register
  1857 00:FE89: 04                           .DB     $04             ;Aux Command Register
  1858 00:FE8A: 06                           .DB     $06             ;Counter Preset Upper
  1859 00:FE8B: 07                           .DB     $07             ;Counter Preset Lower
  1860 00:FE8C: 09                           .DB     $09             ;Baud Clock Register B
  1861 00:FE8D: 01                           .DB     $01             ;Baud Clock Register A
  1862 00:FE8E: 0A                           .DB     $0A             ;Command Register Port B
  1863 00:FE8F: 0A                           .DB     $0A             ;Command Register Port B
  1864 00:FE90: 02                           .DB     $02             ;Command Register Port A
  1865 00:FE91: 02                           .DB     $02             ;Command Register Port A
  1866 00:FE92: 05                           .DB     $05             ;Interrupt Mask Register
  1867 00:FE93: 02                           .DB     $02             ;Command Register Port A
  1868                        INIT_OFFSETE    ;End of DUART Initialization Register Offsets
  1869                        ;
  1870                                .ORG    $FEA0   ;Reserved space for BIOS Text Data
  1871                        ;
  1872                        ; Text Data for the BIOS routines are located here at the end of page $FE.
  1873                        ; - 96 bytes are reserved.
  1874                        ;
  1875                        ; Text Messages for the BIOS used for IDE Boot:
  1876                        ;
  1877                        NO_DRIVE_MSG
  1878 00:FEA0: 4E 6F 20 49          .DB     "No IDE Device!",13,10,0        ;No Drive Found message
       00:FEA4: 44 45 20 44 
       00:FEA8: 65 76 69 63 
       00:FEAC: 65 21 0D 0A 
       00:FEB0: 00 
  1879                        ;
  1880                        DRIVE_MSG
  1881 00:FEB1: 44 72 69 76          .DB     "Drive Error!",13,10,0  ;No drive Found message
       00:FEB5: 65 20 45 72 
       00:FEB9: 72 6F 72 21 
       00:FEBD: 0D 0A 00 
  1882                        ;
  1883                        BPART_MSG
  1884 00:FEC0: 42 61 64 20          .DB     "Bad Partition!",13,10,0        ;Incorrect Partition message
       00:FEC4: 50 61 72 74 
       00:FEC8: 69 74 69 6F 
       00:FECC: 6E 21 0D 0A 
       00:FED0: 00 
  1885                        ;
  1886                        ; Text Data for the BIOS Benchmark Ouput routine:
  1887                        ;
  1888                        MSG_SEC
  1889 00:FED1: 20 53 65 63          .DB     " Seconds",13,10,0
       00:FED5: 6F 6E 64 73 
       00:FED9: 0D 0A 00 
  1890                        ;
  1891                        ; Text Data for the BIOS CPU Register Display:
  Fri Apr 11 2025  6:34                                                                                                    Page 38


  1892                        ;
  1893                        PSTAT_MSG
  1894 00:FEDC: 0D 0A                .DB     $0D,$0A
  1895 00:FEDE: 20 20 20 50          .DB      "   PC  AC XR YR SP NV-BDIZC",$0D,$0A
       00:FEE2: 43 20 20 41 
       00:FEE6: 43 20 58 52 
       00:FEEA: 20 59 52 20 
       00:FEEE: 53 50 20 4E 
       00:FEF2: 56 2D 42 44 
       00:FEF6: 49 5A 43 0D 
       00:FEFA: 0A 
  1896 00:FEFB: 3B 20                .DB     "; "
  1897 00:FEFD: 00                   .DB     $00
  1898                        ;
  1899                        ;END OF BIOS VECTOR DATA AND HARDWARE DEFAULT CONFIGURATION DATA
  1900                        ;**************************************************************************************************
  1901                        ;START OF TOP PAGE - DO NOT MOVE FROM THIS ADDRESS!! JUMP Table starts here.
  1902                        ; - BIOS calls are listed below - total of 32, Reserved calls are for future hardware support.
  1903                        ; - "B_" JUMP Tables entries are for BIOS routines, provides isolation between BIOS and other code.
  1904                        ; - BIOS Version 5.x provides bootble support from an IDE controller (IBM/Hitachi Microdrive).
  1905                        ;
  1906                        ; NOTE: All Jump table calls add 3 clock cycles to execution time for each BIOS function.
  1907                        ;
  1908                                .ORG    $FF00   ;BIOS JMP Table, Cold Init and Vector handlers
  1909                        ;
  1910 00:FF00: 4C F5 FC     B_IDE_RESET     JMP     IDE_RESET       ;Call 00 $FF00 (3)
  1911 00:FF03: 4C 03 FD     B_IDE_GET_STAT  JMP     IDE_GET_STATUS  ;Call 01 $FF03 (3)
  1912 00:FF06: 4C B9 FC     B_IDE_IDENTIFY  JMP     IDE_IDENTIFY    ;Call 02 $FF06 (3)
  1913 00:FF09: 4C 5C F8     B_IDE_READ_LBA  JMP     IDE_READ_LBA    ;Call 03 $FF09 (3)
  1914 00:FF0C: 4C 81 F8     B_IDE_WRITE_LBA JMP     IDE_WRITE_LBA   ;Call 04 $FF0C (3)
  1915 00:FF0F: 4C CE F8     B_IDE_SET_LBA   JMP     IDE_SET_LBA     ;Call 05 $FF0F (3)
  1916 00:FF12: 4C C7 F8     B_IDE_SET_ADDR  JMP     IDE_SET_ADDRESS ;Call 06 $FF12 (3)
  1917 00:FF15: 4C DE FC     B_IDE_SET_CACHE JMP     IDE_SET_CACHE   ;Call 07 $FF15 (3)
  1918                        ;
  1919 00:FF18: 4C 00 F8     B_CHR_STAT      JMP     CHR_STAT        ;Call 09 $FF18 (3)
  1920 00:FF1B: 4C 03 F8     B_CHRIN_NW      JMP     CHRIN_NW        ;Call 10 $FF1B (3)
  1921 00:FF1E: 4C 09 F8     B_CHRIN         JMP     CHRIN           ;Call 11 $FF1E (3)
  1922 00:FF21: 4C 1C F8     B_CHROUT        JMP     CHROUT          ;Call 12 $FF21 (3)
  1923                        ;
  1924 00:FF24: 4C 33 F8     B_CHRIN2        JMP     CHRIN2          ;Call 13 $FF24 (3)
  1925 00:FF27: 4C 45 F8     B_CHROUT2       JMP     CHROUT2         ;Call 14 $FF27 (3)
  1926                        ;
  1927 00:FF2A: 4C 81 F9     B_CNT_INIT      JMP     CNT_INIT        ;Call 15 $FF2A (3)
  1928 00:FF2D: 4C 8A F9     B_CNT_STRT      JMP     CNT_STRT        ;Call 16 $FF2D (3)
  1929 00:FF30: 4C 8D F9     B_CNT_STOP      JMP     CNT_STOP        ;Call 17 $FF30 (3)
  1930 00:FF33: 4C 90 F9     B_CNT_DISP      JMP     CNT_DISP        ;Call 18 $FF33 (3)
  1931                        ;
  1932 00:FF36: 4C 59 F9     B_SET_DLY       JMP     SET_DLY         ;Call 19 $FF36 (3)
  1933 00:FF39: 4C 60 F9     B_EXE_MSDLY     JMP     EXE_MSDLY       ;Call 20 $FF39 (3)
  1934 00:FF3C: 4C 6C F9     B_EXE_LGDLY     JMP     EXE_LGDLY       ;Call 21 $FF3C (3)
  1935                        ;
  1936 00:FF3F: 4C E6 F9     B_PROMPTR       JMP     PROMPTR         ;Call 23 $FF3F (3)
  1937                        ;
  1938 00:FF42: 4C 51 FC     B_RTC_INIT      JMP     INIT_RTC        ;Call 08 $FF42 (3)
  1939                        ;
  1940 00:FF45: 4C 91 FB     B_PRSTAT        JMP     PRSTAT          ;Call 24 $FF45 (3)
  1941                        ;
  1942 00:FF48: 4C B3 FF     B_RESERVE0      JMP     RESERVE         ;Call 24 $FF48 (3)
  1943                        ;
  1944 00:FF4B: 4C A3 FF     B_INIT_VEC      JMP     INIT_VEC        ;Call 25 $FF4B (3)
  1945 00:FF4E: 4C 9F FF     B_INIT_CFG      JMP     INIT_CFG        ;Call 26 $FF4E (3)
  1946                        ;
  1947 00:FF51: 4C 01 FA     B_INIT_28L92    JMP     INIT_28L92      ;Call 27 $FF51 (3)
  Fri Apr 11 2025  6:34                                                                                                    Page 39


  1948 00:FF54: 4C 2E FA     B_RESET_28L92   JMP     RESET_28L92     ;Call 28 $FF54 (3)
  1949                        ;
  1950 00:FF57: 4C 3D FA     B_PANIC         JMP     NMI_VECTOR      ;Call 29 $FF57 (3)
  1951 00:FF5A: 4C 0E F9     B_IDE_BOOT      JMP     IDE_BOOT        ;Call 30 $FF5A (3)
  1952                        ;
  1953                        B_COLDSTRT                              ;Call 31 $FF5D
  1954 00:FF5D: 78                           SEI                     ;Disable Interrupts (safety) (2)
  1955 00:FF5E: D8                           CLD                     ;Clear decimal mode (safety) (2)
  1956 00:FF5F: A2 00                        LDX     #$00            ;Index for length of page (256 bytes) (2)
  1957 00:FF61: 74 00        PAGE0_LP        STZ     $00,X           ;Clear Page Zero (4)
  1958 00:FF63: CA                           DEX                     ;Decrement index (2)
  1959 00:FF64: D0 FB                        BNE     PAGE0_LP        ;Loop back till done (2/3)
  1960 00:FF66: CA                           DEX                     ;LDX #$FF ;-) (2)
  1961 00:FF67: 9A                           TXS                     ;Set Stack Pointer (2)
  1962                        ;
  1963 00:FF68: 20 9C FF                     JSR     INIT_PG02       ;Xfer default Vectors/HW Config to Page $02 (6)
  1964 00:FF6B: 20 FA F9                     JSR     INIT_IO         ;Init I/O - DUART (Console/Timer) (6)
  1965                        ;
  1966                        ; Send BIOS init msg to console - note: X Reg is zero on return from INIT_IO
  1967                        ;
  1968 00:FF6E: BD D0 FF     BMSG_LP         LDA     BIOS_MSG,X      ;Get BIOS init msg (4)
  1969 00:FF71: F0 06                        BEQ     CHECK_IO        ;If zero, msg done, Test for extra I/O (2/3)
  1970 00:FF73: 20 1C F8                     JSR     CHROUT          ;Send to console (6)
  1971 00:FF76: E8                           INX                     ;Increment Index (2)
  1972 00:FF77: 80 F5                        BRA     BMSG_LP         ;Loop back until done (3)
  1973                        CHECK_IO
  1974 00:FF79: 20 38 FC                     JSR     DETECT_RTC      ;Detect and Init RTC (6)
  1975 00:FF7C: 20 76 FC                     JSR     DETECT_IDE      ;Detect and Init IDE (6)
  1976 00:FF7F: 20 B3 FF                     JSR     RESERVE         ;Reserve one more Init routine for future use (6)
  1977 00:FF82: 80 D6                        BRA     B_IDE_BOOT      ;Branch to Boot IDE device (3)
  1978                        ;
  1979                        ;This front end for the IRQ vector, saves the CPU registers and determines if a BRK instruction
  1980                        ; was the cause. There are 25 clock cycles to jump to the IRQ vector, and there are 26 clock cycles
  1981                        ; to jump to the BRK vector. Note that there is an additional 18 clock cycles for the IRQ return
  1982                        ; vector, which restores the registers. This creates an overhead of 43 (IRQ) or 44 (BRK) clock
  1983                        ; cycles, plus whatever the ISR or BRK service routines add.
  1984                        ;
  1985                        IRQ_VECTOR                              ;This is the ROM start for the BRK/IRQ handler
  1986 00:FF84: 48                           PHA                     ;Save A Reg (3)
  1987 00:FF85: DA                           PHX                     ;Save X Reg (3)
  1988 00:FF86: 5A                           PHY                     ;Save Y Reg (3)
  1989 00:FF87: BA                           TSX                     ;Get Stack pointer (2)
  1990 00:FF88: BD 04 01                     LDA     $0100+4,X       ;Get Status Register (4)
  1991 00:FF8B: 29 10                        AND     #$10            ;Mask for BRK bit set (2)
  1992 00:FF8D: D0 03                        BNE     DO_BRK          ;If set, handle BRK (2/3)
  1993 00:FF8F: 6C 04 02                     JMP     (IRQVEC0)       ;Jump to Soft vectored IRQ Handler (6)
  1994 00:FF92: 6C 02 02     DO_BRK          JMP     (BRKVEC0)       ;Jump to Soft vectored BRK Handler (6)
  1995                        ;
  1996 00:FF95: 6C 00 02     NMI_ROM         JMP     (NMIVEC0)       ;Jump to Soft vectored NMI handler (6)
  1997                        ;
  1998                        ;This is the standard return for the IRQ/BRK handler routines (18 clock cycles)
  1999                        ;
  2000 00:FF98: 7A           IRQ_EXIT0       PLY                     ;Restore Y Reg (4)
  2001 00:FF99: FA                           PLX                     ;Restore X Reg (4)
  2002 00:FF9A: 68                           PLA                     ;Restore A Reg (4)
  2003 00:FF9B: 40                           RTI                     ;Return from IRQ/BRK routine (6)
  2004                        ;
  2005 00:FF9C: 20 A3 FF     INIT_PG02       JSR     INIT_VEC        ;Init the Soft Vectors first (6)
  2006 00:FF9F: A0 40        INIT_CFG        LDY     #$40            ;Get offset to Config data (2)
  2007 00:FFA1: 80 02                        BRA     DATA_XFER       ;Go move the Config data to page $02 (3)
  2008                        ;
  2009 00:FFA3: A0 20        INIT_VEC        LDY     #$20            ;Get offset to Vector data (2)
  2010 00:FFA5: 78           DATA_XFER       SEI                     ;Disable Interrupts, can be called via JMP table (2)
  Fri Apr 11 2025  6:34                                                                                                    Page 40


  2011 00:FFA6: A2 20                        LDX     #$20            ;Set count for 32 bytes (2)
  2012 00:FFA8: B9 3F FE     DATA_XFLP       LDA     VEC_TABLE-1,Y   ;Get ROM table data (4)
  2013 00:FFAB: 99 FF 01                     STA     SOFTVEC-1,Y     ;Store in Soft table location (4)
  2014 00:FFAE: 88                           DEY                     ;Decrement index (2)
  2015 00:FFAF: CA                           DEX                     ;Decrement count (2)
  2016 00:FFB0: D0 F6                        BNE     DATA_XFLP       ;Loop back till done (2/3)
  2017 00:FFB2: 58                           CLI                     ;Re-enable interrupts (2)
  2018 00:FFB3: 60           RESERVE         RTS                     ;Return to caller (6)
  2019                        ;
  2020                        RTC_MSG
  2021                        ;
  2022                        ;This is a short BIOS message that is displayed when the DS1318 RTC is found
  2023 00:FFB4: 52 54 43 20                  .DB     "RTC found"
       00:FFB8: 66 6F 75 6E 
       00:FFBC: 64 
  2024 00:FFBD: 0D 0A 00                     .DB     $0D,$0A,$00
  2025                        ;
  2026                        IDE_MSG
  2027                        ;
  2028                        ;This is a short BIOS message that is displayed when the IDE controller is found
  2029 00:FFC0: 49 44 45 20                  .DB     "IDE found"
       00:FFC4: 66 6F 75 6E 
       00:FFC8: 64 
  2030 00:FFC9: 0D 0A 00                     .DB     $0D,$0A,$00
  2031                        ;
  2032                        ;The offset data here is used as an index to the Identity Block of Data from the IDE controller
  2033 00:FFCC: 78 79 7A 7B  LBA_OFFSET      .DB     120,121,122,123 ;Offset Data for LBA Size
  2034                        ;
  2035                        ;This BIOS version does not rely on CPU clock frequency for RTC timing. Timing is based on the
  2036                        ; SC28L92 DUART Timer/Counter which has a fixed frequency of 3.6864MHz. Jiffy clock set at 10ms.
  2037                        ; Edit Displayed clock rate at CPU_CLK below as needed if running "other" than 8MHz.
  2038                        ;
  2039                                .ORG    $FFD0   ;Hard coded BIOS message to the top of memory (Monitor uses this)
  2040                        ;
  2041                        ;BIOS init message - sent before jumping to the monitor coldstart vector.
  2042                        ; Changed for BIOS 5.x release, as CPU clock speeds can exceed 10MHz.
  2043                        ; - BIOS version is "5.x" while CPU speed is now two digits.
  2044                        ;
  2045 00:FFD0: 0D 0A        BIOS_MSG        .DB     $0D,$0A         ;CR/LF
  2046 00:FFD2: 43 30 32 42                  .DB     "C02BIOS 5.0"   ;Updated Release Version
       00:FFD6: 49 4F 53 20 
       00:FFDA: 35 2E 30 
  2047 00:FFDD: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  2048 00:FFDF: 57 36 35 43                  .DB     "W65C02@"       ;Display CPU type
       00:FFE3: 30 32 40 
  2049 00:FFE6: 38 4D 48 7A  CPU_CLK         .DB     "8MHz "         ;Displayed CPU Clock frequency
       00:FFEA: 20 
  2050 00:FFEB: 0D 0A                        .DB     $0D,$0A         ;CR/LF
  2051 00:FFED: 31 30 2F 30                  .DB     "10/04/2025"    ;DD/MM/YYYY
       00:FFF1: 34 2F 32 30 
       00:FFF5: 32 35 
  2052 00:FFF7: 0D 0A 00                     .DB     $0D,$0A,$00     ;CR/LF and terminate string
  2053                        ;
  2054                                .ORG    $FFFA   ;W65C02 Vectors:
  2055                        ;
  2056 00:FFFA: 95 FF                        .DW     NMI_ROM         ;NMI
  2057 00:FFFC: 5D FF                        .DW     B_COLDSTRT      ;RESET
  2058 00:FFFE: 84 FF                        .DW     IRQ_VECTOR      ;IRQ/BRK
  2059                                .END


      Lines assembled: 2478
      Errors: 0
  Fri Apr 11 2025  6:34                                                                                                    Page 41


