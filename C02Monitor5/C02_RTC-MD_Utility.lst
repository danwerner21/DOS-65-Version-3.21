  Sun Mar 30 2025  9:15                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*                Utility program for the RTC/MicroDrive PATA Adapter 0.90                        *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*       This Utility provides functions to identify, test and edit a MicroDrive when present     *
     7                        ;*         The following functions are provided:                                                  *
     8                        ;*           - Identify MicroDrive: Vendor String, Device Serial, LBA Count in Hex/Decimal)       *
     9                        ;*           - Read any LBA into memory and display contents in Hex/ASCII                         *
    10                        ;*           - Write any LBA from memory and display contents in Hex/ASCII                        *
    11                        ;*           - Read Full LBA count sequentially or staggered                                      *
    12                        ;*           - Write Full LBA count sequentially or staggered                                     *
    13                        ;*         - Note: Write pattern is $55AA for Sequential Write                                    *
    14                        ;*                 Write pattern is User defined for Write Benchmark                              *
    15                        ;*                                                                                                *
    16                        ;**************************************************************************************************
    17                        
    18                                PL      66      ;Page Length
    19                                PW      132     ;Page Width (# of char/line)
    20                                CHIP    W65C02S ;Enable WDC 65C02 instructions
    21                                PASS1   OFF     ;Set ON when used for debug
    22                                INCLIST ON      ;Set ON for listing Include files
    23                        ;**************************************************************************************************
    24                        ;
    25                        ; C02BIOS Version 5.0 is the supported BIOS level for this utility!
    26                        ;
    27                        ; This BIOS version also use a common source file for constants and variables used by
    28                        ; both. This just simplifies keeping both code pieces in sync.
    29                        ;
    30                        ;**************************************************************************************************
    31                        ;
    32                        ; Page Zero definitions $00 to $9F reserved for user routines
    33                        ; NOTES:- Locations $00 and $01 are used to zero RAM (calls CPU reset)
    34                        ;       - EEPROM Byte Write routine loaded into Page Zero at $90-$A4
    35                        ;
    36                        ;       - Page Zero definitions for HEX2BCD and BCD2HEX routines, RTC setup
    37                        ;
    38             00000010   HPHANTOM        .EQU    $0010           ; HPHANTOM MUST be located (in target memory)
    39             00000011   HEX0AND1        .EQU    $11             ;  immediately below the HEX0AND1 variable
    40             00000012   HEX2AND3        .EQU    $12
    41             00000013   HEX4AND5        .EQU    $13
    42             00000014   HEX6AND7        .EQU    $14
    43                        ;
    44             00000014   DPHANTOM        .EQU    $0014           ; DPHANTOM MUST be located (in target memory)
    45             00000015   DEC0AND1        .EQU    $15             ; immediately below the DEC0AND1 variable
    46             00000016   DEC2AND3        .EQU    $16
    47             00000017   DEC4AND5        .EQU    $17
    48             00000018   DEC6AND7        .EQU    $18
    49             00000019   DEC8AND9        .EQU    $19
    50                        ;
    51             00000020   BUFADR          .EQU    $20
    52             00000021   BUFADRH         .EQU    $21
    53                        ;
    54             00000030   IBUFF           .EQU    $30             ;Input buffer... lots of space available
    55                        ;
    56             00000040   RTC_LOAD        .EQU    $40             ;Start of Data to set hardware RTC
    57                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 2


    58                        ;**************************************************************************************************
    59                        ;
    60                                INCLUDE         C02Constants5.asm       ;C02 BIOS/Monitor variables, etc.
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*                       C02 Constants used for the 5.x releases of C02BIOS5                      *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  28/12/2024 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ;                                                                                                 *
    10                        ; C02BIOS Version is now at 5.0                                                                   *
    11                        ; - All Constants and Variables for the BIOS are now defined in a single source file (this one)   *
    12                        ;                                                                                                 *
    13                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    14                        ;                                                                                                 *
    15                        ;**************************************************************************************************
    16                        ;                                                                                                 *
    17                        ;          - Page Zero locations $00 to $BF (192 bytes) reserved for user applications            *
    18                        ;                                                                                                 *
    19                        ;**************************************************************************************************
    20                        ;
    21             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Monitor Page 0 use ($A0-$CF, 48 bytes)
    22                        ;
    23             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    24                        ;
    25             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    26                        ;
    27                        ;       - 16-bit variables:
    28             000000A4   HEXDATAH        .EQU    PGZERO_ST+04            ;Hexadecimal input
    29             000000A5   HEXDATAL        .EQU    PGZERO_ST+05
    30             000000A6   COMLO           .EQU    PGZERO_ST+06            ;User command address
    31             000000A7   COMHI           .EQU    PGZERO_ST+07
    32             000000A8   INDEXL          .EQU    PGZERO_ST+08            ;Index for address - multiple routines
    33             000000A9   INDEXH          .EQU    PGZERO_ST+09
    34             000000AA   TEMP1L          .EQU    PGZERO_ST+10            ;Index for word temp value used by Memdump
    35             000000AB   TEMP1H          .EQU    PGZERO_ST+11
    36             000000AC   SRCL            .EQU    PGZERO_ST+12            ;Source address for memory operations
    37             000000AD   SRCH            .EQU    PGZERO_ST+13
    38             000000AE   TGTL            .EQU    PGZERO_ST+14            ;Target address for memory operations
    39             000000AF   TGTH            .EQU    PGZERO_ST+15
    40             000000B0   LENL            .EQU    PGZERO_ST+16            ;Length address for memory operations
    41             000000B1   LENH            .EQU    PGZERO_ST+17
    42                        ;
    43                        ;       - 8-bit variables and constants:
    44             000000B2   BUFIDX          .EQU    PGZERO_ST+18            ;Buffer index
    45             000000B3   BUFLEN          .EQU    PGZERO_ST+19            ;Buffer length
    46             000000B4   IDX             .EQU    PGZERO_ST+20            ;Temp Indexing
    47             000000B5   IDY             .EQU    PGZERO_ST+21            ;Temp Indexing
    48             000000B6   TEMP1           .EQU    PGZERO_ST+22            ;Temp - Code Conversion routines
    49             000000B7   TEMP2           .EQU    PGZERO_ST+23            ;Temp - Memory/EEPROM/SREC routines - Disassembler
    50                        ;TEMP3           .EQU    PGZERO_ST+24            ;Temp - EEPROM/SREC routines
    51             000000B8   CMDFLAG         .EQU    PGZERO_ST+24            ;Command Flag, bit specific, used by many routines
    52             000000B9   OPXMDM          .EQU    PGZERO_ST+25            ;Saved Opcode/Xmodem Flag variable
    53                        ;
    54                        ;       - Xmodem transfer variables
    55             000000BA   CRCHI           .EQU    PGZERO_ST+26            ;CRC hi byte  (two byte variable)
    56             000000BB   CRCLO           .EQU    PGZERO_ST+27            ;CRC lo byte - Operand in Disassembler
    57             000000BC   CRCCNT          .EQU    PGZERO_ST+28            ;CRC retry count - Operand in Disassembler
    58             000000BD   PTRL            .EQU    PGZERO_ST+29            ;Data pointer lo byte - Mnemonic in Disassembler
    59             000000BE   PTRH            .EQU    PGZERO_ST+30            ;Data pointer hi byte - Mnemonic in Disassembler
    60             000000BF   BLKNO           .EQU    PGZERO_ST+31            ;Block number
  Sun Mar 30 2025  9:15                                                                                                    Page 3


    61                        ;
    62                        ;       - Spare Monitor byte for future use
    63                        ;SPARE_M0        .EQU    PGZERO_ST+33            ;Spare Monitor page zero byte
    64                        ;
    65                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    66                        ;BIOS_PG0        .EQU    PGZERO_ST+32            ;Start of BIOS page 0 use ($D0-$FF, 48 bytes)
    67                        
    68             000000C0   BIOS_PG0        .EQU    $C0                     ;Start of BIOS Page 0 usage (64 bytes)
    69                        ;
    70                        ; Reserve 8 bytes of Page Zero for DOS/65 usage ($C0 - $C7).
    71                        ;
    72                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    73                        ;
    74             000000C8   DATABUFF        .EQU    BIOS_PG0+08             ;Data Buffer - 6 bytes ($C8-$CD)
    75                        ;
    76             000000CE   BINVALL         .EQU    BIOS_PG0+14             ;Binary Value for HEX2ASC
    77             000000CF   BINVALH         .EQU    BIOS_PG0+15
    78                        ;
    79             000000D0   STRINGL         .EQU    BIOS_PG0+16             ;Pointer for sending a text string low
    80             000000D1   STRINGH         .EQU    BIOS_PG0+17
    81                        ;
    82                        ;       - BRK handler routine
    83             000000D2   PCL             .EQU    BIOS_PG0+18             ;Program Counter Low index
    84             000000D3   PCH             .EQU    BIOS_PG0+19             ;Program Counter High index
    85             000000D4   PREG            .EQU    BIOS_PG0+20             ;Temp Status Reg
    86             000000D5   SREG            .EQU    BIOS_PG0+21             ;Temp Stack ptr
    87             000000D6   YREG            .EQU    BIOS_PG0+22             ;Temp Y Reg
    88             000000D7   XREG            .EQU    BIOS_PG0+23             ;Temp X Reg
    89             000000D8   AREG            .EQU    BIOS_PG0+24             ;Temp A Reg
    90                        ;
    91                        ;       - 28L92 IRQ handler pointers and status
    92             000000D9   ICNT_A          .EQU    BIOS_PG0+25             ;Input buffer count
    93             000000DA   IHEAD_A         .EQU    BIOS_PG0+26             ;Input buffer head pointer
    94             000000DB   ITAIL_A         .EQU    BIOS_PG0+27             ;Input buffer tail pointer
    95             000000DC   OCNT_A          .EQU    BIOS_PG0+28             ;Output buffer count
    96             000000DD   OHEAD_A         .EQU    BIOS_PG0+29             ;Output buffer head pointer
    97             000000DE   OTAIL_A         .EQU    BIOS_PG0+30             ;Output buffer tail pointer
    98                        ;
    99             000000DF   ICNT_B          .EQU    BIOS_PG0+31             ;Input buffer count
   100             000000E0   IHEAD_B         .EQU    BIOS_PG0+32             ;Input buffer head pointer
   101             000000E1   ITAIL_B         .EQU    BIOS_PG0+33             ;Input buffer tail pointer
   102             000000E2   OCNT_B          .EQU    BIOS_PG0+34             ;Output buffer count
   103             000000E3   OHEAD_B         .EQU    BIOS_PG0+35             ;Output buffer head pointer
   104             000000E4   OTAIL_B         .EQU    BIOS_PG0+36             ;Output buffer tail pointer
   105                        ;
   106             000000E5   UART_IRT        .EQU    BIOS_PG0+37             ;SC28L92 Interrupt Status byte
   107                        ;
   108                        ;       -RTC DS1318 Values:
   109                        ; These are the values used for the alternate RTC chip, which is simply a 32-bit interval counter
   110                        ; which is loaded with EPOCH time and incremented each second as a 32-bit integer.
   111                        ; This frees up 3 locations in Page Zero.
   112                        ;
   113             000000E6   TICKS           .EQU    BIOS_PG0+38             ;Number of timer countdowns = 1 second (100)
   114             000000E7   SECS_0          .EQU    BIOS_PG0+39             ;Seconds: bits 0-7
   115             000000E8   SECS_1          .EQU    BIOS_PG0+40             ;Seconds: bits 8-15
   116             000000E9   SECS_2          .EQU    BIOS_PG0+41             ;Seconds: bits 16-23
   117             000000EA   SECS_3          .EQU    BIOS_PG0+42             ;Seconds: bits 24-31
   118                        ;
   119                        ;       - Delay Timer variables
   120             000000EB   MSDELAY         .EQU    BIOS_PG0+43             ;Timer delay countdown byte (255 > 0)
   121             000000EC   SETMS           .EQU    BIOS_PG0+44             ;Set timeout for delay routines - BIOS use only
   122             000000ED   DELLO           .EQU    BIOS_PG0+45             ;Delay value BIOS use only
   123             000000EE   DELHI           .EQU    BIOS_PG0+46             ;Delay value BIOS use only
  Sun Mar 30 2025  9:15                                                                                                    Page 4


   124                        ;
   125                        ;       - Count variables for 10ms benchmark timing
   126             000000EF   MS10_CNT        .EQU    BIOS_PG0+47             ;10ms Count variable
   127             000000F0   SECL_CNT        .EQU    BIOS_PG0+48             ;Seconds Low byte count
   128             000000F1   SECH_CNT        .EQU    BIOS_PG0+49             ;Seconds High byte count
   129                        ;
   130                        ;       - Address and pointers for IDE Interface
   131             000000F2   LBA_ADDR_LOW    .EQU    BIOS_PG0+50             ;LBA Transfer Address low byte
   132             000000F3   LBA_ADDR_HIGH   .EQU    BIOS_PG0+51             ;LBA Transfer Address high byte
   133                        ;
   134             000000F4   LBA_XFER_CNT    .EQU    BIOS_PG0+52             ;LBA Transfer Count 1-xx (check RAM space!)
   135                        ;
   136             000000F5   LBA_LOW_BYTE    .EQU    BIOS_PG0+53             ;LBA Block number bits 0-7
   137             000000F6   LBA_HIGH_BYTE   .EQU    BIOS_PG0+54             ;LBA Block number bits 8-15
   138             000000F7   LBA_EXT_BYTE    .EQU    BIOS_PG0+55             ;LBA Block number bits 16-23
   139                        ;
   140             000000F8   BIOS_XFERL      .EQU    BIOS_PG0+56             ;BIOS Move Routine low byte
   141             000000F9   BIOS_XFERH      .EQU    BIOS_PG0+57             ;BIOS Move Routine high byte
   142             000000FA   BIOS_XFERC      .EQU    BIOS_PG0+58             ;BIOS Block Count moved (needs to be set)
   143                        ;
   144             000000FB   IDE_STATUS_RAM  .EQU    BIOS_PG0+59             ;IDE RAM-Based Status
   145                        ;
   146             000000FC   B_SPARE0        .EQU    BIOS_PG0+60             ;Spare BIOS byte page zero
   147             000000FD   B_SPARE1        .EQU    BIOS_PG0+61             ;Spare BIOS byte page zero
   148             000000FE   B_SPARE2        .EQU    BIOS_PG0+62             ;Spare BIOS byte page zero
   149                        ;
   150                        ;       - Timer/Counter Match flag for Delay/Benchmark and hardware support
   151             000000FF   MATCH           .EQU    BIOS_PG0+63             ;Bit 7 used for Delay
   152                                                                        ;Bit 6 used for Benchmark
   153                                                                        ;Bit 5 used to show IDE drive present
   154                                                                        ;Bit 4 used to show RTC chip present
   155                                                                        ;Bits 3,2 used for IDE Interrupt Handler
   156                                                                        ;Bits 1,0 reserved for future use
   157                        ;
   158                        ;**************************************************************************************************
   159                        ;
   160                        ; Default for RTC tick count - number of IRQs for 1 second
   161             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   162                        ;
   163                        ;**************************************************************************************************
   164                        ;
   165             00000200   SOFTVEC         .EQU    $0200                   ;Start of soft vectors
   166                        ;The Interrupt structure is vector based. During startup, Page $02 is loaded from ROM.
   167                        ; The soft vectors are structured to allow inserting additional routines either before
   168                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   169                        ;
   170                        ;The main set of vectors occupy the first 16 bytes of Page $02. The ROM handler for
   171                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   172                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   173                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   174                        ;
   175                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   176                        ; which occupy 16 bytes. They can be used as required.
   177                        ; Currently, VECINSRT0 will be used if an IDE Controller is detected.
   178                        ;
   179             00000200   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   180             00000202   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   181             00000204   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   182                        ;
   183             00000206   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   184             00000208   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   185             0000020A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   186                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 5


   187             0000020C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   188             0000020E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   189                        ;
   190             00000210   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   191             00000212   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   192             00000214   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   193             00000216   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   194             00000218   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   195             0000021A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   196             0000021C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   197             0000021E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   198                        ;
   199                        ;**************************************************************************************************
   200                        ;
   201                        ;Soft Config values below are loaded from ROM and are the default I/O setup Configuration data that
   202                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O Configuration
   203                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   204                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O Configuration.
   205                        ;
   206                        ;There are a total of 32 Bytes Configuration data reserved starting at $0220,
   207                        ; - 22 bytes are reserved for the NXP SC28L92 DUART.
   208                        ;
   209             00000220   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware Config parameters
   210                        ;
   211             00000220   LOAD_28L92      .EQU    SOFTCFG+00              ;SC28L92 Soft Config Data
   212                        ;
   213                        ; The configuration for the DUART consists of 14 parameters/commands stored in the following
   214                        ; - memory locations. Note that these are sent in reverse, i.e., $22E thru $220.
   215                        ;
   216                        ;       $220    .DB     %00000011       $03     ;Enable OP0/1 for RTS control Port A/B
   217                        ;       $221    .DB     %00001010       $A0     ;Disable Receiver/Disable Transmitter B
   218                        ;       $222    .DB     %00001001       $09     ;Enable Receiver/Disable Transmitter A
   219                        ;       $223    .DB     %00001111       $0F     ;Interrupt Mask Register setup
   220                        ;       $224    .DB     %11100000       $E0     ;Aux Register setup for Counter/Timer
   221                        ;       $225    .DB     %01001000       $48     ;Counter/Timer Upper Preset (18432 decimal)
   222                        ;       $226    .DB     %00000000       $00     ;Counter/Timer Lower Preset
   223                        ;       $227    .DB     %11001100       $CC     ;Baud Rate clock for B Rcv/Xmt - 115.2K
   224                        ;       $228    .DB     %11001100       $CC     ;Baud Rate clock for A Rcv/Xmt - 115.2K
   225                        ;       $229    .DB     %00110000       $30     ;Reset Transmitter B
   226                        ;       $22A    .DB     %00100000       $20     ;Reset Receiver B
   227                        ;       $22B    .DB     %00110000       $30     ;Reset Transmitter A
   228                        ;       $22C    .DB     %00100000       $20     ;Reset Receiver A
   229                        ;       $22D    .DB     %00000000       $00     ;Interrupt Mask Register setup (clear)
   230                        ;       $22E    .DB     %11110000       $F0     ;Command Register A - Disable Power Down
   231                        ;       $22F    .DB     %11111111       $FF     ;Spare Byte
   232                        ;
   233                        ; The MR registers of the DUART also have soft config data loaded here, but is separate from the
   234                        ; - main register config data, as these are all accessed via a single I/O port (auto-indexed).
   235                        ; - These are also sent in reverse order as above.
   236                        ;
   237                        ;       $230    .DB     %00010111       $17     ;Mode Register 2 data
   238                        ;       $231    .DB     %11010011       $D3     ;Mode Register 1 Data
   239                        ;       $232    .DB     %11111001       $F9     ;Mode Register 0 Data
   240                        ;
   241                        ;       $233    .DB     %00010111       $17     ;Mode Register 2 data
   242                        ;       $234    .DB     %11010011       $D3     ;Mode Register 1 Data
   243                        ;       $235    .DB     %11000001       $C1     ;Mode Register 0 Data
   244                        ;
   245                        ;       10 additional bytes are reserved for additional soft configuration data.
   246                        ;
   247                        ; The Microdrive is initialized and the total LBA count is saved here during startup.
   248                        ;  It is used by various utilities and allows drive capacity sensing without sending additional
   249                        ;  commands to the Microdrive. A total of 4 bytes are used for a 32-bit LBA count. These are saved
  Sun Mar 30 2025  9:15                                                                                                    Page 6


   250                        ;  at addresses $23C - $23F. Order is low-word/high-word. Each word is low-byte/high-byte.
   251                        ; Note: these 4 bytes are allocated from the 10 additional bytes noted above.
   252                        ;
   253             0000023C   LOAD_IDE        .EQU    SOFTCFG+28              ;IDE/CF-Card Soft Config Data
   254                        ;
   255                        ;       $23C    .DW                             ;Low order LBA count
   256                        ;       $23E    .DW                             ;High order LBA count
   257                        ;
   258                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   259                        ;
   260             00000240   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $02 following Hardware Config data
   261                        ;       $240                                    ;Start of search buffer (16 bytes)
   262                        ;
   263                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   264                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   265                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
   266                        ; Xmodem/CRC Loader is 176 bytes
   267                        ;
   268                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   269                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   270                        ; a CR/LF to the end of each record for a total of 44 bytes.
   271                        ;
   272             00000250   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   273                        ;       $250                                    ;Start of S-Record buffer
   274                        ;
   275                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   276                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   277                        ;
   278             0000027C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   279                        ;       $27C                                    ;Start of Receive buffer for Xmodem
   280                        ;
   281                        ;Page $02 is completely allocated for Buffers, Config Data and Vector pointers.
   282                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   283                        ; being used concurrently.
   284                        ;
   285                        ;**************************************************************************************************
   286                        ;
   287             00000300   IBUF_A          .EQU    $0300                   ;Console Input Buffer - 128 bytes
   288             00000380   OBUF_A          .EQU    $0380                   ;Console Output Buffer - 128 bytes
   289                        ;
   290             00000400   IBUF_B          .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   291             00000480   OBUF_B          .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   292                        ;
   293                        ;**************************************************************************************************
   294                        ;
   295                        ;Page $05 is reserved for future hardware / software expansion
   296                        ;
   297                        ;**************************************************************************************************
   298                        ;
   299                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   300             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   301                        ;
   302                        ;Pages $07 - $08 are used for the IDE device Boot Buffer (512 bytes)
   303             00000800   BOOT_BUFFER     .EQU    $0800                   ;Default IDE Boot Buffer address
   304                        ;
   305                        ;**************************************************************************************************
   306                        ;XMODEM Control Character Constants
   307             00000001   SOH             .EQU    $01                     ;Start of Block Header
   308             00000004   EOT             .EQU    $04                     ;End of Text marker
   309             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   310             00000015   NAK             .EQU    $15                     ;Bad Block Acknowledged
   311             00000018   CAN             .EQU    $18                     ;Cancel character
   312                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 7


   313                        ;**************************************************************************************************
   314                        ;
   315                        ;**************************************************************************************************
   316                        ;
   317                        ;DOS/65 can be called from the Monitor via the Ctrl-B command. - Temporary!
   318                        ;The start location is just added here for convenience, but should be changed if needed.
   319                        ;
   320             0000D400   DOS_65          .EQU    $D400                   ;Default SIM location to Boot DOS/65 (optional)
   321                        ;
   322                        ;**************************************************************************************************
   323                        ;
   324             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   325                        ;
   326                        ;**************************************************************************************************
   327                        ;
   328             0000FE80   SC28L92_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   329                        ;
   330             0000FE80   UART_MODEREG_A  .EQU    SC28L92_BASE+$00        ;MR0/MR1/MR2 Port A sequential (READ/WRITE)
   331             0000FE81   UART_STATUS_A   .EQU    SC28L92_BASE+$01        ;UART Status Register Port A (READ)
   332             0000FE81   UART_CLKSEL_A   .EQU    SC28L92_BASE+$01        ;UART Clock Select Port A (WRITE)
   333             0000FE82   UART_RESERVE_A  .EQU    SC28L92_BASE+$02        ;UART Reserved Port A (READ)
   334             0000FE82   UART_COMMAND_A  .EQU    SC28L92_BASE+$02        ;UART Command Register Port A (WRITE)
   335             0000FE83   UART_RECEIVE_A  .EQU    SC28L92_BASE+$03        ;UART Receive Register Port A (READ)
   336             0000FE83   UART_TRANSMIT_A .EQU    SC28L92_BASE+$03        ;UART Transmit Register Port A (WRITE)
   337                        ;
   338             0000FE84   UART_PORT_CHG   .EQU    SC28L92_BASE+$04        ;UART Input Port Change Register (READ)
   339             0000FE84   UART_AUXCR      .EQU    SC28L92_BASE+$04        ;UART Aux Command Register (WRITE)
   340             0000FE85   UART_ISR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Status Register (READ)
   341             0000FE85   UART_IMR        .EQU    SC28L92_BASE+$05        ;UART Interrupt Mask Register (WRITE)
   342                        ;
   343             0000FE86   UART_CNTU       .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Register (READ)
   344             0000FE86   UART_CNTUP      .EQU    SC28L92_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   345             0000FE87   UART_CNTL       .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Register (READ)
   346             0000FE87   UART_CNTLP      .EQU    SC28L92_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   347                        ;
   348             0000FE88   UART_MODEREG_B  .EQU    SC28L92_BASE+$08        ;MR0/MR1/MR2 Port B sequential (READ/WRITE)
   349             0000FE89   UART_STATUS_B   .EQU    SC28L92_BASE+$09        ;UART Status Register Port B (READ)
   350             0000FE89   UART_CLKSEL_B   .EQU    SC28L92_BASE+$09        ;UART Clock Select Port B (WRITE)
   351             0000FE8A   UART_RESERVE_B  .EQU    SC28L92_BASE+$0A        ;UART Reserved Port B (READ)
   352             0000FE8A   UART_COMMAND_B  .EQU    SC28L92_BASE+$0A        ;UART Command Register Port B (WRITE)
   353             0000FE8B   UART_RECEIVE_B  .EQU    SC28L92_BASE+$0B        ;UART Receive Register Port B (READ)
   354             0000FE8B   UART_TRANSMIT_B .EQU    SC28L92_BASE+$0B        ;UART Transmit Register Port B (WRITE)
   355                        ;
   356             0000FE8C   UART_MISC       .EQU    SC28L92_BASE+$0C        ;UART Miscellaneous Register Intel (READ/WRITE)
   357             0000FE8D   UART_INPUT_PORT .EQU    SC28L92_BASE+$0D        ;UART Input Port Register (READ)
   358             0000FE8D   UART_OUT_CFG    .EQU    SC28L92_BASE+$0D        ;UART Ouput Port Config Register (WRITE)
   359             0000FE8E   UART_START_CNT  .EQU    SC28L92_BASE+$0E        ;UART Start Counter Command (READ)
   360             0000FE8E   UART_SOPR_CMD   .EQU    SC28L92_BASE+$0E        ;UART Set Output Port Bits Register (WRITE)
   361             0000FE8F   UART_STOP_CNT   .EQU    SC28L92_BASE+$0F        ;UART Stop Counter Command (READ)
   362             0000FE8F   UART_ROPR_CMD   .EQU    SC28L92_BASE+$0F        ;UART Reset Output Port Bits Register (WRITE)
   363                        ;
   364                        ;Additional Hardware - DS-1318 RTC
   365                        ; Replacement for DS15x1 RTC
   366                        ; - this RTC uses a simple 32-bit counter implemented as 4 bytes
   367                        ; - this will be setup with EPOCH time as a 32-bit count.
   368                        ; - this greatly simplifies the BIOS routines to support.
   369                        ; - the setup will be done by a separate utility application
   370                        ; - reading the RTC and showing as Day/Month/Year will be done via a loadable application
   371                        ;
   372             0000FE60   RTC_BASE        .EQU    IOPAGE+$60              ;Start of RTC Regsters
   373                        ;
   374             0000FE60   RTC_SUB_SEC_0   .EQU    RTC_BASE+0              ;Sub-Seconds 0
   375             0000FE61   RTC_SUB_SEC_1   .EQU    RTC_BASE+1              ;Sub-Seconds 1
  Sun Mar 30 2025  9:15                                                                                                    Page 8


   376                        ;
   377             0000FE62   RTC_SECONDS_0   .EQU    RTC_BASE+2              ;Clock Seconds 0
   378             0000FE63   RTC_SECONDS_1   .EQU    RTC_BASE+3              ;Clock Seconds 1
   379             0000FE64   RTC_SECONDS_2   .EQU    RTC_BASE+4              ;Clock Seconds 2
   380             0000FE65   RTC_SECONDS_3   .EQU    RTC_BASE+5              ;Clock Seconds 3
   381                        ;
   382             0000FE66   RTC_ALARM_0     .EQU    RTC_BASE+6              ;Alarm Seconds 0
   383             0000FE67   RTC_ALARM_1     .EQU    RTC_BASE+7              ;Alarm Seconds 1
   384             0000FE68   RTC_ALARM_2     .EQU    RTC_BASE+8              ;Alarm Seconds 2
   385             0000FE69   RTC_ALARM_3     .EQU    RTC_BASE+9              ;Alarm Seconds 3
   386                        ;
   387             0000FE6A   RTC_CONTROL_A   .EQU    RTC_BASE+10             ;Control Register A
   388             0000FE6B   RTC_CONTROL_B   .EQU    RTC_BASE+11             ;Control Register B
   389                        ;
   390             0000FE6C   RTC_STATUS      .EQU    RTC_BASE+12             ;Status Register
   391                        ;
   392                        ; Adding BIOS definitions for 16-bit IDE interface
   393                        ; uses two addresses for Upper Byte Latch read / write
   394                        ; uses eight addresses for Command Block Registers
   395                        ; uses two addresses for Control Block Registers
   396                        ;
   397             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;
   398                        ;
   399             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   400             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   401                        ;
   402                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   403                        ; Hardware Adapter provides a 16-bit IDE Port per:
   404                        ;  Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   405                        ;
   406                        ; Control Block Registers
   407             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   408             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   409             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   410                        ;
   411                        ; Command Block Registers
   412             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   413             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   414             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   415             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   416             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   417             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   418             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   419             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   420             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
   421             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   422                        ;
   423                        ;**************************************************************************************************
   424                        ;
   425                                .END
    61                                INCLUDE         C02JMP_Table_5.asm      ;JMP table for Monitor and BIOS
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*                        C02 BIOS/Monitor JMP Table for Version 5.x                              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  06/03/2025 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ;                                                                                                 *
    10                        ; C02BIOS Version 5.0                                                                             *
    11                        ; - All Jump Table entries are defined in this single source file.                                *
    12                        ; - Be sure to include this file at the start of any source file that needs it.                   *
  Sun Mar 30 2025  9:15                                                                                                    Page 9


    13                        ;                                                                                                 *
    14                        ;**************************************************************************************************
    15                        ;                                                                                                 *
    16                        ;Monitor JUMP table: 32 JUMP calls are available.                                                 *
    17                        ;       - Call 02 is currently Reserved                                                           *
    18                        ;                                                                                                 *
    19                        ;**************************************************************************************************
    20                        ;
    21             0000E000   M_COLD_MON      .EQU    $E000           ;Call 00        Monitor Cold Start
    22             0000E003   M_WARM_MON      .EQU    $E003           ;Call 01        Monitor Warm Start
    23                        ;
    24                        ;**************************************************************************************************
    25                        ;                                                                                                 *
    26                        ;BIOS JUMP Table starts here:                                                                     *
    27                        ;       - BIOS calls are listed below - total of 32                                               *
    28                        ;       - Reserved calls are for future hardware support                                          *
    29                        ;                                                                                                 *
    30                        ;**************************************************************************************************
    31                        ;
    32             0000FF00   B_IDE_RESET             .EQU    $FF00   ;Call 00
    33             0000FF03   B_IDE_GET_STAT          .EQU    $FF03   ;Call 01
    34             0000FF06   B_IDE_IDENTIFY          .EQU    $FF06   ;Call 02
    35             0000FF09   B_IDE_READ_LBA          .EQU    $FF09   ;Call 03
    36             0000FF0C   B_IDE_WRITE_LBA         .EQU    $FF0C   ;Call 04
    37             0000FF0F   B_IDE_SET_LBA           .EQU    $FF0F   ;Call 05
    38             0000FF12   B_IDE_SET_ADDR          .EQU    $FF12   ;Call 06
    39             0000FF15   B_IDE_SET_CACHE         .EQU    $FF15   ;Call 07
    40                        ;
    41             0000FF18   B_CHR_STAT              .EQU    $FF18   ;Call 08
    42             0000FF1B   B_CHRIN_NW              .EQU    $FF1B   ;Call 09
    43             0000FF1E   B_CHRIN                 .EQU    $FF1E   ;Call 10
    44             0000FF21   B_CHROUT                .EQU    $FF21   ;Call 11
    45                        ;
    46             0000FF24   B_CHRIN2                .EQU    $FF24   ;Call 12
    47             0000FF27   B_CHROUT2               .EQU    $FF27   ;Call 13
    48                        ;
    49             0000FF2A   B_CNT_INIT              .EQU    $FF2A   ;Call 14
    50             0000FF2D   B_CNT_STRT              .EQU    $FF2D   ;Call 15
    51             0000FF30   B_CNT_STOP              .EQU    $FF30   ;Call 16
    52             0000FF33   B_CNT_DISP              .EQU    $FF33   ;Call 17
    53                        ;
    54             0000FF36   B_SET_DLY               .EQU    $FF36   ;Call 18
    55             0000FF39   B_EXE_MSDLY             .EQU    $FF39   ;Call 19
    56             0000FF3C   B_EXE_LGDLY             .EQU    $FF3C   ;Call 20
    57                        ;
    58             0000FF3F   B_PROMPTR               .EQU    $FF3F   ;Call 21
    59                        ;
    60             0000FF42   B_RTC_INIT              .EQU    $FF42   ;Call 22
    61                        ;
    62             0000FF45   B_PRSTAT                .EQU    $FF45   ;Call 23
    63                        ;
    64             0000FF48   B_RESERVE0              .EQU    $FF48   ;Call 24
    65                        ;
    66             0000FF4B   B_INIT_VEC              .EQU    $FF4B   ;Call 25
    67             0000FF4E   B_INIT_CFG              .EQU    $FF4E   ;Call 26
    68                        ;
    69             0000FF51   B_INIT_28L92            .EQU    $FF51   ;Call 27
    70             0000FF54   B_RESET_28L92           .EQU    $FF54   ;Call 28
    71                        ;
    72             0000FF57   B_PANIC                 .EQU    $FF57   ;Call 29
    73             0000FF5A   B_IDE_BOOT              .EQU    $FF5A   ;Call 30
    74                        ;
    75             0000FF5D   B_COLDSTRT              .EQU    $FF5D   ;Call 31
  Sun Mar 30 2025  9:15                                                                                                    Page 10


    76                        ;
    77             0000FFD0   BIOS_MSG                .EQU    $FFD0   ;BIOS Startup Message is hard-coded here
    78                        ;
    79                        ;**************************************************************************************************
    80                        ;
    81                                .END
    62                        ;
    63                        ;**************************************************************************************************
    64             00000103   PEM             .EQU    $0103   ;PEM Entry
    65                        ;**************************************************************************************************
    66                        ;
    67                        ;       User program code can start here. Default to $0800, can be chaged as required
    68                        ;
    69                        ;**************************************************************************************************
    70                        ;
    71                                .ORG    $0800                           ;Start of User RAM for programs
    72                        ;
    73                        ; First, send an intro message to the console, Utility name and version.
    74                        ; Second, send the User Menu to the console, then enter Command mode.
    75                        ;
    76                        START
    77 00:0800: A9 86                        LDA     #<INTRO_MSG             ;Load Message address
    78 00:0802: A0 10                        LDY     #>INTRO_MSG             ;into A/Y Regs
    79 00:0804: 20 3F FF                     JSR     B_PROMPTR               ;Call Monitor routine
    80                        MENU_LOOP
    81 00:0807: A9 F8                        LDA     #<MENU_MSG              ;Load Menu address
    82 00:0809: A0 10                        LDY     #>MENU_MSG              ;into A/Y Regs
    83 00:080B: 20 3F FF                     JSR     B_PROMPTR               ;Call Monitor routine
    84                        ;
    85                        MAIN_LOOP
    86 00:080E: 20 5E 0F                     JSR     RDCHAR                  ;Wait for keystroke (converts to upper-case)
    87 00:0811: A2 08                        LDX     #MONTAB-MONCMD-1        ;Get command list count
    88 00:0813: DD 2D 08     CMD_LP          CMP     MONCMD,X                ;Compare to command list
    89 00:0816: D0 0D                        BNE     CMD_DEC                 ;Check for next command and loop
    90 00:0818: 48                           PHA                             ;Save keystroke
    91 00:0819: 8A                           TXA                             ;Xfer Command index to A reg
    92 00:081A: 0A                           ASL     A                       ;Multiply keystroke value by 2 (command offset)
    93 00:081B: AA                           TAX                             ;Xfer Command offsett address to table MONTAB
    94 00:081C: 68                           PLA                             ;Restore keystroke (some commands send to terminal)
    95 00:081D: 20 22 08                     JSR     DOCMD                   ;Call Monitor command processor as a subroutine
    96 00:0820: 80 E5                        BRA     MENU_LOOP               ;Command processed, branch/wait for next command
    97 00:0822: 7C 36 08     DOCMD           JMP     (MONTAB,X)              ;Execute command from Table
    98                        ;
    99 00:0825: CA           CMD_DEC         DEX                             ;Decrement index count
   100 00:0826: 10 EB                        BPL     CMD_LP                  ;If more to check, loop back
   101 00:0828: 20 68 0F                     JSR     BEEP                    ;Beep for error, not valid command character
   102 00:082B: 80 E1                        BRA     MAIN_LOOP               ;Branch back and re-enter Monitor
   103                        ;
   104                        ; Command Code List
   105                        ;
   106                        MONCMD
   107 00:082D: 34                   .DB     "4"                             ;Identify MicroDrive and display
   108 00:082E: 35                   .DB     "5"                             ;Read LBA and display
   109 00:082F: 36                   .DB     "6"                             ;Write LBA and verify
   110 00:0830: 37                   .DB     "7"                             ;Sequential Read of all LBA
   111 00:0831: 38                   .DB     "8"                             ;Sequential Write of all LBA
   112 00:0832: 39                   .DB     "9"                             ;Benchmark MicroDrive Read/Write
   113 00:0833: 4D                   .DB     "M"                             ;Menu display
   114 00:0834: 53                   .DB     "S"                             ;System Transfer RAM to Disc
   115 00:0835: 51                   .DB     "Q"                             ;Quit Utility
   116                        MONTAB
   117 00:0836: F0 08                .DW     IDE_IDENTIFY                    ;Address of IDE Identify routine
   118 00:0838: 68 09                .DW     IDE_READ_LBA                    ;Address of IDE Read/Display LBA
  Sun Mar 30 2025  9:15                                                                                                    Page 11


   119 00:083A: F0 09                .DW     IDE_WRITE_LBA                   ;Address of IDE Write/Verify LBA
   120 00:083C: 2D 0A                .DW     IDE_SEQ_READ                    ;Address of Sequential LBA Read
   121 00:083E: 0F 0B                .DW     IDE_SEQ_WRITE                   ;Address of Sequential LBA Write
   122 00:0840: CC 0B                .DW     IDE_BENCHMARK                   ;Address of IDE Benchmark
   123 00:0842: 07 08                .DW     MENU_LOOP                       ;Address of Main Menu
   124 00:0844: 7F 0D                .DW     SYS_XFER                        ;Address of System Transfer
   125 00:0846: B6 0C                .DW     QUIT                            ;Address of Quit Utility
   126                        ;
   127                        ;[D] HEX/TEXT DUMP command:
   128                        ; Display in HEX followed by TEXT, the contents of 256 consecutive memory addresses
   129                        ;
   130                        DUMP
   131 00:0848: 8E 53 1D                     STX     ROWS                    ;Save Row count
   132 00:084B: 64 AA                        STZ     TEMP1L                  ;Clear Offset to data
   133 00:084D: 64 AB                        STZ     TEMP1H                  ;used for showing loaded data from device
   134                        ;
   135 00:084F: 20 82 0F     LINED           JSR     CROUT                   ;
   136 00:0852: 20 A4 08                     JSR     DMPGR                   ;Send address offsets to terminal
   137 00:0855: 20 D4 08                     JSR     GLINE                   ;Send horizontal line to terminal
   138 00:0858: 20 82 0F                     JSR     CROUT                 ;Send CR,LF to terminal
   139 00:085B: AE 53 1D                     LDX     ROWS                    ;Set line count for rows displayed
   140 00:085E: 20 6D 0F     DLINE           JSR     SPC                   ;Send 4 Spaces to terminal
   141 00:0861: 20 6D 0F                     JSR     SPC
   142 00:0864: 20 6D 0F                     JSR     SPC
   143 00:0867: 20 6D 0F                     JSR     SPC
   144 00:086A: 20 DF 08                     JSR     PROFFSET                ;Print INDEX value
   145 00:086D: 20 6D 0F                     JSR     SPC                   ;Send 2 Spaces to terminal
   146 00:0870: 20 6D 0F                     JSR     SPC
   147 00:0873: A0 00                        LDY     #$00                    ;Initialize line byte counter
   148                        GETBYT
   149 00:0875: B2 A8                        LDA     (INDEXL)
   150 00:0877: 99 40 02                     STA     SRCHBUFF,Y              ;Save in Search buffer (16 bytes)
   151 00:087A: 20 4A 10                     JSR     PRBYTE                ;Display byte as a HEX value
   152 00:087D: 20 6D 0F                     JSR     SPC                   ;Send Space to terminal
   153 00:0880: 20 8F 0F                     JSR     INCINDEX              ;Increment Index to next byte location
   154 00:0883: 20 E9 08                     JSR     INCOFFSET               ;Increment Offset address
   155 00:0886: C8                           INY                             ;Increment index
   156 00:0887: C0 10                        CPY     #$10                    ;Check for all 16
   157 00:0889: D0 EA                        BNE     GETBYT                  ;Loop back until 16 bytes have been displayed
   158 00:088B: 20 6D 0F                     JSR     SPC                   ;Send a space
   159 00:088E: A0 00                        LDY     #$00                    ;Reset index for SRCHBUFF
   160 00:0890: B9 40 02     GETBYT2         LDA     SRCHBUFF,Y              ;Get buffered line (16 bytes)
   161 00:0893: 20 3D 10                     JSR     PRASC                 ;Print ASCII character
   162 00:0896: C8                           INY                             ;Increment index to next byte
   163 00:0897: C0 10                        CPY     #$10                    ;Check for 16 bytes
   164 00:0899: D0 F5                        BNE     GETBYT2                 ;Loop back until 16 bytes have been displayed
   165 00:089B: 20 82 0F                     JSR     CROUT                 ;Else, send CR,LF to terminal
   166 00:089E: CA                           DEX                             ;Decrement line count
   167 00:089F: D0 BD                        BNE     DLINE                   ;Branch back until all rows done
   168 00:08A1: 20 D4 08                     JSR     GLINE                   ;Send horizontal line to terminal
   169                        ;
   170                        ;DMPGR subroutine: Send address offsets to terminal
   171                        ;
   172 00:08A4: A9 F9        DMPGR           LDA     #<SYS_ADDR_MSG          ;Get " addr:" msg
   173 00:08A6: A0 1C                        LDY     #>SYS_ADDR_MSG          ;
   174 00:08A8: 20 3F FF                     JSR     B_PROMPTR                ;Send to terminal
   175 00:08AB: 20 6D 0F                     JSR     SPC                   ;Add two additional spaces
   176 00:08AE: 20 6D 0F                     JSR     SPC
   177 00:08B1: A2 00                        LDX     #$00                    ;Zero index count
   178 00:08B3: 8A           MDLOOP          TXA                             ;Send "00" - "0F", separated by 1 Space to terminal
   179 00:08B4: 20 4A 10                     JSR     PRBYTE                ;Print byte value
   180 00:08B7: 20 6D 0F                     JSR     SPC                   ;Add a space
   181 00:08BA: E8                           INX                             ;Increment the count
  Sun Mar 30 2025  9:15                                                                                                    Page 12


   182 00:08BB: E0 10                        CPX     #$10                    ;Check for 16
   183 00:08BD: D0 F4                        BNE     MDLOOP                  ;Loop back until done
   184                        ;
   185                        ;Print the ASCII text header "0123456789ABCDEF"
   186                        ;
   187 00:08BF: 20 6D 0F                     JSR     SPC                   ;Send a space
   188 00:08C2: A2 00                        LDX     #$00                    ;Zero X reg for "0"
   189 00:08C4: 8A           MTLOOP          TXA                             ;Xfer to A reg
   190 00:08C5: 20 28 10                     JSR     BIN2ASC               ;Convert Byte to two ASCII digits
   191 00:08C8: 98                           TYA                             ;Xfer the low nibble character to A reg
   192 00:08C9: 20 21 FF                     JSR     B_CHROUT                ;Send least significant HEX to terminal
   193 00:08CC: E8                           INX                             ;Increment to next HEX character
   194 00:08CD: E0 10                        CPX     #$10                    ;Check for 16
   195 00:08CF: D0 F3                        BNE     MTLOOP                  ;Branch back till done
   196 00:08D1: 4C 82 0F                     JMP     CROUT                 ;Do a CR/LF and return
   197                        ;
   198                        ;GLINE subroutine: Send a horizontal line to console used by memory display only.
   199                        ;
   200 00:08D4: A2 4F        GLINE           LDX     #$4F                    ;Load index for 79 decimal
   201 00:08D6: A9 7E                        LDA     #$7E                    ;Get "~" character
   202 00:08D8: 20 21 FF     GLINEL          JSR     B_CHROUT                ;Send to terminal (draw a line)
   203 00:08DB: CA                           DEX                             ;Decrement count
   204 00:08DC: D0 FA                        BNE     GLINEL                  ;Branch back until done
   205 00:08DE: 60                           RTS                             ;Return to caller
   206                        ;
   207                        ;PRINT Offset subroutine: Prints a $ sign followed by TEMP1L/H
   208                        ;
   209 00:08DF: 20 7D 0F     PROFFSET        JSR     DOLLAR                ;Print a $ sign
   210 00:08E2: A5 AA                        LDA     TEMP1L                  ;Get Index Low byte
   211 00:08E4: A4 AB                        LDY     TEMP1H                  ;Get Index High byte
   212 00:08E6: 4C 60 10                     JMP     PRWORD                ;Print Word, return
   213                        ;
   214                        ;Increment Data offset to display
   215                        ;
   216                        INCOFFSET
   217 00:08E9: E6 AA                        INC     TEMP1L                  ;Increment low byte
   218 00:08EB: D0 02                        BNE     SK_HIOFF                ;If not equal, skip high byte
   219 00:08ED: E6 AB                        INC     TEMP1H                  ;Increment high byte
   220 00:08EF: 60           SK_HIOFF        RTS                             ;Return to caller
   221                        ;
   222                        ; MicroDrive Routines
   223                        ;
   224                        IDE_IDENTIFY
   225                        ; Uses the BIOS call to load drive identity information.
   226                        ; This routine will display the following information from the ID block:
   227                        ;
   228                        ;       Bytes $36 - $5D       Model Number:
   229                        ;       Bytes $14 - $27       Serial Number:
   230                        ;       Bytes $2E - $35       Firmware Revision:
   231                        ;       Bytes $62 - $63       LBA Mode Support:
   232                        ;       Bytes $78 - $7B       Total LBA Count:
   233                        ;
   234                        ; The above data is in Big Endian format or ASCII format
   235                        ;
   236 00:08F0: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   237 00:08F3: 20 59 0D                     JSR     SWAP_BYTE               ;Swap High/Low Bytes
   238                        ;
   239 00:08F6: A9 C8                        LDA     #<DRIVE_IDENTITY        ;Get low order offset
   240 00:08F8: A0 15                        LDY     #>DRIVE_IDENTITY        ;Get high order offset
   241 00:08FA: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   242                        ;
   243                        ;ID Block now loaded into buffer
   244                        ; Next, print the description message, then print the offset to the ID block
  Sun Mar 30 2025  9:15                                                                                                    Page 13


   245                        ; for ASCII text, but will need to do some transforms for Mode Support and
   246                        ; LBA block count.
   247                        ;
   248 00:08FD: A9 E6                        LDA     #<MODEL_NUM             ;Get low order offset
   249 00:08FF: A0 15                        LDY     #>MODEL_NUM             ;Get high order offset
   250 00:0901: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   251                        ;
   252 00:0904: A9 36                        LDA     #<LBA_BUFFER+$36        ;Get low order offset
   253 00:0906: A0 06                        LDY     #>LBA_BUFFER+$36        ;Get high order offset
   254 00:0908: A2 28                        LDX     #40                     ;Byte count to display
   255 00:090A: 20 E4 0C                     JSR     STRING_OUT              ;Use string out routine
   256                        ;
   257 00:090D: A9 F8                        LDA     #<SERIAL_NUM            ;Get low order offset
   258 00:090F: A0 15                        LDY     #>SERIAL_NUM            ;Get high order offset
   259 00:0911: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   260                        ;
   261 00:0914: A9 14                        LDA     #<LBA_BUFFER+$14        ;Get low order offset
   262 00:0916: A0 06                        LDY     #>LBA_BUFFER+$14        ;Get high order offset
   263 00:0918: A2 14                        LDX     #20                     ;Byte count to display
   264 00:091A: 20 E4 0C                     JSR     STRING_OUT              ;Use string out routine
   265                        ;
   266 00:091D: A9 0B                        LDA     #<FIRM_REV              ;Get low order offset
   267 00:091F: A0 16                        LDY     #>FIRM_REV              ;Get high order offset
   268 00:0921: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   269                        ;
   270 00:0924: A9 2E                        LDA     #<LBA_BUFFER+$2E        ;Get low order offset
   271 00:0926: A0 06                        LDY     #>LBA_BUFFER+$2E        ;Get high order offset
   272 00:0928: A2 08                        LDX     #8                      ;Byte count to display
   273 00:092A: 20 E4 0C                     JSR     STRING_OUT              ;Use string out routine
   274                        ;
   275 00:092D: A9 22                        LDA     #<MODE_SUPPORT          ;Get low order offset
   276 00:092F: A0 16                        LDY     #>MODE_SUPPORT          ;Get high order offset
   277 00:0931: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   278                        ;
   279 00:0934: AD 62 06                     LDA     LBA_BUFFER+$62          ;Get Capabilities data (bit 9 of Word 49)
   280 00:0937: 4A                           LSR     A                       ;Shift DMA bit to Carry (dont't care)
   281 00:0938: 4A                           LSR     A                       ;Shift LBA bit to Carry (do care)
   282 00:0939: B0 04                        BCS     LBA_MODE_Y              ;If active, finish setup
   283                        ;
   284 00:093B: A9 4E                        LDA     #$4E                    ;Get "N"
   285 00:093D: 80 02                        BRA     LBA_MODE_N              ;Finish sending to console
   286                        LBA_MODE_Y
   287 00:093F: A9 59                        LDA     #$59                    ;Get "Y"
   288                        LBA_MODE_N
   289 00:0941: 20 21 FF                     JSR     B_CHROUT                ;Send to console
   290                        ;
   291 00:0944: A9 3A                        LDA     #<TOTAL_LBA             ;Get low order offset
   292 00:0946: A0 16                        LDY     #>TOTAL_LBA             ;Get high order offset
   293 00:0948: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   294                        ;
   295 00:094B: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   296 00:094E: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   297 00:0950: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   298 00:0953: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   299 00:0955: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   300 00:0958: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   301 00:095A: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   302 00:095D: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   303                        ;
   304 00:095F: 20 EA 0D                     JSR     HEXTOBCD                ;Convert 32-bit Hex to ASCII BCD
   305 00:0962: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   306 00:0965: 4C CE 0C     NO_NEXT_LBA     JMP     USER_INPUT              ;Prompt user for next command
   307                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 14


   308                        IDE_READ_LBA
   309                        ; This routine will read a User requested LBA and display as Hex/ASCII
   310                        ; - The "N" key will show the next in sequence
   311                        ; - Hitting Return will end the LBA Read/Display sequence
   312                        ;
   313 00:0968: 9C 54 1D                     STZ     LBA_LOW_WORD            ;Zero out LBA count
   314 00:096B: 9C 55 1D                     STZ     LBA_LOW_WORD+1
   315 00:096E: 9C 56 1D                     STZ     LBA_HIGH_WORD
   316 00:0971: 9C 57 1D                     STZ     LBA_HIGH_WORD+1
   317                        ;
   318 00:0974: A9 4F                        LDA     #<LBA_INPUT             ;Get LBA Input message
   319 00:0976: A0 16                        LDY     #>LBA_INPUT
   320 00:0978: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   321 00:097B: 20 D8 0C                     JSR     GET_LBA_NUM             ;Get LBA number to read
   322                        ;
   323 00:097E: 8D 54 1D                     STA     LBA_LOW_WORD            ;Save Current LBA number
   324 00:0981: 8C 55 1D                     STY     LBA_LOW_WORD+1          ;to local variables
   325 00:0984: 8E 56 1D                     STX     LBA_HIGH_WORD
   326                        ;
   327                        READ_NEXT_LBA
   328 00:0987: 20 82 0F                     JSR     CROUT                   ;Send CR/LF to console
   329 00:098A: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   330 00:098C: A0 06                        LDY     #>LBA_BUFFER            ; address
   331 00:098E: A2 01                        LDX     #$01                    ;LBA count = 1
   332 00:0990: 85 A8                        STA     INDEXL                  ;Save Index L
   333 00:0992: 84 A9                        STY     INDEXH                  ;Save Index H
   334 00:0994: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   335                        ;
   336 00:0997: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Read LBA into Buffer
   337 00:099A: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   338 00:099C: 4A                           LSR     A                       ;Shift error bit into carry
   339 00:099D: B0 4E                        BCS     IDE_RW_ERR              ;If carry set, handle read error
   340                        ;
   341 00:099F: A2 20                        LDX     #$20                    ;Set display range for 32 rows
   342 00:09A1: 20 48 08                     JSR     DUMP                    ;Display data to console
   343                        ;
   344                        ; Prompt user: either display the next LBA or not.
   345                        ;
   346 00:09A4: A9 12                        LDA     #<NEXT_LBA              ;Get LBA Output message
   347 00:09A6: A0 17                        LDY     #>NEXT_LBA
   348 00:09A8: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   349                        ;
   350                        LBA_TRY_AGAIN
   351 00:09AB: 20 5E 0F                     JSR     RDCHAR                  ;Get input from console
   352 00:09AE: C9 0D                        CMP     #$0D                    ;Check for C/R
   353 00:09B0: F0 B3                        BEQ     NO_NEXT_LBA             ;If yes, exit
   354 00:09B2: C9 4E                        CMP     #"N"                    ;Check for "N" for next
   355 00:09B4: D0 32                        BNE     BAD_ENTRY               ;Bad entry, branch
   356                        ;
   357                        ; Need to increase the current LBA number, then loop back and re-display
   358                        ;
   359 00:09B6: 20 D8 0A                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to read
   360                        ;
   361 00:09B9: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get variables
   362 00:09BC: AC 55 1D                     LDY     LBA_LOW_WORD+1
   363 00:09BF: AE 56 1D                     LDX     LBA_HIGH_WORD
   364 00:09C2: 20 0F FF                     JSR     B_IDE_SET_LBA           ;Set LBA to read
   365                        ;
   366 00:09C5: AD 55 1D                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
   367 00:09C8: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   368 00:09CA: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get LBA count data
   369 00:09CD: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   370 00:09CF: AD 57 1D                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
  Sun Mar 30 2025  9:15                                                                                                    Page 15


   371 00:09D2: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   372 00:09D4: AD 56 1D                     LDA     LBA_HIGH_WORD           ;Get LBA count data
   373 00:09D7: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   374                        ;
   375 00:09D9: 20 EA 0D                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
   376 00:09DC: A9 35                        LDA     #<SHOW_NEXT_LBA         ;Get LBA Output message
   377 00:09DE: A0 17                        LDY     #>SHOW_NEXT_LBA
   378 00:09E0: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   379                        ;
   380 00:09E3: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   381 00:09E6: 80 9F                        BRA     READ_NEXT_LBA           ;Branch back to show next LBA
   382                        ;
   383                        BAD_ENTRY
   384 00:09E8: 20 68 0F                     JSR     BEEP                  ;Send error beep
   385 00:09EB: 80 BE                        BRA     LBA_TRY_AGAIN           ;Branch and try again
   386                        ;
   387                        IDE_RW_ERR
   388 00:09ED: 4C F8 0C                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler
   389                        ;
   390                        IDE_WRITE_LBA
   391                        ; This routine will write a User requested LBA from the LBA_BUFFER
   392                        ; - The Buffer data will be displayed first and then prompted for writing
   393                        ;
   394 00:09F0: A9 72                        LDA     #<LBA_OUTPUT            ;Get LBA Output message
   395 00:09F2: A0 16                        LDY     #>LBA_OUTPUT
   396 00:09F4: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   397 00:09F7: 20 D8 0C                     JSR     GET_LBA_NUM             ;Get LBA number to write
   398 00:09FA: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   399 00:09FC: A0 06                        LDY     #>LBA_BUFFER            ; address
   400 00:09FE: A2 01                        LDX     #$01                    ;LBA count = 1
   401 00:0A00: 85 A8                        STA     INDEXL                  ;Save Index L
   402 00:0A02: 84 A9                        STY     INDEXH                  ;Save Index H
   403 00:0A04: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   404                        ;
   405 00:0A07: A9 B3                        LDA     #<LBA_WR_DATA           ;Get LBA Write message
   406 00:0A09: A0 16                        LDY     #>LBA_WR_DATA
   407 00:0A0B: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   408                        ;
   409 00:0A0E: A2 20                        LDX     #$20                    ;Set display range for 32 rows
   410 00:0A10: 20 48 08                     JSR     DUMP                    ;Display data to console
   411                        ;
   412 00:0A13: A9 E3                        LDA     #<LBA_WR_CNFM           ;Get LBA Confirm Write message
   413 00:0A15: A0 16                        LDY     #>LBA_WR_CNFM
   414 00:0A17: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   415                        ;
   416 00:0A1A: 20 6A 10                     JSR     CONTINUE              ;Prompt to confirm LBA write
   417                        ;
   418 00:0A1D: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write LBA from Buffer
   419 00:0A20: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   420 00:0A22: 4A                           LSR     A                       ;Shift error bit into carry
   421 00:0A23: B0 C8                        BCS     IDE_RW_ERR              ;If carry set, handle write error
   422                        ;
   423                        ;                JSR     B_IDE_VERFY_LBA         ;Verify LBA
   424 00:0A25: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   425 00:0A27: 4A                           LSR     A                       ;Shift error bit into carry
   426 00:0A28: B0 C3                        BCS     IDE_RW_ERR              ;If carry set, handle write error
   427                        ;
   428 00:0A2A: 4C CE 0C                     JMP     USER_INPUT              ;Get user input
   429                        ;
   430                        IDE_SEQ_READ
   431                        ; This routine will read the entire disk data one block at a time,
   432                        ; - This can take a long time as the current LBA count is displayed.
   433                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 16


   434 00:0A2D: A9 53                        LDA     #<LBA_SEQ_RD_MSG        ;Get Seq Read Message address
   435 00:0A2F: A0 17                        LDY     #>LBA_SEQ_RD_MSG
   436 00:0A31: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   437                        ;
   438 00:0A34: A9 AE                        LDA     #<LBA_SEQ_TM_MSG        ;Get Time Message address
   439 00:0A36: A0 17                        LDY     #>LBA_SEQ_TM_MSG
   440 00:0A38: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   441                        ;
   442 00:0A3B: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   443 00:0A3E: 20 59 0D                     JSR     SWAP_BYTE               ;Swap high/low bytes
   444                        ;
   445 00:0A41: A9 3A                        LDA     #<TOTAL_LBA             ;Get low order offset
   446 00:0A43: A0 16                        LDY     #>TOTAL_LBA             ;Get high order offset
   447 00:0A45: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   448                        ;
   449 00:0A48: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   450 00:0A4B: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   451 00:0A4D: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   452 00:0A50: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   453 00:0A52: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   454 00:0A55: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   455 00:0A57: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   456 00:0A5A: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   457                        ;
   458 00:0A5C: 20 EA 0D                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
   459 00:0A5F: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   460                        ;
   461 00:0A62: A9 DA                        LDA     #<LBA_SEQ_CFM           ;Get Message address
   462 00:0A64: A0 17                        LDY     #>LBA_SEQ_CFM
   463 00:0A66: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   464                        ;
   465 00:0A69: 20 6A 10                     JSR     CONTINUE              ;Prompt user to continue
   466 00:0A6C: 20 82 0F                     JSR     CROUT                 ;Send CR/LF
   467                        ;
   468 00:0A6F: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   469 00:0A71: A0 1E                        LDY     #>BENCH_BUFFER          ; address
   470 00:0A73: A2 01                        LDX     #$01                    ;LBA count = 1
   471 00:0A75: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   472                        ;
   473 00:0A78: 9C 54 1D                     STZ     LBA_LOW_WORD            ;Zero out LBA count
   474 00:0A7B: 9C 55 1D                     STZ     LBA_LOW_WORD+1
   475 00:0A7E: 9C 56 1D                     STZ     LBA_HIGH_WORD
   476 00:0A81: 9C 57 1D                     STZ     LBA_HIGH_WORD+1
   477                        ;
   478 00:0A84: A9 19                        LDA     #<LBA_BLKS_RD           ;Get Blocks read msg
   479 00:0A86: A0 18                        LDY     #>LBA_BLKS_RD
   480 00:0A88: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   481                        ;
   482                        SEQ_LBA_READ
   483 00:0A8B: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get variables
   484 00:0A8E: AC 55 1D                     LDY     LBA_LOW_WORD+1
   485 00:0A91: AE 56 1D                     LDX     LBA_HIGH_WORD
   486 00:0A94: 20 0F FF                     JSR     B_IDE_SET_LBA           ;Set LBA to read
   487                        ;
   488 00:0A97: A9 0D                        LDA     #$0D                    ;Get C/R
   489 00:0A99: 20 21 FF                     JSR     B_CHROUT                ;Send to console
   490                        ;
   491 00:0A9C: AD 55 1D                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
   492 00:0A9F: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   493 00:0AA1: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get LBA count data
   494 00:0AA4: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   495 00:0AA6: AD 57 1D                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
   496 00:0AA9: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
  Sun Mar 30 2025  9:15                                                                                                    Page 17


   497 00:0AAB: AD 56 1D                     LDA     LBA_HIGH_WORD           ;Get LBA count data
   498 00:0AAE: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   499                        ;
   500 00:0AB0: 20 EA 0D                     JSR     HEXTOBCD                ;Convert and print to ASCII BCD
   501 00:0AB3: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   502                        ;
   503 00:0AB6: A5 DC        OC_LOOP         LDA     OCNT_A                  ;Check output buffer count
   504 00:0AB8: D0 FC                        BNE     OC_LOOP                 ;Loop back until buffer sent
   505                        ;
   506 00:0ABA: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Read selected LBA from IDE
   507 00:0ABD: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   508 00:0ABF: C9 51                        CMP     #$51                    ;Check for error
   509 00:0AC1: D0 03                        BNE     NO_RD_ERR               ;Branch if no error
   510                        ;
   511 00:0AC3: 4C F8 0C                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler
   512                        ;
   513                        NO_RD_ERR
   514 00:0AC6: 20 D8 0A                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to read
   515                        ;
   516 00:0AC9: 20 EB 0A                     JSR     LBA_LIMIT_CHK           ;Check LBA limit
   517 00:0ACC: 90 BD                        BCC     SEQ_LBA_READ            ;Loop back to continue (Carry clear)
   518                        ;
   519 00:0ACE: A9 3E                        LDA     #<LBA_BLKS_RD_CMP       ;Get Blocks read msg
   520 00:0AD0: A0 18                        LDY     #>LBA_BLKS_RD_CMP
   521 00:0AD2: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   522 00:0AD5: 4C CE 0C                     JMP     USER_INPUT              ;Prompt User
   523                        ;
   524                        LBA_BLK_UPDATE
   525                        ; This routine updates the LBA block number being read or written
   526                        ; - This routine is only used for the full read or write
   527                        ;
   528 00:0AD8: EE 54 1D                     INC     LBA_LOW_WORD            ;Increment 32-bit word
   529 00:0ADB: D0 0D                        BNE     SKIP_BLK_UPDATE
   530 00:0ADD: EE 55 1D                     INC     LBA_LOW_WORD+1
   531 00:0AE0: D0 08                        BNE     SKIP_BLK_UPDATE
   532 00:0AE2: EE 56 1D                     INC     LBA_HIGH_WORD
   533 00:0AE5: D0 03                        BNE     SKIP_BLK_UPDATE
   534 00:0AE7: EE 57 1D                     INC     LBA_HIGH_WORD+1
   535 00:0AEA: 60           SKIP_BLK_UPDATE RTS                             ;Return to caller
   536                        ;
   537                        LBA_LIMIT_CHK
   538 00:0AEB: AD 57 1D                     LDA     LBA_HIGH_WORD+1         ;Get high order word
   539 00:0AEE: CD 3F 03                     CMP     $033F                   ;Compare to Limit
   540 00:0AF1: D0 1A                        BNE     LIMIT_GOOD              ;If not, exit
   541 00:0AF3: AD 56 1D                     LDA     LBA_HIGH_WORD           ;Get high order word
   542 00:0AF6: CD 3E 03                     CMP     $033E                   ;Compare to limit
   543 00:0AF9: D0 12                        BNE     LIMIT_GOOD              ;If not, exit
   544 00:0AFB: AD 55 1D                     LDA     LBA_LOW_WORD+1          ;Get low order word
   545 00:0AFE: CD 3D 03                     CMP     $033D                   ;Compare to limit
   546 00:0B01: D0 0A                        BNE     LIMIT_GOOD              ;If not, exit
   547 00:0B03: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get low order word
   548 00:0B06: CD 3C 03                     CMP     $033C                   ;Compare to limit
   549 00:0B09: D0 02                        BNE     LIMIT_GOOD
   550 00:0B0B: 38                           SEC                             ;Set carry for limit reached
   551 00:0B0C: 60                           RTS
   552 00:0B0D: 18           LIMIT_GOOD      CLC                             ;Clear carry for limit good
   553 00:0B0E: 60                           RTS                             ;Return to caller
   554                        ;
   555                        IDE_SEQ_WRITE
   556                        ; This routine will write the entire data on the drive!!
   557                        ; - A 16-bit data pattern is requested from user.
   558                        ; - This routine can take a long time as the current LBA count is displayed!!
   559                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 18


   560 00:0B0F: A9 81                        LDA     #<LBA_SEQ_WR_MSG        ;Get Seq Write Message address
   561 00:0B11: A0 17                        LDY     #>LBA_SEQ_WR_MSG
   562 00:0B13: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   563                        ;
   564 00:0B16: A9 AE                        LDA     #<LBA_SEQ_TM_MSG        ;Get time address
   565 00:0B18: A0 17                        LDY     #>LBA_SEQ_TM_MSG
   566 00:0B1A: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   567                        ;
   568 00:0B1D: 20 06 FF                     JSR     B_IDE_IDENTIFY          ;Call BIOS routine
   569 00:0B20: 20 59 0D                     JSR     SWAP_BYTE               ;Swap high/low bytes
   570                        ;
   571 00:0B23: A9 3A                        LDA     #<TOTAL_LBA             ;Get low order offset
   572 00:0B25: A0 16                        LDY     #>TOTAL_LBA             ;Get high order offset
   573 00:0B27: 20 3F FF                     JSR     B_PROMPTR               ;Send message to console
   574                        ;
   575 00:0B2A: AD 78 06                     LDA     LBA_BUFFER+$78          ;Get LBA count data
   576 00:0B2D: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   577 00:0B2F: AD 79 06                     LDA     LBA_BUFFER+$79          ;Get LBA count data
   578 00:0B32: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   579 00:0B34: AD 7A 06                     LDA     LBA_BUFFER+$7A          ;Get LBA count data
   580 00:0B37: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   581 00:0B39: AD 7B 06                     LDA     LBA_BUFFER+$7B          ;Get LBA count data
   582 00:0B3C: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   583                        ;
   584 00:0B3E: 20 EA 0D                     JSR     HEXTOBCD                ;Convert Hex to ASCII BCD
   585 00:0B41: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   586                        ;
   587 00:0B44: A9 DA                        LDA     #<LBA_SEQ_CFM           ;Get 1st Message address
   588 00:0B46: A0 17                        LDY     #>LBA_SEQ_CFM
   589 00:0B48: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   590                        ;
   591 00:0B4B: 20 6A 10                     JSR     CONTINUE              ;Prompt user to continue
   592 00:0B4E: 20 82 0F                     JSR     CROUT                 ;Send CR/LF
   593                        ;
   594 00:0B51: A9 F6                        LDA     #<LBA_SEQ_CFM2          ;Get 2nd Message address
   595 00:0B53: A0 17                        LDY     #>LBA_SEQ_CFM2
   596 00:0B55: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   597                        ;
   598 00:0B58: 20 6A 10                     JSR     CONTINUE              ;Prompt user to continue
   599 00:0B5B: 20 82 0F                     JSR     CROUT                 ;Send CR/LF
   600                        ;
   601 00:0B5E: 20 25 0D                     JSR     GET_PATTERN             ;Prompt for two-byte Hex pattern
   602                        ;
   603                        ;                LDA     #$AA                    ;Get Fill Pattern default
   604                        ;                LDY     #$55                    ; of $AA55
   605                        ;                STA     INDEXL                  ;Save to Index pointer
   606                        ;                STY     INDEXH                  ; High/Low
   607                        ;
   608 00:0B61: 20 32 0D                     JSR     FILL_PATTERN            ;Fill buffer with pattern
   609                        ;
   610 00:0B64: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   611 00:0B66: A0 1E                        LDY     #>BENCH_BUFFER          ; address
   612 00:0B68: A2 01                        LDX     #$01                    ;LBA count = 1
   613 00:0B6A: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   614                        ;
   615 00:0B6D: 9C 54 1D                     STZ     LBA_LOW_WORD            ;Zero out LBA count
   616 00:0B70: 9C 55 1D                     STZ     LBA_LOW_WORD+1
   617 00:0B73: 9C 56 1D                     STZ     LBA_HIGH_WORD
   618 00:0B76: 9C 57 1D                     STZ     LBA_HIGH_WORD+1
   619                        ;
   620 00:0B79: A9 2A                        LDA     #<LBA_BLKS_WR           ;Get Blocks written msg
   621 00:0B7B: A0 18                        LDY     #>LBA_BLKS_WR
   622 00:0B7D: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
  Sun Mar 30 2025  9:15                                                                                                    Page 19


   623                        ;
   624                        SEQ_LBA_WRITE
   625 00:0B80: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get variables
   626 00:0B83: AC 55 1D                     LDY     LBA_LOW_WORD+1
   627 00:0B86: AE 56 1D                     LDX     LBA_HIGH_WORD
   628 00:0B89: 20 0F FF                     JSR     B_IDE_SET_LBA           ;Set LBA to write
   629                        ;
   630 00:0B8C: A9 0D                        LDA     #$0D                    ;Get C/R
   631 00:0B8E: 20 21 FF                     JSR     B_CHROUT                ;Send to console
   632                        ;
   633 00:0B91: AD 55 1D                     LDA     LBA_LOW_WORD+1          ;Get LBA count data
   634 00:0B94: 85 13                        STA     HEX4AND5                ;Store in Page Zero work area
   635 00:0B96: AD 54 1D                     LDA     LBA_LOW_WORD            ;Get LBA count data
   636 00:0B99: 85 14                        STA     HEX6AND7                ;Store in Page Zero work area
   637 00:0B9B: AD 57 1D                     LDA     LBA_HIGH_WORD+1         ;Get LBA count data
   638 00:0B9E: 85 11                        STA     HEX0AND1                ;Store in Page Zero work area
   639 00:0BA0: AD 56 1D                     LDA     LBA_HIGH_WORD           ;Get LBA count data
   640 00:0BA3: 85 12                        STA     HEX2AND3                ;Store in Page Zero work area
   641                        ;
   642 00:0BA5: 20 EA 0D                     JSR     HEXTOBCD                ;Convert Hex to ASCII BCD
   643 00:0BA8: 20 4D 0E                     JSR     BCDOUT                  ;Print BCD count to console
   644                        
   645 00:0BAB: A5 DC        OC_LOOP2        LDA     OCNT_A                  ;Check output buffer count
   646 00:0BAD: D0 FC                        BNE     OC_LOOP2                ;Loop back until buffer sent
   647                        ;
   648 00:0BAF: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write selected LBA from buffer
   649 00:0BB2: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   650 00:0BB4: C9 51                        CMP     #$51                    ;Check for error
   651 00:0BB6: D0 02                        BNE     NO_WR_ERR               ;Branch if no error
   652                        ;
   653 00:0BB8: 80 7D                        BRA     RD_WR_ERR               ;Branch to handle error
   654                        ;
   655                        NO_WR_ERR
   656 00:0BBA: 20 D8 0A                     JSR     LBA_BLK_UPDATE          ;Update LBA Block to write
   657                        ;
   658 00:0BBD: 20 EB 0A                     JSR     LBA_LIMIT_CHK           ;Check LBA limit
   659 00:0BC0: 90 BE                        BCC     SEQ_LBA_WRITE           ;Loop back to continue (Carry clear)
   660                        ;
   661 00:0BC2: A9 69                        LDA     #<LBA_BLKS_WR_CMP       ;Get Blocks written msg
   662 00:0BC4: A0 18                        LDY     #>LBA_BLKS_WR_CMP
   663 00:0BC6: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   664 00:0BC9: 4C CE 0C                     JMP     USER_INPUT              ;Prompt User
   665                        ;
   666                        IDE_BENCHMARK
   667                        ;
   668                        ; The Benchmark will read or write a 16MB contiguous block of data.
   669                        ;  The starting LBA is entered by the user.
   670                        ;
   671                        ; - The Benchmark timer in the C02 BIOS/Monitor is used to time the data transfer and shows
   672                        ; - the number of seconds and hundredths of a second that it takes to complete the transfer.
   673                        ; -  Note that the benchmark routines use a multiple block transfer of 32 blocks (16KB).
   674                        ;
   675                        ; The User is prompted for the Write function, as this overwrites a 16MB block of data on the
   676                        ; - IDE device, which results in a loss of data. When executing the Write benchmark, the
   677                        ; - LBA Buffer will be filled with a "55AA" pattern for a 512-byte block.
   678                        ;
   679                        ; Error checking is done after each LBA Read or Write function and any error will be
   680                        ; - displayed and the test aborted after that.
   681                        ;
   682 00:0BCC: A9 CA                        LDA     #<LBA_BENCH_INTRO       ;Get LBA Bench Intro Msg
   683 00:0BCE: A0 18                        LDY     #>LBA_BENCH_INTRO
   684 00:0BD0: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   685                        BENCH_IN_LP
  Sun Mar 30 2025  9:15                                                                                                    Page 20


   686 00:0BD3: 20 5E 0F                     JSR     RDCHAR                  ;Get character from user
   687 00:0BD6: 20 21 FF                     JSR     B_CHROUT                ;Send to console
   688 00:0BD9: C9 52                        CMP     #"R"                    ;Test for Read
   689 00:0BDB: F0 09                        BEQ     IDE_BENCH_READ          ;If yes, go set RTC
   690 00:0BDD: C9 57                        CMP     #"W"                    ;Test for Write
   691 00:0BDF: F0 59                        BEQ     IDE_BENCH_WRITE         ;If no, skip RTC set
   692 00:0BE1: 20 68 0F                     JSR     BEEP                    ;Else, error, send beep
   693 00:0BE4: 80 ED                        BRA     BENCH_IN_LP             ;Branch back and try again
   694                        ;
   695                        IDE_BENCH_READ
   696                        ;
   697                        ; Simple test program to transfer multiple sectors - READ
   698                        ;
   699 00:0BE6: A9 94                        LDA     #<LBA_START             ;Get LBA starting # Msg
   700 00:0BE8: A0 16                        LDY     #>LBA_START
   701 00:0BEA: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   702                        ;
   703 00:0BED: 20 D8 0C                     JSR     GET_LBA_NUM             ;Get starting LBA # from user
   704                        ;
   705 00:0BF0: A9 30                        LDA     #<LBA_RD_BENCH          ;Get LBA Read Bench Msg
   706 00:0BF2: A0 1A                        LDY     #>LBA_RD_BENCH
   707 00:0BF4: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   708                        ;
   709 00:0BF7: A5 DC        OC_LOOP3        LDA     OCNT_A                  ;Check output buffer count
   710 00:0BF9: D0 FC                        BNE     OC_LOOP3                ;Loop back until buffer sent
   711                        ;
   712 00:0BFB: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   713 00:0BFD: A0 1E                        LDY     #>BENCH_BUFFER          ; address
   714 00:0BFF: A2 20                        LDX     #$20                    ;Sector count of 32 (16KB)
   715 00:0C01: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS routine to set it
   716                        ;
   717                        ; Setup 1024 transfers at 32 blocks per transfer = 16MB
   718                        ;
   719 00:0C04: A2 00                        LDX     #$00                    ;Set for 256 blocks (128KB)
   720 00:0C06: A0 04                        LDY     #$04                    ;Set multiplier of 4 (* 256)
   721 00:0C08: 20 2A FF                     JSR     B_CNT_INIT              ;Reset Benchmark Counter
   722 00:0C0B: 20 2D FF                     JSR     B_CNT_STRT              ;Start Benchmark Counter
   723                        ;
   724                        LBA_RBLK
   725 00:0C0E: 20 09 FF                     JSR     B_IDE_READ_LBA          ;Call BIOS Read Block
   726 00:0C11: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status (RAM)
   727 00:0C13: 4A                           LSR     A                       ;Shift error bit into carry
   728 00:0C14: B0 21                        BCS     RD_WR_ERR               ;Branch if error
   729                        ;
   730 00:0C16: A5 F5                        LDA     LBA_LOW_BYTE            ;Get LBA low byte (Carry is clear)
   731 00:0C18: 65 F4                        ADC     LBA_XFER_CNT            ;Add 32 decimal
   732 00:0C1A: 85 F5                        STA     LBA_LOW_BYTE            ;Save it back
   733                        ;
   734 00:0C1C: A5 F6                        LDA     LBA_HIGH_BYTE           ;Get LBA high byte
   735 00:0C1E: 69 00                        ADC     #$00                    ;Add carry
   736 00:0C20: 85 F6                        STA     LBA_HIGH_BYTE           ;Save it back
   737                        ;
   738 00:0C22: A5 F7                        LDA     LBA_EXT_BYTE            ;Get LBA ext byte
   739 00:0C24: 69 00                        ADC     #$00                    ;Add carry
   740 00:0C26: 85 F7                        STA     LBA_EXT_BYTE            ;Save it back
   741                        ;
   742 00:0C28: CA                           DEX                             ;Decrement low index
   743 00:0C29: D0 E3                        BNE     LBA_RBLK                ;Loop back until zero
   744 00:0C2B: 88                           DEY                             ;Decrement multiplier index
   745 00:0C2C: D0 E0                        BNE     LBA_RBLK                ;Loop back until done
   746 00:0C2E: 20 30 FF                     JSR     B_CNT_STOP              ;Stop benchmark counter
   747 00:0C31: 20 33 FF                     JSR     B_CNT_DISP              ;Print Benchmark counter
   748 00:0C34: 4C CE 0C                     JMP     USER_INPUT              ;Prompt User
  Sun Mar 30 2025  9:15                                                                                                    Page 21


   749                        ;
   750                        RD_WR_ERR
   751 00:0C37: 4C F8 0C                     JMP     IDE_ERROR_HANDLER       ;Jump to error handler, then return
   752                        ;
   753                        IDE_BENCH_WRITE
   754                        ;
   755                        ; Simple test program to transfer multiple sectors - WRITE
   756                        ;
   757 00:0C3A: 20 25 0D                     JSR     GET_PATTERN             ;Prompt for two-byte Hex pattern
   758 00:0C3D: 20 32 0D                     JSR     FILL_PATTERN            ;Fill 16KB buffer with pattern
   759                        ;
   760 00:0C40: A9 94                        LDA     #<LBA_START             ;Get LBA starting # Msg
   761 00:0C42: A0 16                        LDY     #>LBA_START
   762 00:0C44: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   763                        ;
   764 00:0C47: 20 D8 0C                     JSR     GET_LBA_NUM             ;Get starting LBA # from user
   765                        ;
   766 00:0C4A: A9 74                        LDA     #<LBA_BENCH_WARN        ;Get LBA Write Bench msg
   767 00:0C4C: A0 1A                        LDY     #>LBA_BENCH_WARN
   768 00:0C4E: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   769                        BENCH_WARN_LP
   770 00:0C51: 20 5E 0F                     JSR     RDCHAR                  ;Get character from user
   771 00:0C54: 20 21 FF                     JSR     B_CHROUT                ;Send to console
   772 00:0C57: C9 59                        CMP     #"Y"                    ;Test for yes
   773 00:0C59: F0 09                        BEQ     BENCH_WRITE_Y           ;If yes, do write benchmark
   774 00:0C5B: C9 4E                        CMP     #"N"                    ;Test for no
   775 00:0C5D: F0 4D                        BEQ     BENCH_WRITE_N           ;If no, skip write benchmark
   776 00:0C5F: 20 68 0F                     JSR     BEEP                    ;Else, error, send beep
   777 00:0C62: 80 ED                        BRA     BENCH_WARN_LP           ;Branch back and try again
   778                        BENCH_WRITE_Y
   779 00:0C64: A9 52                        LDA     #<LBA_WR_BENCH          ;Get LBA Write Bench msg
   780 00:0C66: A0 1A                        LDY     #>LBA_WR_BENCH
   781 00:0C68: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   782                        ;
   783 00:0C6B: A5 DC        OC_LOOP4        LDA     OCNT_A                  ;Check output buffer count
   784 00:0C6D: D0 FC                        BNE     OC_LOOP4                ;Loop back until buffer sent
   785                        ;
   786 00:0C6F: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   787 00:0C71: A0 1E                        LDY     #>BENCH_BUFFER          ; address
   788 00:0C73: A2 20                        LDX     #$20                    ;Sector count of 32
   789 00:0C75: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS routine to set it
   790                        ;
   791                        ; Setup 1024 transfers at 32 blocks per transfer = 16MB
   792                        ;
   793 00:0C78: A2 00                        LDX     #$00                    ;Set for 256 blocks (128KB)
   794 00:0C7A: A0 04                        LDY     #$04                    ;Set multiplier of 4 (* 256)
   795 00:0C7C: 20 2A FF                     JSR     B_CNT_INIT              ;Reset Benchmark Counter
   796 00:0C7F: 20 2D FF                     JSR     B_CNT_STRT              ;Start Benchmark Counter
   797                        LBA_WBLK
   798 00:0C82: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Write Block
   799 00:0C85: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status
   800 00:0C87: 4A                           LSR     A                       ;Shift error bit into carry
   801 00:0C88: B0 AD                        BCS     RD_WR_ERR               ;Branch if error
   802                        ;
   803 00:0C8A: 18                           CLC                             ;Clear Carry for add
   804 00:0C8B: A5 F5                        LDA     LBA_LOW_BYTE            ;Get LBA low byte
   805 00:0C8D: 65 F4                        ADC     LBA_XFER_CNT            ;Add 32 decimal
   806 00:0C8F: 85 F5                        STA     LBA_LOW_BYTE            ;Save it back
   807                        ;
   808 00:0C91: A5 F6                        LDA     LBA_HIGH_BYTE           ;Get LBA high byte
   809 00:0C93: 69 00                        ADC     #$00                    ;Add carry
   810 00:0C95: 85 F6                        STA     LBA_HIGH_BYTE           ;Save it back
   811                        ;
  Sun Mar 30 2025  9:15                                                                                                    Page 22


   812 00:0C97: A5 F7                        LDA     LBA_EXT_BYTE            ;Get LBA ext byte
   813 00:0C99: 69 00                        ADC     #$00                    ;Add carry
   814 00:0C9B: 85 F7                        STA     LBA_EXT_BYTE            ;Save it back
   815                        ;
   816                        SKP_HI_WR
   817 00:0C9D: CA                           DEX                             ;Decrement index
   818 00:0C9E: D0 E2                        BNE     LBA_WBLK                ;Loop until done
   819 00:0CA0: 88                           DEY                             ;Decrement index high
   820 00:0CA1: D0 DF                        BNE     LBA_WBLK                ;Loop back until done
   821 00:0CA3: 20 30 FF                     JSR     B_CNT_STOP              ;Stop benchmark counter
   822 00:0CA6: 20 33 FF                     JSR     B_CNT_DISP              ;Print Benchmark counter
   823 00:0CA9: 4C CE 0C                     JMP     USER_INPUT              ;Prompt User
   824                        ;
   825                        BENCH_WRITE_N
   826 00:0CAC: A9 FB                        LDA     #<LBA_BENCH_ABORT       ;Get LBA Write Bench msg
   827 00:0CAE: A0 1A                        LDY     #>LBA_BENCH_ABORT
   828 00:0CB0: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   829                        ;
   830 00:0CB3: 4C CE 0C                     JMP     USER_INPUT
   831                        ;
   832                        QUIT
   833 00:0CB6: A9 8A                        LDA     #<QUIT_MSG              ;Load Message address
   834 00:0CB8: A0 15                        LDY     #>QUIT_MSG              ;into A/Y regs
   835 00:0CBA: 20 3F FF                     JSR     B_PROMPTR               ;Send to console/return
   836                        ;
   837 00:0CBD: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   838 00:0CBF: A0 06                        LDY     #>LBA_BUFFER            ; address
   839 00:0CC1: A2 01                        LDX     #$01                    ;LBA count = 1
   840 00:0CC3: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Set Buffer address
   841 00:0CC6: 20 00 FF                     JSR     B_IDE_RESET             ;Reset MicroDrive
   842                        ;
   843 00:0CC9: A2 00                        LDX     #$00                    ;Get warm boot function
   844 00:0CCB: 4C 03 01                     JMP     PEM                     ;Jump to PEM to warm boot
   845                        ;
   846                        ;Prompt User for what's next
   847                        ; As we're outputting to a remote console, displaying the menu again could scroll the displayed
   848                        ; data off the screen, so this routine pauses the program execution and let's the user decide
   849                        ; on going to the menu display or just continuing on with another function.
   850                        ;
   851                        USER_INPUT
   852 00:0CCE: A9 A5                        LDA     #<USER_INMSG            ;Load message address
   853 00:0CD0: A0 15                        LDY     #>USER_INMSG            ;into A/Y reg
   854 00:0CD2: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   855 00:0CD5: 4C 0E 08                     JMP     MAIN_LOOP               ;Goto main input loop
   856                        ;
   857                        GET_LBA_NUM
   858                        ;Get LBA number from user
   859 00:0CD8: 20 0F 0F                     JSR     DECIN                   ;Get Decimal input, convert to BCD, then to HEX
   860                        ;
   861 00:0CDB: A5 14                        LDA     HEX6AND7                ;Low byte
   862 00:0CDD: A4 13                        LDY     HEX4AND5
   863 00:0CDF: A6 12                        LDX     HEX2AND3
   864 00:0CE1: 4C 0F FF                     JMP     B_IDE_SET_LBA           ;Set LBA number
   865                        ;
   866                        STRING_OUT
   867                        ; String out prints a string based on the A/Y register pointing to the start of the string
   868                        ; and the X reg containing how many characters to print (not a null terminated string)
   869                        ;
   870 00:0CE4: 85 D0                        STA     STRINGL                 ;Set low byte address
   871 00:0CE6: 84 D1                        STY     STRINGH                 ;Set high byte address
   872 00:0CE8: A0 00                        LDY     #$00                    ;Zero offet index
   873                        STRING_LOOP
   874 00:0CEA: B1 D0                        LDA     (STRINGL),Y             ;Get string data
  Sun Mar 30 2025  9:15                                                                                                    Page 23


   875 00:0CEC: C9 20                        CMP     #$20                    ;Check for ASCII space
   876 00:0CEE: F0 03                        BEQ     SKIP_SPC                ;If yes, skip printing it
   877 00:0CF0: 20 21 FF                     JSR     B_CHROUT                ;Send to terminal
   878                        SKIP_SPC
   879 00:0CF3: C8                           INY                             ;Increment index to string
   880 00:0CF4: CA                           DEX                             ;Decrement character count
   881 00:0CF5: D0 F3                        BNE     STRING_LOOP             ;Branch back until done
   882 00:0CF7: 60                           RTS                             ;Return to caller
   883                        ;
   884                        IDE_ERROR_HANDLER
   885                        ; This routine gets the error code anytime a command returns with the error
   886                        ; bit on in the status register. It uses the BIOS routine to get the error register
   887                        ; and returns with the error code in the X register.
   888                        ;
   889                        ; the error code is matched to the list of possible codes per the Hitachi
   890                        ; MicroDrive documentation, then the matching error message is sent to the console.
   891                        ; After this, the IDE controller is reset and the User is prompted for the next
   892                        ; action to be taken.
   893                        ;
   894 00:0CF8: A9 1E                        LDA     #<IDE_CONTROLLER_ERROR  ;Get Base IDE error msg
   895 00:0CFA: A0 1B                        LDY     #>IDE_CONTROLLER_ERROR
   896 00:0CFC: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   897                        ;
   898 00:0CFF: 20 03 FF                     JSR     B_IDE_GET_STAT          ;Get Status from BIOS
   899 00:0D02: 8A                           TXA                             ;Xfer error code to A reg
   900                        ;
   901 00:0D03: A2 05                        LDX     #IDE_ERROR_ADDRESS-IDE_ERROR_CODES-1    ;Get error list count
   902 00:0D05: DD 58 1D     ERROR_LP        CMP     IDE_ERROR_CODES,X       ;Compare to command list
   903 00:0D08: D0 0B                        BNE     ERROR_DEC               ;Check for next error and loop
   904                        ;
   905                        ; X Reg now contains error index
   906                        ;
   907 00:0D0A: 8A                           TXA                             ;Xfer Error code index to A reg
   908 00:0D0B: 0A                           ASL     A                       ;Multiply error index value by 2
   909 00:0D0C: AA                           TAX                             ;Xfer Error offset address to message table
   910                        ;
   911 00:0D0D: BD 5E 1D                     LDA     IDE_ERROR_ADDRESS,X     ;Get message address
   912 00:0D10: BC 5F 1D                     LDY     IDE_ERROR_ADDRESS+1,X
   913 00:0D13: 80 07                        BRA     ERROR_MSG               ;Branch below to output message and continue
   914                        ;
   915 00:0D15: CA           ERROR_DEC       DEX                             ;Decrement index count
   916 00:0D16: 10 ED                        BPL     ERROR_LP                ;If more to check, loop back
   917                        ;
   918                        ; No more error codes, so it must be something unknown. So print the unknown message
   919                        ; to the console and return to the User prompt.
   920                        ;
   921 00:0D18: A9 EE                        LDA     #<IDE_ERROR_06          ;Get Error message address
   922 00:0D1A: A0 1D                        LDY     #>IDE_ERROR_06
   923                        ERROR_MSG
   924 00:0D1C: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   925 00:0D1F: 20 00 FF                     JSR     B_IDE_RESET             ;Reset IDE Controller
   926 00:0D22: 4C CE 0C                     JMP     USER_INPUT              ;Prompt User
   927                        ;
   928                        GET_PATTERN
   929                        ; Get Pattern: This prompts the User for a 2-byte Hexadecimal fill pattern.
   930                        ; - This will be used by FILL_PATTERN to load the BENCH_BUFFER.
   931 00:0D25: A9 97                        LDA     #<PATTERN_MSG           ;Get write pattern msg
   932 00:0D27: A0 18                        LDY     #>PATTERN_MSG
   933 00:0D29: 20 3F FF                     JSR     B_PROMPTR               ;Send to console
   934                        ;
   935                        ; Monitor routine will get User input and return in A/Y regs
   936                        ; - Data also saved in INDEXH/INDEXL
   937 00:0D2C: 20 96 0F                     JSR     HEXIN4                ;Use Monitor to get input
  Sun Mar 30 2025  9:15                                                                                                    Page 24


   938 00:0D2F: 4C 82 0F                     JMP     CROUT                 ;Send C/R to console and return
   939                        ;
   940                        FILL_PATTERN
   941                        ;
   942                        ; Fill Pattern: This fills the LBA buffer with a user specified data pattern.
   943                        ; - The buffer address is specified by BENCH_BUFFER (at the end of our code).
   944                        ; - For ease of coding, we default to a 16KB fill buffer.
   945                        ; - The 16KB buffer is used by the Read and Write Benchmark routines only.
   946                        ;
   947 00:0D32: A9 00                        LDA     #<BENCH_BUFFER          ;Setup LBA Buffer
   948 00:0D34: A0 1E                        LDY     #>BENCH_BUFFER          ; address
   949 00:0D36: 85 AE                        STA     TGTL                    ;Setup Page Zero pointer lo
   950 00:0D38: 84 AF                        STY     TGTH                    ;Setup Page Zero pointer hi
   951                        ;
   952 00:0D3A: A2 00                        LDX     #$00                    ;Set Index for count
   953 00:0D3C: A0 20                        LDY     #$20                    ; of 16KB (8K of words)
   954                        FILL_P_LOOP
   955 00:0D3E: A5 A9                        LDA     INDEXH                  ;Get High byte fill
   956 00:0D40: 92 AE                        STA     (TGTL)                  ;Save it
   957 00:0D42: E6 AE                        INC     TGTL                    ;Increment pointer
   958 00:0D44: D0 02                        BNE     SK_FILL_1               ;Skip if no rollover
   959 00:0D46: E6 AF                        INC     TGTH                    ;Increment pointer
   960                        SK_FILL_1
   961 00:0D48: A5 A8                        LDA     INDEXL                  ;Get Low byte fill
   962 00:0D4A: 92 AE                        STA     (TGTL)                  ;Save it
   963 00:0D4C: E6 AE                        INC     TGTL                    ;Increment pointer
   964 00:0D4E: D0 02                        BNE     SK_FILL_2               ;Skip if no rollover
   965 00:0D50: E6 AF                        INC     TGTH                    ;Increment pointer
   966                        SK_FILL_2
   967 00:0D52: CA                           DEX                             ;Decrement low count
   968 00:0D53: D0 E9                        BNE     FILL_P_LOOP             ;Loop back till done
   969 00:0D55: 88                           DEY                             ;Decrement high count
   970 00:0D56: D0 E6                        BNE     FILL_P_LOOP             'Loop back until done
   971 00:0D58: 60                           RTS                             ;Return to caller
   972                        ;
   973                        ; Routine to swap high and low bytes in the block space
   974                        ; - used for Identity Data, as the bytes are swapped high and low
   975                        ;
   976                        SWAP_BYTE
   977 00:0D59: A9 00                        LDA     #<LBA_BUFFER            ;Setup LBA Buffer
   978 00:0D5B: A0 06                        LDY     #>LBA_BUFFER            ; address
   979 00:0D5D: 85 F8                        STA     BIOS_XFERL              ;Save it to page zero
   980 00:0D5F: 84 F9                        STY     BIOS_XFERH              ;variable
   981                        ;
   982 00:0D61: A2 00                        LDX     #$00                    ;Set Index for count of 256
   983 00:0D63: A0 01                        LDY     #$01                    ;Load Y reg for 1-byte offset
   984                        ;
   985                        SWAP_LOOP
   986 00:0D65: B2 F8                        LDA     (BIOS_XFERL)            ;Get first byte
   987 00:0D67: 48                           PHA                             ;Save to stack
   988 00:0D68: B1 F8                        LDA     (BIOS_XFERL),Y          ;Get second byte
   989 00:0D6A: 92 F8                        STA     (BIOS_XFERL)            ;Save it
   990 00:0D6C: 68                           PLA                             ;Get second byte back
   991 00:0D6D: 91 F8                        STA     (BIOS_XFERL),Y          ;Save it to first byte
   992                        ;
   993 00:0D6F: E6 F8                        INC     BIOS_XFERL              ;Increment index
   994 00:0D71: D0 02                        BNE     SWAP_SKP1               ;Branch if non-zero
   995 00:0D73: E6 F9                        INC     BIOS_XFERH              ;Increment index
   996                        SWAP_SKP1
   997 00:0D75: E6 F8                        INC     BIOS_XFERL              ;Increment index
   998 00:0D77: D0 02                        BNE     SWAP_SKP2               ;Branch if non-zero
   999 00:0D79: E6 F9                        INC     BIOS_XFERH              ;Increment index
  1000                        SWAP_SKP2
  Sun Mar 30 2025  9:15                                                                                                    Page 25


  1001 00:0D7B: CA                           DEX                             ;Decrement index
  1002 00:0D7C: D0 E7                        BNE     SWAP_LOOP               ;Loop back till done
  1003 00:0D7E: 60                           RTS                             ;Return to caller
  1004                        ;
  1005                        SYS_XFER
  1006                        ;
  1007                        ;System Transfer routine.
  1008                        ; This routine is used to write a section of memory to a defined set of contiguous blocks
  1009                        ; on the Microdrive. The purpose being to transfer the bootable image from RAM to the disc.
  1010                        ;
  1011                        ; The user is prompted for a few inputs as:
  1012                        ; - Starting LBA on the Microdrive
  1013                        ; - Starting memory address used as the source
  1014                        ; - Number of blocks to be transferred
  1015                        ;
  1016                        ; Once this is entered, the user is prompted to either continue or abort.
  1017                        ; if confirmed, the write executed and the blocks on the disc are overwritten with the
  1018                        ; contens of memory.
  1019                        ;
  1020 00:0D7F: A9 54                        LDA     #<SYS_INTRO_MSG         ;Get System Xfer Message
  1021 00:0D81: A0 1B                        LDY     #>SYS_INTRO_MSG         ;
  1022 00:0D83: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1023                        ;
  1024 00:0D86: A9 CC                        LDA     #<SYS_LBA_MSG           ;Get Starting LBA for xfer
  1025 00:0D88: A0 1B                        LDY     #>SYS_LBA_MSG           ;
  1026 00:0D8A: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1027 00:0D8D: 20 D8 0C                     JSR     GET_LBA_NUM             ;Get starting LBA from User
  1028                        ;
  1029                        ; Use C02 Monitor routine to get a 16-bit hex address returned in A/Y
  1030                        ; and stored in INDEXH/INDEXL
  1031                        ;
  1032 00:0D90: A9 4E                        LDA     #<RAM_START_MSG         ;Get Starting RAM for xfer
  1033 00:0D92: A0 1C                        LDY     #>RAM_START_MSG         ;
  1034 00:0D94: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1035 00:0D97: 20 96 0F                     JSR     HEXIN4                ;Call Monitor routine
  1036                        ;
  1037 00:0D9A: A9 0F                        LDA     #<BLK_SIZE_MSG          ;Get LBA count for xfer
  1038 00:0D9C: A0 1C                        LDY     #>BLK_SIZE_MSG          ;
  1039 00:0D9E: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1040                        ;
  1041 00:0DA1: 20 0F 0F                     JSR     DECIN                   ;Get Decimal input, convert to BCD, then to HEX
  1042                        ;
  1043 00:0DA4: A6 14                        LDX     HEX6AND7                ;Get low byte (number of blocks)
  1044 00:0DA6: A5 A8                        LDA     INDEXL                  ;Get RAM address to start from
  1045 00:0DA8: A4 A9                        LDY     INDEXH                  ;
  1046 00:0DAA: 20 12 FF                     JSR     B_IDE_SET_ADDR          ;Call BIOS to set address and block count
  1047                        ;
  1048 00:0DAD: A9 79                        LDA     #<SYS_CONFIRM_MSG       ;Get Confirm Message for xfer
  1049 00:0DAF: A0 1C                        LDY     #>SYS_CONFIRM_MSG       ;
  1050 00:0DB1: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1051                        ;
  1052                        SYS_WRT_WARN_LP
  1053 00:0DB4: 20 5E 0F                     JSR     RDCHAR                  ;Get character from user
  1054 00:0DB7: 20 21 FF                     JSR     B_CHROUT                ;Send to console
  1055 00:0DBA: C9 59                        CMP     #"Y"                    ;Test for yes
  1056 00:0DBC: F0 09                        BEQ     SYS_WRITE_GO            ;If yes, do write benchmark
  1057 00:0DBE: C9 4E                        CMP     #"N"                    ;Test for no
  1058 00:0DC0: F0 25                        BEQ     SYS_WRITE_ABORT         ;If no, skip write benchmark
  1059 00:0DC2: 20 68 0F                     JSR     BEEP                    ;Else, error, send beep
  1060 00:0DC5: 80 ED                        BRA     SYS_WRT_WARN_LP         ;Branch back and try again
  1061                        ;
  1062                        SYS_WRITE_GO
  1063 00:0DC7: A9 AF                        LDA     #<SYS_WRITE_MSG         ;Get Confirm Message for xfer
  Sun Mar 30 2025  9:15                                                                                                    Page 26


  1064 00:0DC9: A0 1C                        LDY     #>SYS_WRITE_MSG         ;
  1065 00:0DCB: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1066                        ;
  1067                        WAIT_SYS
  1068 00:0DCE: A5 DC                        LDA     OCNT_A                  ;Get output count for console
  1069 00:0DD0: D0 FC                        BNE     WAIT_SYS                ;Wait until done
  1070                        ;
  1071 00:0DD2: 20 0C FF                     JSR     B_IDE_WRITE_LBA         ;Call BIOS to write image
  1072 00:0DD5: A5 FB                        LDA     IDE_STATUS_RAM          ;Get IDE Status (RAM)
  1073 00:0DD7: 4A                           LSR     A                       ;Shift error bit into carry
  1074 00:0DD8: B0 0A                        BCS     IMG_WR_ERR              ;Branch if error
  1075                        ;
  1076 00:0DDA: A9 CA                        LDA     #<SYS_COMPLETE_MSG      ;Get Confirm Message for xfer
  1077 00:0DDC: A0 1C                        LDY     #>SYS_COMPLETE_MSG      ;
  1078 00:0DDE: 20 3F FF                     JSR     B_PROMPTR               ;Send to Console
  1079 00:0DE1: 4C CE 0C                     JMP     USER_INPUT              ;Exit to main
  1080                        ;
  1081                        IMG_WR_ERR
  1082 00:0DE4: 20 F8 0C                     JSR     IDE_ERROR_HANDLER       ;Handle Disc error
  1083                        SYS_WRITE_ABORT
  1084 00:0DE7: 4C CE 0C                     JMP     USER_INPUT              ;Exit to main
  1085                        ;
  1086                        ;
  1087                        ; The following routines are borrowed from Brian Phelps' SyMON monitor.
  1088                        ; - HEXTOBCD, BCDOUT, BCDTOASC, BCDTOHEX, ASCTODEC
  1089                        ; - I made some coding changes to use CMOS instructions, etc.
  1090                        ;
  1091                        ;HEXTOBCD subroutine: convert a 1-8 digit HEX value to a 1-10 digit BCD value.
  1092                        ; Call with 8 digit (4 byte) HEX value in HEX0AND1(MSB) through HEX6AND7(LSB).
  1093                        ; Returns with 10 digit (5 byte) BCD result in DEC0AND1(MSB) through DEC8AND9(LSB)
  1094                        ;HPHANTOM is a 16 bit address used to reference an 8 bit zero-page address.
  1095                        ; (HEXTOBCD needs LDA $hh,Y (an invalid instruction) so we use LDA $00hh,Y instead)
  1096                        ; This address is not written-to nor read-from in the HEXTOBCD subroutine.
  1097                        ; The address is the zero-page memory location immediatly below the HEX0AND1 variable
  1098                        ;HEX value input buffer:
  1099                        ;HEX0AND1 Two most significant HEX digits
  1100                        ;HEX2AND3
  1101                        ;HEX4AND5
  1102                        ;HEX6AND7 Two least significant HEX digits
  1103                        ;BCD value output buffer (BCD accumulator):
  1104                        ;DEC0AND1 ;Two most significant BCD digits
  1105                        ;DEC2AND3
  1106                        ;DEC4AND5
  1107                        ;DEC6AND7
  1108                        ;DEC8AND9 ;Two least significant BCD digits
  1109                        ;
  1110 00:0DEA: 64 15        HEXTOBCD        STZ     DEC0AND1                ;Init (zero) buffer
  1111 00:0DEC: 64 16                        STZ     DEC2AND3
  1112 00:0DEE: 64 17                        STZ     DEC4AND5
  1113 00:0DF0: 64 18                        STZ     DEC6AND7
  1114 00:0DF2: 64 19                        STZ     DEC8AND9
  1115 00:0DF4: A0 04                        LDY     #$04                    ;Initialize HEX input buffer byte index: point to addre
                    ss minus 1 of LSB
  1116 00:0DF6: A2 04                        LDX     #$04                    ;Initialize multiplicand table index: point to LSB of l
                    owest multiplicand
  1117 00:0DF8: B9 10 00     DECLOOP         LDA     HPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1118 00:0DFB: 29 0F                        AND     #$0F                    ;Zero the high digit
  1119 00:0DFD: 20 18 0E                     JSR     MULTIPLY                ;Multiply low digit
  1120 00:0E00: E8                           INX                             ;Add 5 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1121 00:0E01: E8                           INX
  1122 00:0E02: E8                           INX
  Sun Mar 30 2025  9:15                                                                                                    Page 27


  1123 00:0E03: E8                           INX
  1124 00:0E04: E8                           INX
  1125 00:0E05: B9 10 00                     LDA     HPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1126 00:0E08: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1127 00:0E09: 4A                           LSR     A
  1128 00:0E0A: 4A                           LSR     A
  1129 00:0E0B: 4A                           LSR     A
  1130 00:0E0C: 20 18 0E                     JSR     MULTIPLY                ;Multiply digit
  1131 00:0E0F: E8                           INX                             ;Add 5 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1132 00:0E10: E8                           INX
  1133 00:0E11: E8                           INX
  1134 00:0E12: E8                           INX
  1135 00:0E13: E8                           INX
  1136 00:0E14: 88                           DEY                             ;Decrement HEX input buffer byte index
  1137 00:0E15: D0 E1                        BNE     DECLOOP                 ;LOOP back to DECLOOP IF byte index <> 0: there are mor
                    e bytes to process
  1138 00:0E17: 60                           RTS                             ; ELSE, done HEXTOBCD subroutine, RETURN
  1139                        ;
  1140                        ;Multiply indexed multiplicand by digit in ACCUMULATOR
  1141                        ;
  1142 00:0E18: 48           MULTIPLY        PHA
  1143 00:0E19: DA                           PHX
  1144 00:0E1A: 5A                           PHY
  1145 00:0E1B: F8                           SED                             ;Switch processor to BCD arithmatic mode
  1146 00:0E1C: A8                           TAY                             ;Copy digit to Y REGISTER: multiplier loop counter
  1147 00:0E1D: C0 00        HMLTLOOP        CPY     #$00
  1148 00:0E1F: D0 05                        BNE     HDOADD                  ;GOTO HDOADD IF multiplier loop counter <> 0
  1149 00:0E21: D8                           CLD                             ; ELSE, switch processor to BINARY arithmatic mode
  1150 00:0E22: 7A                           PLY
  1151 00:0E23: FA                           PLX
  1152 00:0E24: 68                           PLA
  1153 00:0E25: 60           BCD_DONE        RTS                             ;Done MULTIPLY subroutine, RETURN
  1154                        ;
  1155                        ;Add indexed multiplicand to BCD accumulator (output buffer)
  1156                        ;
  1157 00:0E26: 18           HDOADD          CLC
  1158 00:0E27: BD 03 1D                     LDA     HMULTAB,X               ;Least significant byte of indexed multiplicand
  1159 00:0E2A: 65 19                        ADC     DEC8AND9                ;Least significant byte of BCD accumulator
  1160 00:0E2C: 85 19                        STA     DEC8AND9
  1161 00:0E2E: BD 02 1D                     LDA     HMULTAB-1,X
  1162 00:0E31: 65 18                        ADC     DEC6AND7
  1163 00:0E33: 85 18                        STA     DEC6AND7
  1164 00:0E35: BD 01 1D                     LDA     HMULTAB-2,X
  1165 00:0E38: 65 17                        ADC     DEC4AND5
  1166 00:0E3A: 85 17                        STA     DEC4AND5
  1167 00:0E3C: BD 00 1D                     LDA     HMULTAB-3,X
  1168 00:0E3F: 65 16                        ADC     DEC2AND3
  1169 00:0E41: 85 16                        STA     DEC2AND3
  1170 00:0E43: BD FF 1C                     LDA     HMULTAB-4,X             ;Most significant byte of indexed multiplicand
  1171 00:0E46: 65 15                        ADC     DEC0AND1                ;Most significant byte of BCD accumulator
  1172 00:0E48: 85 15                        STA     DEC0AND1
  1173 00:0E4A: 88                           DEY                             ;Decrement multiplier loop counter
  1174 00:0E4B: 80 D0                        BRA     HMLTLOOP                ;LOOP back to HMLTLOOP
  1175                        ;
  1176                        ;BCDOUT subroutine: convert 10 BCD digits to ASCII DECIMAL digits then send result to terminal.
  1177                        ;Leading zeros are supressed in the displayed result.
  1178                        ;Call with 10 digit (5 byte) BCD value contained in variables DEC0AND1 through DEC8AND9:
  1179                        ;DEC0AND1 ($15) Two most significant BCD digits
  1180                        ;DEC2AND3 ($16)
  1181                        ;DEC4AND5 ($17)
  1182                        ;DEC6AND7 ($18)
  Sun Mar 30 2025  9:15                                                                                                    Page 28


  1183                        ;DEC8AND9 ($19) Two least significant BCD digits
  1184                        ;
  1185 00:0E4D: A2 00        BCDOUT          LDX     #$00                    ;Initialize BCD output buffer index: point to MSB
  1186 00:0E4F: A0 00                        LDY     #$00                    ;Initialize leading zero flag: no non-zero digits have 
                    been processed
  1187 00:0E51: B5 15        BCDOUTL         LDA     DEC0AND1,X              ;Read indexed byte from BCD output buffer
  1188 00:0E53: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1189 00:0E54: 4A                           LSR     A
  1190 00:0E55: 4A                           LSR     A
  1191 00:0E56: 4A                           LSR     A
  1192 00:0E57: 20 6F 0E                     JSR     BCDTOASC                ;Convert BCD digit to ASCII DECIMAL digit, send digit t
                    o terminal
  1193 00:0E5A: B5 15                        LDA     DEC0AND1,X              ;Read indexed byte from BCD output buffer
  1194 00:0E5C: 29 0F                        AND     #$0F                    ;Zero the high digit
  1195 00:0E5E: 20 6F 0E                     JSR     BCDTOASC                ;Convert BCD digit to ASCII DECIMAL digit, send digit t
                    o terminal
  1196 00:0E61: E8                           INX                             ;Increment BCD output buffer index
  1197 00:0E62: E0 05                        CPX     #$05
  1198 00:0E64: D0 EB                        BNE     BCDOUTL                 ;LOOP back to BCDOUTL IF output buffer index <> 5
  1199 00:0E66: C0 00                        CPY     #$00
  1200 00:0E68: D0 BB                        BNE     BCD_DONE                ; ELSE, GOTO BCDOUTDN IF any non-zero digits were proce
                    ssed
  1201 00:0E6A: A9 30                        LDA     #$30                    ; ELSE, send "0" to terminal
  1202 00:0E6C: 4C 21 FF                     JMP     B_CHROUT                ;Send to console
  1203                        ;
  1204                        ;BCDTOASC subroutine:
  1205                        ; convert BCD digit to ASCII DECIMAL digit, send digit to terminal IF it's not a leading zero
  1206                        ;
  1207 00:0E6F: D0 04        BCDTOASC        BNE     NONZERO                 ;GOTO NONZERO IF BCD digit <> 0
  1208 00:0E71: C0 00                        CPY     #$00                    ; ELSE, GOTO BTADONE IF no non-zero digits have been pr
                    ocessed
  1209 00:0E73: F0 B0                        BEQ     BCD_DONE                ;  (supress output of leading zeros)
  1210 00:0E75: C8           NONZERO         INY                             ; ELSE, indicate that a non-zero digit has been process
                    ed (Y REGISTER <> 0)
  1211 00:0E76: 18                           CLC                             ;Add ASCII "0" to digit: convert BCD digit to ASCII DEC
                    IMAL digit
  1212 00:0E77: 69 30                        ADC     #$30
  1213 00:0E79: 4C 21 FF                     JMP     B_CHROUT                ;Send converted digit to terminal
  1214                        ;
  1215                        ;BCDTOHEX subroutine: convert a 1-10 digit BCD value to a 1-8 digit HEX value.
  1216                        ; Call with 10 digit (5 byte) DECIMAL value in DEC0AND1(MSB) through DEC8AND9(LSB).
  1217                        ; Returns with 8 digit (4 byte) HEX result in HEX0AND1(MSB) through HEX6AND7(LSB)
  1218                        ;DPHANTOM is a 16 bit address used to reference an 8 bit zero-page address.
  1219                        ; (BCDTOHEX needs LDA $hh,Y (an invalid instruction) so we use LDA $00hh,Y instead)
  1220                        ; This address is not written-to nor read-from in the BCDTOHEX subroutine.
  1221                        ; The address is the zero-page memory location immediatly below the DEC0AND1 variable
  1222                        ;BCD value input buffer:
  1223                        ;DEC0AND1 ;Two most significant BCD digits
  1224                        ;DEC2AND3
  1225                        ;DEC4AND5
  1226                        ;DEC6AND7
  1227                        ;DEC8AND9 ;Two least significant BCD digits
  1228                        ;HEX value output buffer (HEX accumulator):
  1229                        ;HEX0AND1 Two most significant HEX digits
  1230                        ;HEX2AND3
  1231                        ;HEX4AND5
  1232                        ;HEX6AND7 Two least significant HEX digits
  1233                        ;
  1234 00:0E7C: 64 11        BCDTOHEX        STZ     HEX0AND1                ;Init (zero) buffer
  1235 00:0E7E: 64 12                        STZ     HEX2AND3
  1236 00:0E80: 64 13                        STZ     HEX4AND5
  1237 00:0E82: 64 14                        STZ     HEX6AND7
  1238 00:0E84: A0 05                        LDY     #$05                    ;Initialize DECIMAL input buffer byte index: point to (
  Sun Mar 30 2025  9:15                                                                                                    Page 29


                    address - 1) of LSB
  1239 00:0E86: A2 03                        LDX     #$03                    ;Initialize multiplicand table index: point to LSB of l
                    owest multiplicand
  1240 00:0E88: B9 14 00     BCDLOOP         LDA     DPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1241 00:0E8B: 29 0F                        AND     #$0F                    ;Zero the high digit
  1242 00:0E8D: 20 A6 0E                     JSR     MULTPLI                 ;Multiply low digit
  1243 00:0E90: E8                           INX                             ;Add 4 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1244 00:0E91: E8                           INX
  1245 00:0E92: E8                           INX
  1246 00:0E93: E8                           INX
  1247 00:0E94: B9 14 00                     LDA     DPHANTOM,Y              ;Read indexed byte from input buffer: Y REGISTER index 
                    always > 0 here
  1248 00:0E97: 4A                           LSR     A                       ;Shift high digit to low digit, zero high digit
  1249 00:0E98: 4A                           LSR     A
  1250 00:0E99: 4A                           LSR     A
  1251 00:0E9A: 4A                           LSR     A
  1252 00:0E9B: 20 A6 0E                     JSR     MULTPLI                 ;Multiply digit
  1253 00:0E9E: E8                           INX                             ;Add 4 to multiplicand table index: point to LSB of nex
                    t higher multiplicand
  1254 00:0E9F: E8                           INX
  1255 00:0EA0: E8                           INX
  1256 00:0EA1: E8                           INX
  1257 00:0EA2: 88                           DEY                             ;Decrement DECIMAL input buffer byte index
  1258 00:0EA3: D0 E3                        BNE     BCDLOOP                 ;LOOP back to BCDLOOP IF byte index <> 0: there are mor
                    e bytes to process
  1259 00:0EA5: 60                           RTS                             ; ELSE, done BCDTOHEX subroutine, RETURN
  1260                        ;
  1261                        ;Multiply indexed multiplicand by digit in ACCUMULATOR
  1262                        ;
  1263 00:0EA6: 48           MULTPLI         PHA                             ;Save registers
  1264 00:0EA7: DA                           PHX
  1265 00:0EA8: 5A                           PHY
  1266 00:0EA9: A8                           TAY                             ;Copy digit to Y REGISTER: multiplier loop counter
  1267 00:0EAA: C0 00        DMLTLOOP        CPY     #$00
  1268 00:0EAC: D0 04                        BNE     DDOADD                  ;GOTO DDOADD IF multiplier loop counter <> 0
  1269 00:0EAE: 7A                           PLY                             ;Restore registers
  1270 00:0EAF: FA                           PLX
  1271 00:0EB0: 68                           PLA
  1272 00:0EB1: 60                           RTS                             ;Done MULTIPLI subroutine, RETURN
  1273                        ;
  1274                        ;Add indexed multiplicand to HEX accumulator (output buffer)
  1275                        ;
  1276 00:0EB2: 18           DDOADD          CLC
  1277 00:0EB3: BD 2B 1D                     LDA     DMULTAB,X               ;Least significant byte of indexed multiplicand
  1278 00:0EB6: 65 14                        ADC     HEX6AND7                ;Least significant byte of HEX accumulator
  1279 00:0EB8: 85 14                        STA     HEX6AND7
  1280 00:0EBA: BD 2A 1D                     LDA     DMULTAB-1,X
  1281 00:0EBD: 65 13                        ADC     HEX4AND5
  1282 00:0EBF: 85 13                        STA     HEX4AND5
  1283 00:0EC1: BD 29 1D                     LDA     DMULTAB-2,X
  1284 00:0EC4: 65 12                        ADC     HEX2AND3
  1285 00:0EC6: 85 12                        STA     HEX2AND3
  1286 00:0EC8: BD 28 1D                     LDA     DMULTAB-3,X             ;Most significant byte of indexed multiplicand
  1287 00:0ECB: 65 11                        ADC     HEX0AND1                ;Most significant byte of HEX accumulator
  1288 00:0ECD: 85 11                        STA     HEX0AND1
  1289 00:0ECF: 88                           DEY                             ;Decrement multiplier loop counter
  1290 00:0ED0: B0 02                        BCS     OVERFLOW                ;GOTO OVERFLOW IF the last add produced a CARRY: HEX ou
                    tput buffer has overflowed
  1291 00:0ED2: 90 D6                        BCC     DMLTLOOP                ; ELSE, LOOP back to DMLTLOOP (always branch)
  1292 00:0ED4: A9 2A        OVERFLOW        LDA     #$2A                    ;Send "*" to terminal: indicate that an overflow has oc
                    cured
  Sun Mar 30 2025  9:15                                                                                                    Page 30


  1293 00:0ED6: 20 21 FF                     JSR     B_CHROUT
  1294 00:0ED9: 80 CF                        BRA     DMLTLOOP                ;LOOP back to DMLTLOOP
  1295                        ;
  1296                        ;ASCTODEC subroutine: convert ASCII DECIMAL digits to BCD
  1297                        ;
  1298 00:0EDB: 64 15        ASCTODEC        STZ     DEC0AND1                ;Init (zero) buffer two most significant BCD digits
  1299 00:0EDD: 64 16                        STZ     DEC2AND3
  1300 00:0EDF: 64 17                        STZ     DEC4AND5
  1301 00:0EE1: 64 18                        STZ     DEC6AND7
  1302 00:0EE3: 64 19                        STZ     DEC8AND9                ; two least significant BCD digits
  1303 00:0EE5: A6 B2                        LDX     BUFIDX                  ;Read number of digits entered: ASCII digit buffer inde
                    x
  1304 00:0EE7: F0 18                        BEQ     A2DDONE                 ;GOTO A2DDONE IF BUFIDX = 0: no digits were entered
  1305 00:0EE9: A0 05                        LDY     #$05                    ; ELSE, Initialize BCD input buffer index: process up t
                    o 5 BCD bytes (10 digits)
  1306 00:0EEB: 20 02 0F     ATODLOOP        JSR     A2DSUB                  ;Read ASCII digit then convert to BCD
  1307 00:0EEE: 99 14 00                     STA     DPHANTOM,Y              ;Write BCD digit to indexed buffer location (index alwa
                    ys > 0)
  1308 00:0EF1: 20 02 0F                     JSR     A2DSUB                  ;Read ASCII digit then convert to BCD
  1309 00:0EF4: 0A                           ASL     A                       ;Make this BCD digit the more significant in the BCD by
                    te
  1310 00:0EF5: 0A                           ASL     A
  1311 00:0EF6: 0A                           ASL     A
  1312 00:0EF7: 0A                           ASL     A
  1313 00:0EF8: 19 14 00                     ORA     DPHANTOM,Y              ;OR with the less significant digit
  1314 00:0EFB: 99 14 00                     STA     DPHANTOM,Y              ;Write BCD byte to indexed buffer location (index alway
                    s > 0)
  1315 00:0EFE: 88                           DEY                             ;Decrement BCD input buffer index
  1316 00:0EFF: D0 EA                        BNE     ATODLOOP                ;GOTO ATODLOOP IF buffer index <> 0: there is room to p
                    rocess another digit
  1317 00:0F01: 60           A2DDONE         RTS                             ; ELSE, done ASCTODEC, RETURN
  1318                        ;
  1319                        ;Read indexed ASCII DECIMAL digit from text buffer then convert digit to 4 bit BCD
  1320                        ;
  1321 00:0F02: 8A           A2DSUB          TXA                             ;GOTO A2DCONV IF digit buffer index <> 0: there are mor
                    e digits to process
  1322 00:0F03: D0 03                        BNE     A2DCONV
  1323 00:0F05: 68                           PLA                             ; ELSE, pull return address from STACK
  1324 00:0F06: 68                           PLA
  1325 00:0F07: 60                           RTS                             ;Done ASCTODEC, RETURN
  1326 00:0F08: B5 2F        A2DCONV         LDA     IBUFF-1,X               ;Read indexed ASCII DECIMAL digit
  1327 00:0F0A: 38                           SEC                             ;Subtract ASCII "0" from ASCII DECIMAL digit: convert d
                    igit to BCD
  1328 00:0F0B: E9 30                        SBC     #$30
  1329 00:0F0D: CA                           DEX                             ;Decrement ASCII digit buffer index
  1330 00:0F0E: 60                           RTS                             ;A2DSUB done, RETURN
  1331                        ;
  1332                        ;DECIN subroutine: request 1 - 10 DECIMAL digit input from terminal, followed by [RETURN].
  1333                        ; [ESCAPE] aborts, [BACKSPACE] erases last keystroke.
  1334                        ; Convert input to BCD and HEX then store both results as follows:
  1335                        ; Converted 10 digit (5 byte) BCD value will be contained in variables DEC0AND1 through DEC8AND9:
  1336                        ;  DEC0AND1 ($E5) Two most significant BCD digits
  1337                        ;  DEC2AND3 ($E6)
  1338                        ;  DEC4AND5 ($E7)
  1339                        ;  DEC6AND7 ($E8)
  1340                        ;  DEC8AND9 ($E9) Two least significant BCD digits
  1341                        ; Converted 8 digit (4 byte) HEX value will be contained in variables HEX0AND1 through HEX6AND7:
  1342                        ;  HEX0AND1 ($E1) Two most significant HEX digits
  1343                        ;  HEX2AND3 ($E2)
  1344                        ;  HEX4AND5 ($E3)
  1345                        ;  HEX6AND7 ($E4) Two least significant HEX digits
  1346                        ; NOTE1: If a DECIMAL value greater than 4,294,967,295 ($FFFFFFFF) is entered,
  1347                        ;  1 or 2 asterisks (*) will be sent to the terminal following the inputted digits.
  Sun Mar 30 2025  9:15                                                                                                    Page 31


  1348                        ;  This is to indicate that an overflow in the HEX accumulator has occured.
  1349                        ;  (the BCDTOHEX subroutine's HEX accumulator "rolls over" to zero when that value is exceeded)
  1350                        ;  An overflow condition does NOT affect the BCD value stored.
  1351                        ; NOTE2: This subroutine is not used by SyMon; it is here for user purposes, if needed.
  1352                        ;
  1353 00:0F0F: 20 18 0F     DECIN           JSR     DECINPUT                ;Request 1 - 8 DECIMAL digit input from terminal
  1354 00:0F12: 20 DB 0E                     JSR     ASCTODEC                ;Convert ASCII DECIMAL digits to BCD
  1355 00:0F15: 4C 7C 0E                     JMP     BCDTOHEX                ;Convert 1-8 digit BCD to a 1-8 digit HEX value
  1356                        ;
  1357                        ;DECINPUT subroutine: request 1 to 8 DECIMAL digits from terminal. Result is
  1358                        ; stored in zero-page address IBUFF through (IBUFF + $08)
  1359                        ;Setup RDLINE subroutine parameters:
  1360                        ;
  1361                        DECINPUT
  1362 00:0F18: A2 08                        LDX     #$08                    ;  X-REGISTER = maximum number of digits allowed
  1363                        ; Drop into RDLINE routine
  1364                        ;
  1365                        ;RDLINE subroutine: Store keystrokes into buffer until [RETURN] key is struck
  1366                        ; Used for Decimal entry, so only (0-9) are accepted entries.
  1367                        ; On entry, X Reg = buffer length. On exit, X Reg = buffer count
  1368                        ; [BACKSPACE] key removes keystrokes from buffer.
  1369                        ; [ESCAPE] key aborts then returns.
  1370 00:0F1A: 86 B3        RDLINE          STX     BUFLEN          ;Store buffer length
  1371 00:0F1C: 64 B2                        STZ     BUFIDX          ;Zero buffer index
  1372 00:0F1E: 20 5E 0F     RDLOOP          JSR     RDCHAR          ;Get character from terminal, convert LC2UC
  1373 00:0F21: C9 1B                        CMP     #$1B            ;Check for ESC key
  1374 00:0F23: F0 33                        BEQ     RDNULL          ;If yes, exit back to Monitor
  1375 00:0F25: C9 0D        NOTESC          CMP     #$0D            ;Check for C/R
  1376 00:0F27: F0 2B                        BEQ     EXITRD          ;Exit if yes
  1377 00:0F29: C9 08                        CMP     #$08            ;Check for Backspace
  1378 00:0F2B: F0 1C                        BEQ     RDBKSP          ;If yes handle backspace
  1379 00:0F2D: C9 30                        CMP     #$30            ;Check for '0' or higher
  1380 00:0F2F: 90 0A                        BCC     INPERR          ;Branch to error if less than '0'
  1381 00:0F31: C9 3A                        CMP     #$3A            ;Check for higher than '9'
  1382 00:0F33: B0 06                        BCS     INPERR          ;Branch to error if more than '9'
  1383 00:0F35: A6 B2                        LDX     BUFIDX          ;Get the current buffer index
  1384 00:0F37: E4 B3                        CPX     BUFLEN          ;Compare to length for space
  1385 00:0F39: 90 05                        BCC     STRCHR          ;Branch to store in buffer
  1386 00:0F3B: 20 68 0F     INPERR          JSR     BEEP            ;Else, error, send Bell to terminal
  1387 00:0F3E: 80 DE                        BRA     RDLOOP          ;Branch back to RDLOOP
  1388 00:0F40: 95 30        STRCHR          STA     IBUFF,X         ;Store keystroke in buffer
  1389 00:0F42: 20 21 FF                     JSR     B_CHROUT        ;Send keystroke to terminal
  1390 00:0F45: E6 B2                        INC     BUFIDX          ;Increment buffer index
  1391 00:0F47: 80 D5                        BRA     RDLOOP          ;Branch back to RDLOOP
  1392 00:0F49: A5 B2        RDBKSP          LDA     BUFIDX          ;Check if buffer is empty
  1393 00:0F4B: F0 EE                        BEQ     INPERR          ;Branch if yes
  1394 00:0F4D: C6 B2                        DEC     BUFIDX          ;Else, decrement buffer index
  1395 00:0F4F: 20 72 0F                     JSR     BSOUT           ;Send Backspace to terminal
  1396 00:0F52: 80 CA                        BRA     RDLOOP          ;Loop back and continue
  1397 00:0F54: A6 B2        EXITRD          LDX     BUFIDX          ;Get keystroke count (set Z flag)
  1398 00:0F56: D0 05                        BNE     RDL_OK          ;If data entered, normal exit
  1399 00:0F58: 68           RDNULL          PLA                     ;Pull return address
  1400 00:0F59: 68                           PLA                     ; from stack
  1401 00:0F5A: 4C CE 0C                     JMP     USER_INPUT      ;Go to main menu
  1402 00:0F5D: 60           RDL_OK          RTS                     ;Return to caller
  1403                        ;
  1404                        ;RDCHAR subroutine: Waits for a keystroke to be entered.
  1405                        ; if keystroke is a lower-case alphabetical, convert it to upper-case
  1406 00:0F5E: 20 1E FF     RDCHAR          JSR     B_CHRIN         ;Request keystroke input from terminal
  1407 00:0F61: C9 61                        CMP     #$61            ;Check for lower case value range
  1408 00:0F63: 90 02                        BCC     UCOK            ;Branch if < $61, control code/upper-case/numeric
  1409 00:0F65: E9 20                        SBC     #$20            ;Subtract $20 to convert to upper case
  1410 00:0F67: 60           UCOK            RTS                     ;Character received, return to caller
  Sun Mar 30 2025  9:15                                                                                                    Page 32


  1411                        ;
  1412                        ;BEEP subroutine: Send ASCII [BELL] to terminal
  1413 00:0F68: 48           BEEP            PHA                     ;Save A Reg on Stack
  1414 00:0F69: A9 07                        LDA     #$07            ;Get ASCII [BELL] to terminal
  1415 00:0F6B: 80 1D                        BRA     SENDIT          ;Branch to send
  1416                        ;
  1417                        ;SPC subroutine: Send a Space to terminal
  1418 00:0F6D: 48           SPC             PHA                     ;Save character in A Reg
  1419 00:0F6E: A9 20                        LDA     #$20            ;Get ASCII Space
  1420 00:0F70: 80 18                        BRA     SENDIT          ;Branch to send
  1421                        ;
  1422                        ;BSOUT subroutine: send a Backspace to terminal
  1423 00:0F72: 20 78 0F     BSOUT           JSR     BSOUT2          ;Send an ASCII backspace
  1424 00:0F75: 20 6D 0F                     JSR     SPC             ;Send space to clear out character
  1425 00:0F78: 48           BSOUT2          PHA                     ;Save character in A Reg
  1426 00:0F79: A9 08                        LDA     #$08            ;Send another Backspace to return
  1427 00:0F7B: 80 0D                        BRA     SENDIT          ;Branch to send
  1428                        ;
  1429                        ;DOLLAR subroutine: Send "$" to terminal
  1430 00:0F7D: 48           DOLLAR          PHA                     ;Save A Reg on STACK
  1431 00:0F7E: A9 24                        LDA     #$24            ;Get ASCII "$"
  1432 00:0F80: 80 08                        BRA     SENDIT          ;Branch to send
  1433                        ;
  1434                        ;Send CR/LF to terminal
  1435 00:0F82: 48           CROUT           PHA                     ;Save A Reg
  1436 00:0F83: A9 0D                        LDA     #$0D            ;Get ASCII Return
  1437 00:0F85: 20 21 FF                     JSR     B_CHROUT        ;Send to terminal
  1438 00:0F88: A9 0A                        LDA     #$0A            ;Get ASCII Linefeed
  1439 00:0F8A: 20 21 FF     SENDIT          JSR     B_CHROUT        ;Send to terminal
  1440 00:0F8D: 68                           PLA                     ;Restore A Reg
  1441 00:0F8E: 60                           RTS                     ;Return to caller
  1442                        ;
  1443                        ;INCINDEX subroutine: increment 16 bit variable INDEXL/INDEXH
  1444 00:0F8F: E6 A8        INCINDEX        INC     INDEXL          ;Increment index low byte
  1445 00:0F91: D0 02                        BNE     SKP_IDX         ;If not zero, skip high byte
  1446 00:0F93: E6 A9                        INC     INDEXH          ;Increment index high byte
  1447 00:0F95: 60           SKP_IDX         RTS                     ;Return to caller
  1448                        ;
  1449                        ;HEX input subroutines: Request 1 to 4 ASCII HEX digits from terminal, then convert digits into
  1450                        ; a binary value. For 1 to 4 digits entered, HEXDATAH and HEXDATAL contain the output.
  1451                        ; Variable BUFIDX will contain the number of digits entered
  1452                        ; HEXIN2 - returns value in A Reg and Y Reg only (Y Reg always $00)
  1453                        ; HEXIN4 - returns values in A Reg, Y Reg and INDEXL/INDEXH
  1454                        ; HEX2 - Prints MSG# in A Reg then calls HEXIN2, HEX4 - Prints MSG# in A Reg then calls HEXIN4
  1455                        ;HEX4            JSR     PROMPT          ;Print MSG # from A Reg
  1456 00:0F96: A2 04        HEXIN4          LDX     #$04            ;Set for number of characters allowed
  1457 00:0F98: 20 A2 0F                     JSR     HEXINPUT        ;Convert digits
  1458 00:0F9B: 84 A9                        STY     INDEXH          ;Store to INDEXH
  1459 00:0F9D: 85 A8                        STA     INDEXL          ;Store to INDEXL
  1460 00:0F9F: 60                           RTS                     ;Return to caller
  1461                        ;
  1462                        ;HEX2            JSR     PROMPT          ;Print MSG # from A Reg
  1463 00:0FA0: A2 02        HEXIN2          LDX     #$02            ;Set for number of characters allowed
  1464                        ;
  1465                        ;HEXINPUT subroutine: request 1 to 4 HEX digits from terminal, then convert ASCII HEX to HEX
  1466                        ; minor update from Mike Barry, saves a byte.
  1467                        ; Setup RDLINE subroutine parameters:
  1468 00:0FA2: 20 7D 0F     HEXINPUT        JSR     DOLLAR          ;Send "$" to console
  1469 00:0FA5: 20 D0 0F                     JSR     RDLINE_H          ;Request ASCII HEX input from terminal
  1470 00:0FA8: F0 25                        BEQ     HINEXIT         ;Exit if none (Z flag already set)
  1471 00:0FAA: 64 A4                        STZ     HEXDATAH        ;Clear Upper HEX byte, Lower HEX byte will be updated
  1472 00:0FAC: A0 02                        LDY     #$02            ;Set index for 2 bytes
  1473 00:0FAE: 5A           ASCLOOP         PHY                     ;Save it to stack
  Sun Mar 30 2025  9:15                                                                                                    Page 33


  1474 00:0FAF: B5 9F                        LDA     INBUFF-1,X      ;Read ASCII digit from buffer
  1475 00:0FB1: A8                           TAY                     ;Xfer to Y Reg (LSD)
  1476 00:0FB2: CA                           DEX                     ;Decrement input count
  1477 00:0FB3: F0 04                        BEQ     NO_UPNB         ;Branch if no upper nibble
  1478 00:0FB5: B5 9F                        LDA     INBUFF-1,X      ;Read ASCII digit from buffer
  1479 00:0FB7: 80 02                        BRA     DO_UPNB         ;Branch to include upper nibble
  1480 00:0FB9: A9 30        NO_UPNB         LDA     #$30            ;Load ASCII "0" (MSD)
  1481 00:0FBB: 20 11 10     DO_UPNB         JSR     ASC2BIN         ;Convert ASCII digits to binary value
  1482 00:0FBE: 7A                           PLY                     ;Get index from stack
  1483 00:0FBF: 99 A3 00                     STA     HEXDATAH-1,Y    ;Write byte to indexed buffer location
  1484 00:0FC2: 8A                           TXA                     ;Check for zero, (no digits left)
  1485 00:0FC3: F0 04                        BEQ     HINDONE         ;If not, exit
  1486 00:0FC5: 88                           DEY                     ;Else, decrement to next byte set
  1487 00:0FC6: CA                           DEX                     ;Decrement index count
  1488 00:0FC7: D0 E5                        BNE     ASCLOOP         ;Loop back for next byte
  1489 00:0FC9: A4 A4        HINDONE         LDY     HEXDATAH        ;Get High Byte
  1490 00:0FCB: A5 A5                        LDA     HEXDATAL        ;Get Low Byte
  1491 00:0FCD: A6 B2                        LDX     BUFIDX          ;Get input count (set Z flag)
  1492 00:0FCF: 60           HINEXIT         RTS                     ;And return to caller
  1493                        ;;RDLINE subroutine: Store keystrokes into buffer until [RETURN] key is struck
  1494                        ; Used for Hex entry, so only (0-9,A-F) are accepted entries. Lower-case alpha characters
  1495                        ; are converted to upper-case. On entry, X Reg = buffer length. On exit, X Reg = buffer count
  1496                        ; [BACKSPACE] key removes keystrokes from buffer. [ESCAPE] key aborts then re-enters monitor.
  1497 00:0FD0: 86 B3        RDLINE_H        STX     BUFLEN          ;Store buffer length
  1498 00:0FD2: 64 B2                        STZ     BUFIDX          ;Zero buffer index
  1499 00:0FD4: 20 5E 0F     RDLOOP_H          JSR     RDCHAR          ;Get character from terminal, convert LC2UC
  1500 00:0FD7: C9 1B                        CMP     #$1B            ;Check for ESC key
  1501 00:0FD9: F0 33                        BEQ     RDNULL_H          ;If yes, exit back to Monitor
  1502 00:0FDB: C9 0D        NOTESC_H          CMP     #$0D            ;Check for C/R
  1503 00:0FDD: F0 2B                        BEQ     EXITRD_H          ;Exit if yes
  1504 00:0FDF: C9 08                        CMP     #$08            ;Check for Backspace
  1505 00:0FE1: F0 1C                        BEQ     RDBKSP_H          ;If yes handle backspace
  1506 00:0FE3: C9 30                        CMP     #$30            ;Check for '0' or higher
  1507 00:0FE5: 90 0A                        BCC     INPERR_H          ;Branch to error if less than '0'
  1508 00:0FE7: C9 47                        CMP     #$47            ;Check for 'G' ('F'+1)
  1509 00:0FE9: B0 06                        BCS     INPERR_H          ;Branch to error if 'G' or higher
  1510 00:0FEB: A6 B2                        LDX     BUFIDX          ;Get the current buffer index
  1511 00:0FED: E4 B3                        CPX     BUFLEN          ;Compare to length for space
  1512 00:0FEF: 90 05                        BCC     STRCHR_H          ;Branch to store in buffer
  1513 00:0FF1: 20 68 0F     INPERR_H          JSR     BEEP            ;Else, error, send Bell to terminal
  1514 00:0FF4: 80 DE                        BRA     RDLOOP_H          ;Branch back to RDLOOP
  1515 00:0FF6: 95 A0        STRCHR_H          STA     INBUFF,X        ;Store keystroke in buffer
  1516 00:0FF8: 20 21 FF                     JSR     B_CHROUT        ;Send keystroke to terminal
  1517 00:0FFB: E6 B2                        INC     BUFIDX          ;Increment buffer index
  1518 00:0FFD: 80 D5                        BRA     RDLOOP_H          ;Branch back to RDLOOP
  1519 00:0FFF: A5 B2        RDBKSP_H          LDA     BUFIDX          ;Check if buffer is empty
  1520 00:1001: F0 EE                        BEQ     INPERR_H          ;Branch if yes
  1521 00:1003: C6 B2                        DEC     BUFIDX          ;Else, decrement buffer index
  1522 00:1005: 20 72 0F                     JSR     BSOUT           ;Send Backspace to terminal
  1523 00:1008: 80 CA                        BRA     RDLOOP_H          ;Loop back and continue
  1524 00:100A: A6 B2        EXITRD_H          LDX     BUFIDX          ;Get keystroke count (Z flag)
  1525 00:100C: D0 C1                        BNE     HINEXIT         ;If data entered, normal exit
  1526 00:100E: 4C CE 0C     RDNULL_H        JMP     USER_INPUT      ;Go to main menu
  1527                        ;
  1528                        ;ASC2BIN subroutine: Convert 2 ASCII HEX digits to a binary (byte) value
  1529                        ; Enter: A Register = high digit, Y Register = low digit
  1530                        ; Return: A Register = binary value
  1531                        ; Updated routine via Mike Barry... saves 3 bytes, 10 clock cycles
  1532 00:1011: 64 B6        ASC2BIN         STZ     TEMP1           ;Clear TEMP1
  1533 00:1013: 20 1D 10                     JSR     BINARY          ;Convert high digit to 4-bit nibble
  1534 00:1016: 0A                           ASL     A               ;Shift to high nibble
  1535 00:1017: 0A                           ASL     A
  1536 00:1018: 0A                           ASL     A
  Sun Mar 30 2025  9:15                                                                                                    Page 34


  1537 00:1019: 0A                           ASL     A
  1538 00:101A: 85 B6                        STA     TEMP1           ;Store it in temp area
  1539 00:101C: 98                           TYA                     ;Get Low digit
  1540                        ;
  1541 00:101D: 49 30        BINARY          EOR     #$30            ;ASCII -> HEX nibble
  1542 00:101F: C9 0A                        CMP     #$0A            ;Check for result < 10
  1543 00:1021: 90 02                        BCC     BNOK            ;Branch if 0-9
  1544 00:1023: E9 67                        SBC     #$67            ;Else subtract for A-F
  1545 00:1025: 05 B6        BNOK            ORA     TEMP1           ;OR into temp value
  1546 00:1027: 60           RESERVED        RTS                     ;Return to caller
  1547                        ;
  1548                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
  1549                        ; Enter: A Register contains byte value to convert
  1550                        ; Return: A Register = high digit, Y Register = low digit
  1551 00:1028: 48           BIN2ASC         PHA                     ;Save A Reg on stack
  1552 00:1029: 29 0F                        AND     #$0F            ;Mask off high nibble
  1553 00:102B: 20 34 10                     JSR     ASCII           ;Convert nibble to ASCII HEX digit
  1554 00:102E: A8                           TAY                     ;Move to Y Reg
  1555 00:102F: 68                           PLA                     ;Get character back from stack
  1556 00:1030: 4A                           LSR     A               ;Shift high nibble to lower 4 bits
  1557 00:1031: 4A                           LSR     A
  1558 00:1032: 4A                           LSR     A
  1559 00:1033: 4A                           LSR     A
  1560                        ;
  1561 00:1034: C9 0A        ASCII           CMP     #$0A            ;Check for 10 or less
  1562 00:1036: 90 02                        BCC     ASCOK           ;Branch if less than 10
  1563 00:1038: 69 06                        ADC     #$06            ;Add $06+CF ($07) for A-F
  1564 00:103A: 69 30        ASCOK           ADC     #$30            ;Add $30 for ASCII
  1565 00:103C: 60                           RTS                     ;Return to caller
  1566                        ;
  1567                        ;Routines to output 8/16-bit Binary Data and ASCII characters
  1568                        ; PRASC subroutine: Print A-Reg as ASCII (Printable ASCII values = $20 - $7E), else print "."
  1569 00:103D: C9 7F        PRASC           CMP     #$7F            ;Check for first 128
  1570 00:103F: B0 04                        BCS     PERIOD          ;If = or higher, branch
  1571 00:1041: C9 20                        CMP     #$20            ;Check for control characters
  1572 00:1043: B0 02                        BCS     ASCOUT          ;If space or higher, branch and print
  1573 00:1045: A9 2E        PERIOD          LDA     #$2E            ;Else, print a "."
  1574 00:1047: 4C 21 FF     ASCOUT          JMP     B_CHROUT        ;Send byte in A-Reg, then return
  1575                        ;
  1576                        ;PRBYTE subroutine: Converts a single Byte to 2 HEX ASCII characters and sends to console on
  1577                        ; entry, A Reg contains the Byte to convert/send. Register contents are preserved on entry/exit.
  1578 00:104A: 48           PRBYTE          PHA                     ;Save A Register
  1579 00:104B: 5A                           PHY                     ;Save Y Register
  1580 00:104C: 20 28 10     PRBYT2          JSR     BIN2ASC         ;Convert A Reg to 2 ASCII Hex characters
  1581 00:104F: 20 21 FF                     JSR     B_CHROUT        ;Print high nibble from A Reg
  1582 00:1052: 98                           TYA                     ;Transfer low nibble to A Reg
  1583 00:1053: 20 21 FF                     JSR     B_CHROUT        ;Print low nibble from A Reg
  1584 00:1056: 7A                           PLY                     ;Restore Y Register
  1585 00:1057: 68                           PLA                     ;Restore A Register
  1586 00:1058: 60                           RTS                     ;Return to caller
  1587                        ;
  1588                        ;PRINDEX subroutine: Prints a $ sign followed by INDEXH/L
  1589 00:1059: 20 7D 0F     PRINDEX         JSR     DOLLAR          ;Print a $ sign
  1590 00:105C: A5 A8                        LDA     INDEXL          ;Get Index Low byte
  1591 00:105E: A4 A9                        LDY     INDEXH          ;Get Index High byte
  1592                        ;
  1593                        ;PRWORD subroutine: Converts a 16-bit word to 4 HEX ASCII characters and sends to console. On
  1594                        ; entry, A Reg contains Low Byte, Y Reg contains High Byte. Registers are preserved on entry/exit.
  1595                        ; NOTE: Routine changed for consistency; A Reg = Low byte, Y Reg = High byte on 2nd May 2020
  1596 00:1060: 48           PRWORD          PHA                     ;Save A Register (Low)
  1597 00:1061: 5A                           PHY                     ;Save Y Register (High)
  1598 00:1062: 48                           PHA                     ;Save Low byte again
  1599 00:1063: 98                           TYA                     ;Xfer High byte to A Reg
  Sun Mar 30 2025  9:15                                                                                                    Page 35


  1600 00:1064: 20 4A 10                     JSR     PRBYTE          ;Convert and print one HEX character (00-FF)
  1601 00:1067: 68                           PLA                     ;Get Low byte value
  1602 00:1068: 80 E2                        BRA     PRBYT2          ;Finish up Low Byte and exit
  1603                        ;
  1604                        ;Continue routine: called by commands to confirm execution, when No is confirmed, return address
  1605                        ;is removed from stack and the exit goes back to the Monitor input loop.
  1606                        ;Short version prompts for (Y/N) only.
  1607 00:106A: A9 ED        CONTINUE        LDA     #<SYS_CONT_MSG  ;Get Continue msg
  1608 00:106C: A0 1C                        LDY     #>SYS_CONT_MSG  ;
  1609 00:106E: 20 3F FF                     JSR     B_PROMPTR          ;Send to terminal
  1610 00:1071: 20 5E 0F     TRY_AGN         JSR     RDCHAR          ;Get keystroke from terminal
  1611 00:1074: C9 59                        CMP     #$59            ;"Y" key?
  1612 00:1076: F0 0D                        BEQ     DOCONT          ;If yes, continue/exit
  1613 00:1078: C9 4E                        CMP     #$4E            ;If "N", quit/exit
  1614 00:107A: F0 05                        BEQ     DONTCNT         ;Return if not ESC
  1615 00:107C: 20 68 0F                     JSR     BEEP            ;Send Beep to console
  1616 00:107F: 80 F0                        BRA     TRY_AGN         ;Loop back, try again
  1617 00:1081: 68           DONTCNT         PLA                     ;Else remove return address
  1618 00:1082: 68                           PLA                     ;and discard it
  1619 00:1083: 64 B8                        STZ     CMDFLAG         ;Clear all bits in command flag
  1620 00:1085: 60           DOCONT          RTS                     ;Return
  1621                        ;
  1622                        ; Utility Messages are defined here:
  1623                        ;
  1624                        INTRO_MSG
  1625 00:1086: 0D 0A                .DB     $0D,$0A
  1626 00:1088: 20 44 69 61          .DB     " Diagnostic and Test Utility for:",$0D,$0A
       00:108C: 67 6E 6F 73 
       00:1090: 74 69 63 20 
       00:1094: 61 6E 64 20 
       00:1098: 54 65 73 74 
       00:109C: 20 55 74 69 
       00:10A0: 6C 69 74 79 
       00:10A4: 20 66 6F 72 
       00:10A8: 3A 0D 0A 
  1627 00:10AB: 20 4D 69 63          .DB     " MicroDrive PATA Adapter, Version 0.90",$0D,$0A
       00:10AF: 72 6F 44 72 
       00:10B3: 69 76 65 20 
       00:10B7: 50 41 54 41 
       00:10BB: 20 41 64 61 
       00:10BF: 70 74 65 72 
       00:10C3: 2C 20 56 65 
       00:10C7: 72 73 69 6F 
       00:10CB: 6E 20 30 2E 
       00:10CF: 39 30 0D 0A 
  1628 00:10D3: 20 43 6F 70          .DB     " Copyright 2022-2025 by K.E. Maier",$0D,$0A
       00:10D7: 79 72 69 67 
       00:10DB: 68 74 20 32 
       00:10DF: 30 32 32 2D 
       00:10E3: 32 30 32 35 
       00:10E7: 20 62 79 20 
       00:10EB: 4B 2E 45 2E 
       00:10EF: 20 4D 61 69 
       00:10F3: 65 72 0D 0A 
  1629 00:10F7: 00                   .DB     $00
  1630                        ;
  1631                        MENU_MSG
  1632 00:10F8: 0D 0A                .DB     $0D,$0A
  1633 00:10FA: 20 2A 2A 2A          .DB     " ***************************************************************************** ",$0D,$
                    0A
       00:10FE: 2A 2A 2A 2A 
       00:1102: 2A 2A 2A 2A 
       00:1106: 2A 2A 2A 2A 
  Sun Mar 30 2025  9:15                                                                                                    Page 36


       00:110A: 2A 2A 2A 2A 
       00:110E: 2A 2A 2A 2A 
       00:1112: 2A 2A 2A 2A 
       00:1116: 2A 2A 2A 2A 
       00:111A: 2A 2A 2A 2A 
       00:111E: 2A 2A 2A 2A 
       00:1122: 2A 2A 2A 2A 
       00:1126: 2A 2A 2A 2A 
       00:112A: 2A 2A 2A 2A 
       00:112E: 2A 2A 2A 2A 
       00:1132: 2A 2A 2A 2A 
       00:1136: 2A 2A 2A 2A 
       00:113A: 2A 2A 2A 2A 
       00:113E: 2A 2A 2A 2A 
       00:1142: 2A 2A 2A 2A 
       00:1146: 2A 2A 20 0D 
       00:114A: 0A 
  1634 00:114B: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:114F: 20 20 20 20 
       00:1153: 20 20 20 20 
       00:1157: 20 20 20 20 
       00:115B: 20 20 20 20 
       00:115F: 20 20 20 20 
       00:1163: 20 20 20 20 
       00:1167: 20 20 20 20 
       00:116B: 20 20 20 20 
       00:116F: 20 20 20 20 
       00:1173: 20 20 20 20 
       00:1177: 20 20 20 20 
       00:117B: 20 20 20 20 
       00:117F: 20 20 20 20 
       00:1183: 20 20 20 20 
       00:1187: 20 20 20 20 
       00:118B: 20 20 20 20 
       00:118F: 20 20 20 20 
       00:1193: 20 20 20 20 
       00:1197: 20 2A 20 0D 
       00:119B: 0A 
  1635 00:119C: 20 2A 20 20          .DB     " *          MicroDrive (IDE) Functions:                                      * ",$0D,$
                    0A
       00:11A0: 20 20 20 20 
       00:11A4: 20 20 20 20 
       00:11A8: 4D 69 63 72 
       00:11AC: 6F 44 72 69 
       00:11B0: 76 65 20 28 
       00:11B4: 49 44 45 29 
       00:11B8: 20 46 75 6E 
       00:11BC: 63 74 69 6F 
       00:11C0: 6E 73 3A 20 
       00:11C4: 20 20 20 20 
       00:11C8: 20 20 20 20 
       00:11CC: 20 20 20 20 
       00:11D0: 20 20 20 20 
       00:11D4: 20 20 20 20 
       00:11D8: 20 20 20 20 
       00:11DC: 20 20 20 20 
       00:11E0: 20 20 20 20 
       00:11E4: 20 20 20 20 
       00:11E8: 20 2A 20 0D 
       00:11EC: 0A 
  1636 00:11ED: 20 2A 20 20          .DB     " *             4- Identify Drive information                                 * ",$0D,$
                    0A
  Sun Mar 30 2025  9:15                                                                                                    Page 37


       00:11F1: 20 20 20 20 
       00:11F5: 20 20 20 20 
       00:11F9: 20 20 20 34 
       00:11FD: 2D 20 49 64 
       00:1201: 65 6E 74 69 
       00:1205: 66 79 20 44 
       00:1209: 72 69 76 65 
       00:120D: 20 69 6E 66 
       00:1211: 6F 72 6D 61 
       00:1215: 74 69 6F 6E 
       00:1219: 20 20 20 20 
       00:121D: 20 20 20 20 
       00:1221: 20 20 20 20 
       00:1225: 20 20 20 20 
       00:1229: 20 20 20 20 
       00:122D: 20 20 20 20 
       00:1231: 20 20 20 20 
       00:1235: 20 20 20 20 
       00:1239: 20 2A 20 0D 
       00:123D: 0A 
  1637 00:123E: 20 2A 20 20          .DB     " *             5- Read a LBA to Memory and Display                           * ",$0D,$
                    0A
       00:1242: 20 20 20 20 
       00:1246: 20 20 20 20 
       00:124A: 20 20 20 35 
       00:124E: 2D 20 52 65 
       00:1252: 61 64 20 61 
       00:1256: 20 4C 42 41 
       00:125A: 20 74 6F 20 
       00:125E: 4D 65 6D 6F 
       00:1262: 72 79 20 61 
       00:1266: 6E 64 20 44 
       00:126A: 69 73 70 6C 
       00:126E: 61 79 20 20 
       00:1272: 20 20 20 20 
       00:1276: 20 20 20 20 
       00:127A: 20 20 20 20 
       00:127E: 20 20 20 20 
       00:1282: 20 20 20 20 
       00:1286: 20 20 20 20 
       00:128A: 20 2A 20 0D 
       00:128E: 0A 
  1638 00:128F: 20 2A 20 20          .DB     " *             6- Write a LBA from Memory and Verify                         * ",$0D,$
                    0A
       00:1293: 20 20 20 20 
       00:1297: 20 20 20 20 
       00:129B: 20 20 20 36 
       00:129F: 2D 20 57 72 
       00:12A3: 69 74 65 20 
       00:12A7: 61 20 4C 42 
       00:12AB: 41 20 66 72 
       00:12AF: 6F 6D 20 4D 
       00:12B3: 65 6D 6F 72 
       00:12B7: 79 20 61 6E 
       00:12BB: 64 20 56 65 
       00:12BF: 72 69 66 79 
       00:12C3: 20 20 20 20 
       00:12C7: 20 20 20 20 
       00:12CB: 20 20 20 20 
       00:12CF: 20 20 20 20 
       00:12D3: 20 20 20 20 
       00:12D7: 20 20 20 20 
       00:12DB: 20 2A 20 0D 
  Sun Mar 30 2025  9:15                                                                                                    Page 38


       00:12DF: 0A 
  1639 00:12E0: 20 2A 20 20          .DB     " *             7- Sequential Read all LBA                                    * ",$0D,$
                    0A
       00:12E4: 20 20 20 20 
       00:12E8: 20 20 20 20 
       00:12EC: 20 20 20 37 
       00:12F0: 2D 20 53 65 
       00:12F4: 71 75 65 6E 
       00:12F8: 74 69 61 6C 
       00:12FC: 20 52 65 61 
       00:1300: 64 20 61 6C 
       00:1304: 6C 20 4C 42 
       00:1308: 41 20 20 20 
       00:130C: 20 20 20 20 
       00:1310: 20 20 20 20 
       00:1314: 20 20 20 20 
       00:1318: 20 20 20 20 
       00:131C: 20 20 20 20 
       00:1320: 20 20 20 20 
       00:1324: 20 20 20 20 
       00:1328: 20 20 20 20 
       00:132C: 20 2A 20 0D 
       00:1330: 0A 
  1640 00:1331: 20 2A 20 20          .DB     " *             8- Sequential Write all LBA                                   * ",$0D,$
                    0A
       00:1335: 20 20 20 20 
       00:1339: 20 20 20 20 
       00:133D: 20 20 20 38 
       00:1341: 2D 20 53 65 
       00:1345: 71 75 65 6E 
       00:1349: 74 69 61 6C 
       00:134D: 20 57 72 69 
       00:1351: 74 65 20 61 
       00:1355: 6C 6C 20 4C 
       00:1359: 42 41 20 20 
       00:135D: 20 20 20 20 
       00:1361: 20 20 20 20 
       00:1365: 20 20 20 20 
       00:1369: 20 20 20 20 
       00:136D: 20 20 20 20 
       00:1371: 20 20 20 20 
       00:1375: 20 20 20 20 
       00:1379: 20 20 20 20 
       00:137D: 20 2A 20 0D 
       00:1381: 0A 
  1641 00:1382: 20 2A 20 20          .DB     " *             9- Benchmark for LBA Read or Write                            * ",$0D,$
                    0A
       00:1386: 20 20 20 20 
       00:138A: 20 20 20 20 
       00:138E: 20 20 20 39 
       00:1392: 2D 20 42 65 
       00:1396: 6E 63 68 6D 
       00:139A: 61 72 6B 20 
       00:139E: 66 6F 72 20 
       00:13A2: 4C 42 41 20 
       00:13A6: 52 65 61 64 
       00:13AA: 20 6F 72 20 
       00:13AE: 57 72 69 74 
       00:13B2: 65 20 20 20 
       00:13B6: 20 20 20 20 
       00:13BA: 20 20 20 20 
       00:13BE: 20 20 20 20 
       00:13C2: 20 20 20 20 
  Sun Mar 30 2025  9:15                                                                                                    Page 39


       00:13C6: 20 20 20 20 
       00:13CA: 20 20 20 20 
       00:13CE: 20 2A 20 0D 
       00:13D2: 0A 
  1642 00:13D3: 20 2A 20 20          .DB     " *             S- System Transfer (Memory to Disc)                           * ",$0D,$
                    0A
       00:13D7: 20 20 20 20 
       00:13DB: 20 20 20 20 
       00:13DF: 20 20 20 53 
       00:13E3: 2D 20 53 79 
       00:13E7: 73 74 65 6D 
       00:13EB: 20 54 72 61 
       00:13EF: 6E 73 66 65 
       00:13F3: 72 20 28 4D 
       00:13F7: 65 6D 6F 72 
       00:13FB: 79 20 74 6F 
       00:13FF: 20 44 69 73 
       00:1403: 63 29 20 20 
       00:1407: 20 20 20 20 
       00:140B: 20 20 20 20 
       00:140F: 20 20 20 20 
       00:1413: 20 20 20 20 
       00:1417: 20 20 20 20 
       00:141B: 20 20 20 20 
       00:141F: 20 2A 20 0D 
       00:1423: 0A 
  1643 00:1424: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:1428: 20 20 20 20 
       00:142C: 20 20 20 20 
       00:1430: 20 20 20 20 
       00:1434: 20 20 20 20 
       00:1438: 20 20 20 20 
       00:143C: 20 20 20 20 
       00:1440: 20 20 20 20 
       00:1444: 20 20 20 20 
       00:1448: 20 20 20 20 
       00:144C: 20 20 20 20 
       00:1450: 20 20 20 20 
       00:1454: 20 20 20 20 
       00:1458: 20 20 20 20 
       00:145C: 20 20 20 20 
       00:1460: 20 20 20 20 
       00:1464: 20 20 20 20 
       00:1468: 20 20 20 20 
       00:146C: 20 20 20 20 
       00:1470: 20 2A 20 0D 
       00:1474: 0A 
  1644 00:1475: 20 2A 20 20          .DB     " *             Q- Quit, return to DOS/65                                     * ",$0D,$
                    0A
       00:1479: 20 20 20 20 
       00:147D: 20 20 20 20 
       00:1481: 20 20 20 51 
       00:1485: 2D 20 51 75 
       00:1489: 69 74 2C 20 
       00:148D: 72 65 74 75 
       00:1491: 72 6E 20 74 
       00:1495: 6F 20 44 4F 
       00:1499: 53 2F 36 35 
       00:149D: 20 20 20 20 
       00:14A1: 20 20 20 20 
       00:14A5: 20 20 20 20 
       00:14A9: 20 20 20 20 
  Sun Mar 30 2025  9:15                                                                                                    Page 40


       00:14AD: 20 20 20 20 
       00:14B1: 20 20 20 20 
       00:14B5: 20 20 20 20 
       00:14B9: 20 20 20 20 
       00:14BD: 20 20 20 20 
       00:14C1: 20 2A 20 0D 
       00:14C5: 0A 
  1645 00:14C6: 20 2A 20 20          .DB     " *                                                                           * ",$0D,$
                    0A
       00:14CA: 20 20 20 20 
       00:14CE: 20 20 20 20 
       00:14D2: 20 20 20 20 
       00:14D6: 20 20 20 20 
       00:14DA: 20 20 20 20 
       00:14DE: 20 20 20 20 
       00:14E2: 20 20 20 20 
       00:14E6: 20 20 20 20 
       00:14EA: 20 20 20 20 
       00:14EE: 20 20 20 20 
       00:14F2: 20 20 20 20 
       00:14F6: 20 20 20 20 
       00:14FA: 20 20 20 20 
       00:14FE: 20 20 20 20 
       00:1502: 20 20 20 20 
       00:1506: 20 20 20 20 
       00:150A: 20 20 20 20 
       00:150E: 20 20 20 20 
       00:1512: 20 2A 20 0D 
       00:1516: 0A 
  1646 00:1517: 20 2A 2A 2A          .DB     " ***************************************************************************** ",$0D,$
                    0A,$0A
       00:151B: 2A 2A 2A 2A 
       00:151F: 2A 2A 2A 2A 
       00:1523: 2A 2A 2A 2A 
       00:1527: 2A 2A 2A 2A 
       00:152B: 2A 2A 2A 2A 
       00:152F: 2A 2A 2A 2A 
       00:1533: 2A 2A 2A 2A 
       00:1537: 2A 2A 2A 2A 
       00:153B: 2A 2A 2A 2A 
       00:153F: 2A 2A 2A 2A 
       00:1543: 2A 2A 2A 2A 
       00:1547: 2A 2A 2A 2A 
       00:154B: 2A 2A 2A 2A 
       00:154F: 2A 2A 2A 2A 
       00:1553: 2A 2A 2A 2A 
       00:1557: 2A 2A 2A 2A 
       00:155B: 2A 2A 2A 2A 
       00:155F: 2A 2A 2A 2A 
       00:1563: 2A 2A 20 0D 
       00:1567: 0A 0A 
  1647 00:1569: 20 20 20 20          .DB     "     Enter Command to continue: "
       00:156D: 20 45 6E 74 
       00:1571: 65 72 20 43 
       00:1575: 6F 6D 6D 61 
       00:1579: 6E 64 20 74 
       00:157D: 6F 20 63 6F 
       00:1581: 6E 74 69 6E 
       00:1585: 75 65 3A 20 
  1648 00:1589: 00                   .DB     $00
  1649                        ;
  1650                        QUIT_MSG
  1651 00:158A: 0D 0A 0A             .DB     $0D,$0A,$0A
  Sun Mar 30 2025  9:15                                                                                                    Page 41


  1652 00:158D: 20 52 65 74          .DB     " Returning to DOS/65."
       00:1591: 75 72 6E 69 
       00:1595: 6E 67 20 74 
       00:1599: 6F 20 44 4F 
       00:159D: 53 2F 36 35 
       00:15A1: 2E 
  1653 00:15A2: 0D 0A                .DB     $0D,$0A
  1654 00:15A4: 00                   .DB     $00
  1655                        ;
  1656                        USER_INMSG
  1657 00:15A5: 0D 0A 0A             .DB     $0D,$0A,$0A
  1658 00:15A8: 20 45 6E 74          .DB     " Enter Command or M for Menu."
       00:15AC: 65 72 20 43 
       00:15B0: 6F 6D 6D 61 
       00:15B4: 6E 64 20 6F 
       00:15B8: 72 20 4D 20 
       00:15BC: 66 6F 72 20 
       00:15C0: 4D 65 6E 75 
       00:15C4: 2E 
  1659 00:15C5: 0D 0A                .DB     $0D,$0A
  1660 00:15C7: 00                   .DB     $00
  1661                        ;
  1662                        DRIVE_IDENTITY
  1663 00:15C8: 0D 0A 0A             .DB     $0D,$0A,$0A
  1664 00:15CB: 20 4D 69 63          .DB     " MicroDrive Information:"
       00:15CF: 72 6F 44 72 
       00:15D3: 69 76 65 20 
       00:15D7: 49 6E 66 6F 
       00:15DB: 72 6D 61 74 
       00:15DF: 69 6F 6E 3A 
  1665 00:15E3: 0D 0A                .DB     $0D,$0A
  1666 00:15E5: 00                   .DB     $00
  1667                        ;
  1668                        MODEL_NUM
  1669 00:15E6: 0D 0A                .DB     $0D,$0A
  1670 00:15E8: 20 4D 6F 64          .DB     " Model Number: "
       00:15EC: 65 6C 20 4E 
       00:15F0: 75 6D 62 65 
       00:15F4: 72 3A 20 
  1671 00:15F7: 00                   .DB     $00
  1672                        ;
  1673                        SERIAL_NUM
  1674 00:15F8: 0D 0A                .DB     $0D,$0A
  1675 00:15FA: 20 53 65 72          .DB     " Serial Number: "
       00:15FE: 69 61 6C 20 
       00:1602: 4E 75 6D 62 
       00:1606: 65 72 3A 20 
  1676 00:160A: 00                   .DB     $00
  1677                        ;
  1678                        FIRM_REV
  1679 00:160B: 0D 0A                .DB     $0D,$0A
  1680 00:160D: 20 46 69 72          .DB     " Firmware Revision: "
       00:1611: 6D 77 61 72 
       00:1615: 65 20 52 65 
       00:1619: 76 69 73 69 
       00:161D: 6F 6E 3A 20 
  1681 00:1621: 00                   .DB     $00
  1682                        ;
  1683                        MODE_SUPPORT
  1684 00:1622: 0D 0A                .DB     $0D,$0A
  1685 00:1624: 20 4C 42 41          .DB     " LBA Mode Supported: "
       00:1628: 20 4D 6F 64 
       00:162C: 65 20 53 75 
  Sun Mar 30 2025  9:15                                                                                                    Page 42


       00:1630: 70 70 6F 72 
       00:1634: 74 65 64 3A 
       00:1638: 20 
  1686 00:1639: 00                   .DB     $00
  1687                        TOTAL_LBA
  1688 00:163A: 0D 0A                .DB     $0D,$0A
  1689 00:163C: 20 54 6F 74          .DB     " Total LBA Count: "
       00:1640: 61 6C 20 4C 
       00:1644: 42 41 20 43 
       00:1648: 6F 75 6E 74 
       00:164C: 3A 20 
  1690 00:164E: 00                   .DB     $00
  1691                        ;
  1692                        LBA_INPUT
  1693 00:164F: 0D 0A                .DB     $0D,$0A
  1694 00:1651: 20 45 6E 74          .DB     " Enter LBA number to Read from: "
       00:1655: 65 72 20 4C 
       00:1659: 42 41 20 6E 
       00:165D: 75 6D 62 65 
       00:1661: 72 20 74 6F 
       00:1665: 20 52 65 61 
       00:1669: 64 20 66 72 
       00:166D: 6F 6D 3A 20 
  1695 00:1671: 00                   .DB     $00
  1696                        ;
  1697                        LBA_OUTPUT
  1698 00:1672: 0D 0A                .DB     $0D,$0A
  1699 00:1674: 20 45 6E 74          .DB     " Enter LBA number to Write to: "
       00:1678: 65 72 20 4C 
       00:167C: 42 41 20 6E 
       00:1680: 75 6D 62 65 
       00:1684: 72 20 74 6F 
       00:1688: 20 57 72 69 
       00:168C: 74 65 20 74 
       00:1690: 6F 3A 20 
  1700 00:1693: 00                   .DB     $00
  1701                        ;
  1702                        LBA_START
  1703 00:1694: 0D 0A                .DB     $0D,$0A
  1704 00:1696: 20 45 6E 74          .DB     " Enter starting LBA number: "
       00:169A: 65 72 20 73 
       00:169E: 74 61 72 74 
       00:16A2: 69 6E 67 20 
       00:16A6: 4C 42 41 20 
       00:16AA: 6E 75 6D 62 
       00:16AE: 65 72 3A 20 
  1705 00:16B2: 00                   .DB     $00
  1706                        ;
  1707                        LBA_WR_DATA
  1708 00:16B3: 0D 0A                .DB     $0D,$0A
  1709 00:16B5: 20 41 62 6F          .DB     " About to write LBA from buffer Data below!"
       00:16B9: 75 74 20 74 
       00:16BD: 6F 20 77 72 
       00:16C1: 69 74 65 20 
       00:16C5: 4C 42 41 20 
       00:16C9: 66 72 6F 6D 
       00:16CD: 20 62 75 66 
       00:16D1: 66 65 72 20 
       00:16D5: 44 61 74 61 
       00:16D9: 20 62 65 6C 
       00:16DD: 6F 77 21 
  1710 00:16E0: 0D 0A                .DB     $0D,$0A
  1711 00:16E2: 00                   .DB     $00
  Sun Mar 30 2025  9:15                                                                                                    Page 43


  1712                        ;
  1713                        LBA_WR_CNFM
  1714 00:16E3: 0D 0A                .DB     $0D,$0A
  1715 00:16E5: 20 41 72 65          .DB     " Are you SURE you want to overwrite the LBA?"
       00:16E9: 20 79 6F 75 
       00:16ED: 20 53 55 52 
       00:16F1: 45 20 79 6F 
       00:16F5: 75 20 77 61 
       00:16F9: 6E 74 20 74 
       00:16FD: 6F 20 6F 76 
       00:1701: 65 72 77 72 
       00:1705: 69 74 65 20 
       00:1709: 74 68 65 20 
       00:170D: 4C 42 41 3F 
  1716 00:1711: 00                   .DB     $00
  1717                        ;
  1718                        NEXT_LBA
  1719 00:1712: 0D 0A                .DB     $0D,$0A
  1720 00:1714: 20 44 69 73          .DB     " Display (N)ext LBA or (R)eturn "
       00:1718: 70 6C 61 79 
       00:171C: 20 28 4E 29 
       00:1720: 65 78 74 20 
       00:1724: 4C 42 41 20 
       00:1728: 6F 72 20 28 
       00:172C: 52 29 65 74 
       00:1730: 75 72 6E 20 
  1721 00:1734: 00                   .DB     $00
  1722                        ;
  1723                        SHOW_NEXT_LBA
  1724 00:1735: 0D 0A 0A             .DB     $0D,$0A,$0A
  1725 00:1738: 20 44 69 73          .DB     " Displaying Data for LBA: "
       00:173C: 70 6C 61 79 
       00:1740: 69 6E 67 20 
       00:1744: 44 61 74 61 
       00:1748: 20 66 6F 72 
       00:174C: 20 4C 42 41 
       00:1750: 3A 20 
  1726 00:1752: 00                   .DB     $00
  1727                        ;
  1728                        LBA_SEQ_RD_MSG
  1729 00:1753: 0D 0A 0A             .DB     $0D,$0A,$0A
  1730 00:1756: 20 41 62 6F          .DB     " About to read ALL LBAs from MicroDrive!"
       00:175A: 75 74 20 74 
       00:175E: 6F 20 72 65 
       00:1762: 61 64 20 41 
       00:1766: 4C 4C 20 4C 
       00:176A: 42 41 73 20 
       00:176E: 66 72 6F 6D 
       00:1772: 20 4D 69 63 
       00:1776: 72 6F 44 72 
       00:177A: 69 76 65 21 
  1731 00:177E: 0D 0A                .DB     $0D,$0A
  1732 00:1780: 00                   .DB     $00
  1733                        ;
  1734                        LBA_SEQ_WR_MSG
  1735 00:1781: 0D 0A 0A             .DB     $0D,$0A,$0A
  1736 00:1784: 20 41 62 6F          .DB     " About to write ALL LBAs to MicroDrive!"
       00:1788: 75 74 20 74 
       00:178C: 6F 20 77 72 
       00:1790: 69 74 65 20 
       00:1794: 41 4C 4C 20 
       00:1798: 4C 42 41 73 
       00:179C: 20 74 6F 20 
  Sun Mar 30 2025  9:15                                                                                                    Page 44


       00:17A0: 4D 69 63 72 
       00:17A4: 6F 44 72 69 
       00:17A8: 76 65 21 
  1737 00:17AB: 0D 0A                .DB     $0D,$0A
  1738 00:17AD: 00                   .DB     $00
  1739                        ;
  1740                        LBA_SEQ_TM_MSG
  1741 00:17AE: 20 43 6F 6D          .DB     " Completion time based on drive capacity."
       00:17B2: 70 6C 65 74 
       00:17B6: 69 6F 6E 20 
       00:17BA: 74 69 6D 65 
       00:17BE: 20 62 61 73 
       00:17C2: 65 64 20 6F 
       00:17C6: 6E 20 64 72 
       00:17CA: 69 76 65 20 
       00:17CE: 63 61 70 61 
       00:17D2: 63 69 74 79 
       00:17D6: 2E 
  1742 00:17D7: 0D 0A                .DB     $0D,$0A
  1743 00:17D9: 00                   .DB     $00
  1744                        
  1745                        LBA_SEQ_CFM
  1746 00:17DA: 0D 0A                .DB     $0D,$0A
  1747 00:17DC: 20 41 72 65          .DB     " Are you sure you want to"
       00:17E0: 20 79 6F 75 
       00:17E4: 20 73 75 72 
       00:17E8: 65 20 79 6F 
       00:17EC: 75 20 77 61 
       00:17F0: 6E 74 20 74 
       00:17F4: 6F 
  1748 00:17F5: 00                   .DB     $00
  1749                        ;
  1750                        LBA_SEQ_CFM2
  1751 00:17F6: 0D 0A                .DB     $0D,$0A
  1752 00:17F8: 20 41 72 65          .DB     " Are you REALLY sure you want to"
       00:17FC: 20 79 6F 75 
       00:1800: 20 52 45 41 
       00:1804: 4C 4C 59 20 
       00:1808: 73 75 72 65 
       00:180C: 20 79 6F 75 
       00:1810: 20 77 61 6E 
       00:1814: 74 20 74 6F 
  1753 00:1818: 00                   .DB     $00
  1754                        ;
  1755                        LBA_BLKS_RD
  1756 00:1819: 0D 0A                .DB     $0D,$0A
  1757 00:181B: 42 6C 6F 63          .DB     "Blocks Read:"
       00:181F: 6B 73 20 52 
       00:1823: 65 61 64 3A 
  1758 00:1827: 0D 0A 00             .DB     $0D,$0A,$00
  1759                        ;
  1760                        LBA_BLKS_WR
  1761 00:182A: 0D 0A                .DB     $0D,$0A
  1762 00:182C: 42 6C 6F 63          .DB     "Blocks Written:"
       00:1830: 6B 73 20 57 
       00:1834: 72 69 74 74 
       00:1838: 65 6E 3A 
  1763 00:183B: 0D 0A 00             .DB     $0D,$0A,$00
  1764                        ;
  1765                        LBA_BLKS_RD_CMP
  1766 00:183E: 0D 0A                .DB     $0D,$0A
  1767 00:1840: 20 41 6C 6C          .DB     " All LBAs have been successfully read!"
       00:1844: 20 4C 42 41 
  Sun Mar 30 2025  9:15                                                                                                    Page 45


       00:1848: 73 20 68 61 
       00:184C: 76 65 20 62 
       00:1850: 65 65 6E 20 
       00:1854: 73 75 63 63 
       00:1858: 65 73 73 66 
       00:185C: 75 6C 6C 79 
       00:1860: 20 72 65 61 
       00:1864: 64 21 
  1768 00:1866: 0D 0A                .DB     $0D,$0A
  1769 00:1868: 00                   .DB     $00
  1770                        ;
  1771                        LBA_BLKS_WR_CMP
  1772 00:1869: 0D 0A                .DB     $0D,$0A
  1773 00:186B: 20 41 6C 6C          .DB     " All LBAs have been successfully written!"
       00:186F: 20 4C 42 41 
       00:1873: 73 20 68 61 
       00:1877: 76 65 20 62 
       00:187B: 65 65 6E 20 
       00:187F: 73 75 63 63 
       00:1883: 65 73 73 66 
       00:1887: 75 6C 6C 79 
       00:188B: 20 77 72 69 
       00:188F: 74 74 65 6E 
       00:1893: 21 
  1774 00:1894: 0D 0A                .DB     $0D,$0A
  1775 00:1896: 00                   .DB     $00
  1776                        ;
  1777                        PATTERN_MSG
  1778 00:1897: 0D 0A                .DB     $0D,$0A
  1779 00:1899: 20 45 6E 74          .DB     " Enter a 16-bit Hex value for the Fill Pattern: "
       00:189D: 65 72 20 61 
       00:18A1: 20 31 36 2D 
       00:18A5: 62 69 74 20 
       00:18A9: 48 65 78 20 
       00:18AD: 76 61 6C 75 
       00:18B1: 65 20 66 6F 
       00:18B5: 72 20 74 68 
       00:18B9: 65 20 46 69 
       00:18BD: 6C 6C 20 50 
       00:18C1: 61 74 74 65 
       00:18C5: 72 6E 3A 20 
  1780 00:18C9: 00                   .DB     $00
  1781                        ;
  1782                        LBA_BENCH_INTRO
  1783 00:18CA: 0D 0A 0A             .DB     $0D,$0A,$0A
  1784 00:18CD: 20 42 65 6E          .DB     " Benchmark Performance Testing to Read or Write",$0D,$0A
       00:18D1: 63 68 6D 61 
       00:18D5: 72 6B 20 50 
       00:18D9: 65 72 66 6F 
       00:18DD: 72 6D 61 6E 
       00:18E1: 63 65 20 54 
       00:18E5: 65 73 74 69 
       00:18E9: 6E 67 20 74 
       00:18ED: 6F 20 52 65 
       00:18F1: 61 64 20 6F 
       00:18F5: 72 20 57 72 
       00:18F9: 69 74 65 0D 
       00:18FD: 0A 
  1785 00:18FE: 20 61 20 31          .DB     " a 16MB contiguous block of data starting from",$0D,$0A
       00:1902: 36 4D 42 20 
       00:1906: 63 6F 6E 74 
       00:190A: 69 67 75 6F 
       00:190E: 75 73 20 62 
  Sun Mar 30 2025  9:15                                                                                                    Page 46


       00:1912: 6C 6F 63 6B 
       00:1916: 20 6F 66 20 
       00:191A: 64 61 74 61 
       00:191E: 20 73 74 61 
       00:1922: 72 74 69 6E 
       00:1926: 67 20 66 72 
       00:192A: 6F 6D 0D 0A 
  1786 00:192E: 20 74 68 65          .DB     " the entered LBA address.",$0D,$0A,$0A
       00:1932: 20 65 6E 74 
       00:1936: 65 72 65 64 
       00:193A: 20 4C 42 41 
       00:193E: 20 61 64 64 
       00:1942: 72 65 73 73 
       00:1946: 2E 0D 0A 0A 
  1787 00:194A: 20 54 68 65          .DB     " The Write Benchmark requires a 16-bit Hex fill pattern.",$0D,$0A
       00:194E: 20 57 72 69 
       00:1952: 74 65 20 42 
       00:1956: 65 6E 63 68 
       00:195A: 6D 61 72 6B 
       00:195E: 20 72 65 71 
       00:1962: 75 69 72 65 
       00:1966: 73 20 61 20 
       00:196A: 31 36 2D 62 
       00:196E: 69 74 20 48 
       00:1972: 65 78 20 66 
       00:1976: 69 6C 6C 20 
       00:197A: 70 61 74 74 
       00:197E: 65 72 6E 2E 
       00:1982: 0D 0A 
  1788 00:1984: 20 4E 6F 74          .DB     " Note: the Write Benchmark will result in",$0D,$0A
       00:1988: 65 3A 20 74 
       00:198C: 68 65 20 57 
       00:1990: 72 69 74 65 
       00:1994: 20 42 65 6E 
       00:1998: 63 68 6D 61 
       00:199C: 72 6B 20 77 
       00:19A0: 69 6C 6C 20 
       00:19A4: 72 65 73 75 
       00:19A8: 6C 74 20 69 
       00:19AC: 6E 0D 0A 
  1789 00:19AF: 20 4C 4F 53          .DB     " LOSS of DATA on the MicroDrive being tested!",$0D,$0A,$0A
       00:19B3: 53 20 6F 66 
       00:19B7: 20 44 41 54 
       00:19BB: 41 20 6F 6E 
       00:19BF: 20 74 68 65 
       00:19C3: 20 4D 69 63 
       00:19C7: 72 6F 44 72 
       00:19CB: 69 76 65 20 
       00:19CF: 62 65 69 6E 
       00:19D3: 67 20 74 65 
       00:19D7: 73 74 65 64 
       00:19DB: 21 0D 0A 0A 
  1790 00:19DF: 20 4D 61 6B          .DB     " Make sure you know what you are doing!",$0D,$0A,$0A
       00:19E3: 65 20 73 75 
       00:19E7: 72 65 20 79 
       00:19EB: 6F 75 20 6B 
       00:19EF: 6E 6F 77 20 
       00:19F3: 77 68 61 74 
       00:19F7: 20 79 6F 75 
       00:19FB: 20 61 72 65 
       00:19FF: 20 64 6F 69 
       00:1A03: 6E 67 21 0D 
       00:1A07: 0A 0A 
  Sun Mar 30 2025  9:15                                                                                                    Page 47


  1791 00:1A09: 20 45 6E 74          .DB     " Enter 'R' for Read or 'W' for Write: "
       00:1A0D: 65 72 20 27 
       00:1A11: 52 27 20 66 
       00:1A15: 6F 72 20 52 
       00:1A19: 65 61 64 20 
       00:1A1D: 6F 72 20 27 
       00:1A21: 57 27 20 66 
       00:1A25: 6F 72 20 57 
       00:1A29: 72 69 74 65 
       00:1A2D: 3A 20 
  1792 00:1A2F: 00                   .DB     $00
  1793                        ;
  1794                        LBA_RD_BENCH
  1795 00:1A30: 0D 0A 0A             .DB     $0D,$0A,$0A
  1796 00:1A33: 20 52 65 61          .DB     " Reading 16MB of LBA data in: "
       00:1A37: 64 69 6E 67 
       00:1A3B: 20 31 36 4D 
       00:1A3F: 42 20 6F 66 
       00:1A43: 20 4C 42 41 
       00:1A47: 20 64 61 74 
       00:1A4B: 61 20 69 6E 
       00:1A4F: 3A 20 
  1797 00:1A51: 00                   .DB     $00
  1798                        ;
  1799                        LBA_WR_BENCH
  1800 00:1A52: 0D 0A 0A             .DB     $0D,$0A,$0A
  1801 00:1A55: 20 57 72 69          .DB     " Writing 16MB of LBA data in: "
       00:1A59: 74 69 6E 67 
       00:1A5D: 20 31 36 4D 
       00:1A61: 42 20 6F 66 
       00:1A65: 20 4C 42 41 
       00:1A69: 20 64 61 74 
       00:1A6D: 61 20 69 6E 
       00:1A71: 3A 20 
  1802 00:1A73: 00                   .DB     $00
  1803                        ;
  1804                        LBA_BENCH_WARN
  1805 00:1A74: 0D 0A 0A             .DB     $0D,$0A,$0A
  1806 00:1A77: 20 59 6F 75          .DB     " You are about to Write 32,768 LBAs!",$0D,$0A
       00:1A7B: 20 61 72 65 
       00:1A7F: 20 61 62 6F 
       00:1A83: 75 74 20 74 
       00:1A87: 6F 20 57 72 
       00:1A8B: 69 74 65 20 
       00:1A8F: 33 32 2C 37 
       00:1A93: 36 38 20 4C 
       00:1A97: 42 41 73 21 
       00:1A9B: 0D 0A 
  1807 00:1A9D: 20 41 6C 6C          .DB     " All Data from starting LBA will be overwritten!",$0D,$0A
       00:1AA1: 20 44 61 74 
       00:1AA5: 61 20 66 72 
       00:1AA9: 6F 6D 20 73 
       00:1AAD: 74 61 72 74 
       00:1AB1: 69 6E 67 20 
       00:1AB5: 4C 42 41 20 
       00:1AB9: 77 69 6C 6C 
       00:1ABD: 20 62 65 20 
       00:1AC1: 6F 76 65 72 
       00:1AC5: 77 72 69 74 
       00:1AC9: 74 65 6E 21 
       00:1ACD: 0D 0A 
  1808 00:1ACF: 20 42 65 20          .DB     " Be sure about this before continuing (Y/N)"
       00:1AD3: 73 75 72 65 
  Sun Mar 30 2025  9:15                                                                                                    Page 48


       00:1AD7: 20 61 62 6F 
       00:1ADB: 75 74 20 74 
       00:1ADF: 68 69 73 20 
       00:1AE3: 62 65 66 6F 
       00:1AE7: 72 65 20 63 
       00:1AEB: 6F 6E 74 69 
       00:1AEF: 6E 75 69 6E 
       00:1AF3: 67 20 28 59 
       00:1AF7: 2F 4E 29 
  1809 00:1AFA: 00                   .DB     $00
  1810                        ;
  1811                        LBA_BENCH_ABORT
  1812 00:1AFB: 0D 0A                .DB     $0D,$0A
  1813 00:1AFD: 20 57 72 69          .DB     " Write Benchmark test aborted!",$0D,$0A
       00:1B01: 74 65 20 42 
       00:1B05: 65 6E 63 68 
       00:1B09: 6D 61 72 6B 
       00:1B0D: 20 74 65 73 
       00:1B11: 74 20 61 62 
       00:1B15: 6F 72 74 65 
       00:1B19: 64 21 0D 0A 
  1814 00:1B1D: 00                   .DB     $00
  1815                        ;
  1816                        IDE_CONTROLLER_ERROR
  1817 00:1B1E: 0D 0A 0A             .DB     $0D,$0A,$0A
  1818 00:1B21: 20 41 6E 20          .DB     " An error occured accessing the MicroDrive!",$0D,$0A,$0A
       00:1B25: 65 72 72 6F 
       00:1B29: 72 20 6F 63 
       00:1B2D: 63 75 72 65 
       00:1B31: 64 20 61 63 
       00:1B35: 63 65 73 73 
       00:1B39: 69 6E 67 20 
       00:1B3D: 74 68 65 20 
       00:1B41: 4D 69 63 72 
       00:1B45: 6F 44 72 69 
       00:1B49: 76 65 21 0D 
       00:1B4D: 0A 0A 
  1819 00:1B4F: 20 20 2A 20          .DB     "  * "
  1820 00:1B53: 00                   .DB     $00
  1821                        ;
  1822                        SYS_INTRO_MSG
  1823 00:1B54: 0D 0A                .DB     $0D,$0A
  1824 00:1B56: 54 68 69 73          .DB     "This will write an image from memory to the Microdrive!",$0D,$0A
       00:1B5A: 20 77 69 6C 
       00:1B5E: 6C 20 77 72 
       00:1B62: 69 74 65 20 
       00:1B66: 61 6E 20 69 
       00:1B6A: 6D 61 67 65 
       00:1B6E: 20 66 72 6F 
       00:1B72: 6D 20 6D 65 
       00:1B76: 6D 6F 72 79 
       00:1B7A: 20 74 6F 20 
       00:1B7E: 74 68 65 20 
       00:1B82: 4D 69 63 72 
       00:1B86: 6F 64 72 69 
       00:1B8A: 76 65 21 0D 
       00:1B8E: 0A 
  1825 00:1B8F: 4D 61 6B 65          .DB     "Make sure you know what you are doing before you commit!!",$0D,$0A,$0A
       00:1B93: 20 73 75 72 
       00:1B97: 65 20 79 6F 
       00:1B9B: 75 20 6B 6E 
       00:1B9F: 6F 77 20 77 
       00:1BA3: 68 61 74 20 
  Sun Mar 30 2025  9:15                                                                                                    Page 49


       00:1BA7: 79 6F 75 20 
       00:1BAB: 61 72 65 20 
       00:1BAF: 64 6F 69 6E 
       00:1BB3: 67 20 62 65 
       00:1BB7: 66 6F 72 65 
       00:1BBB: 20 79 6F 75 
       00:1BBF: 20 63 6F 6D 
       00:1BC3: 6D 69 74 21 
       00:1BC7: 21 0D 0A 0A 
  1826 00:1BCB: 00                   .DB     $00
  1827                        ;
  1828                        SYS_LBA_MSG
  1829 00:1BCC: 0D 0A                .DB     $0D,$0A
  1830 00:1BCE: 20 45 6E 74          .DB     " Enter the Starting LBA (decimal) to write the Memory Image to: "
       00:1BD2: 65 72 20 74 
       00:1BD6: 68 65 20 53 
       00:1BDA: 74 61 72 74 
       00:1BDE: 69 6E 67 20 
       00:1BE2: 4C 42 41 20 
       00:1BE6: 28 64 65 63 
       00:1BEA: 69 6D 61 6C 
       00:1BEE: 29 20 74 6F 
       00:1BF2: 20 77 72 69 
       00:1BF6: 74 65 20 74 
       00:1BFA: 68 65 20 4D 
       00:1BFE: 65 6D 6F 72 
       00:1C02: 79 20 49 6D 
       00:1C06: 61 67 65 20 
       00:1C0A: 74 6F 3A 20 
  1831 00:1C0E: 00                   .DB     $00
  1832                        ;
  1833                        BLK_SIZE_MSG
  1834 00:1C0F: 0D 0A                .DB     $0D,$0A
  1835 00:1C11: 20 45 6E 74          .DB     " Enter the number of 512-byte Blocks (decimal) to transfer: "
       00:1C15: 65 72 20 74 
       00:1C19: 68 65 20 6E 
       00:1C1D: 75 6D 62 65 
       00:1C21: 72 20 6F 66 
       00:1C25: 20 35 31 32 
       00:1C29: 2D 62 79 74 
       00:1C2D: 65 20 42 6C 
       00:1C31: 6F 63 6B 73 
       00:1C35: 20 28 64 65 
       00:1C39: 63 69 6D 61 
       00:1C3D: 6C 29 20 74 
       00:1C41: 6F 20 74 72 
       00:1C45: 61 6E 73 66 
       00:1C49: 65 72 3A 20 
  1836 00:1C4D: 00                   .DB     $00
  1837                        ;
  1838                        RAM_START_MSG
  1839 00:1C4E: 0D 0A                .DB     $0D,$0A
  1840 00:1C50: 20 45 6E 74          .DB     " Enter the Starting RAM address in Hex: "
       00:1C54: 65 72 20 74 
       00:1C58: 68 65 20 53 
       00:1C5C: 74 61 72 74 
       00:1C60: 69 6E 67 20 
       00:1C64: 52 41 4D 20 
       00:1C68: 61 64 64 72 
       00:1C6C: 65 73 73 20 
       00:1C70: 69 6E 20 48 
       00:1C74: 65 78 3A 20 
  1841 00:1C78: 00                   .DB     $00
  Sun Mar 30 2025  9:15                                                                                                    Page 50


  1842                        ;
  1843                        SYS_CONFIRM_MSG
  1844 00:1C79: 0D 0A                .DB     $0D,$0A
  1845 00:1C7B: 20 41 72 65          .DB     " Are you sure you want to overwrite the Disc data? "
       00:1C7F: 20 79 6F 75 
       00:1C83: 20 73 75 72 
       00:1C87: 65 20 79 6F 
       00:1C8B: 75 20 77 61 
       00:1C8F: 6E 74 20 74 
       00:1C93: 6F 20 6F 76 
       00:1C97: 65 72 77 72 
       00:1C9B: 69 74 65 20 
       00:1C9F: 74 68 65 20 
       00:1CA3: 44 69 73 63 
       00:1CA7: 20 64 61 74 
       00:1CAB: 61 3F 20 
  1846 00:1CAE: 00                   .DB     $00
  1847                        ;
  1848                        SYS_WRITE_MSG
  1849 00:1CAF: 0D 0A                .DB     $0D,$0A
  1850 00:1CB1: 20 57 72 69          .DB     " Writing Disc Image..."
       00:1CB5: 74 69 6E 67 
       00:1CB9: 20 44 69 73 
       00:1CBD: 63 20 49 6D 
       00:1CC1: 61 67 65 2E 
       00:1CC5: 2E 2E 
  1851 00:1CC7: 0D 0A 00             .DB     $0D,$0A,$00
  1852                        ;
  1853                        SYS_COMPLETE_MSG
  1854 00:1CCA: 0D 0A                .DB     $0D,$0A
  1855 00:1CCC: 20 53 79 73          .DB     " System Image written to Disc."
       00:1CD0: 74 65 6D 20 
       00:1CD4: 49 6D 61 67 
       00:1CD8: 65 20 77 72 
       00:1CDC: 69 74 74 65 
       00:1CE0: 6E 20 74 6F 
       00:1CE4: 20 44 69 73 
       00:1CE8: 63 2E 
  1856 00:1CEA: 0A 0D 00             .DB     $0A,$0D,$00
  1857                        ;
  1858                        SYS_CONT_MSG
  1859 00:1CED: 20 63 6F 6E          .DB     " cont?"
       00:1CF1: 74 3F 
  1860 00:1CF3: 28 79 2F 6E          .DB     "(y/n)"
       00:1CF7: 29 
  1861 00:1CF8: 00                   .DB     $00
  1862                        ;
  1863                        SYS_ADDR_MSG
  1864 00:1CF9: 20 20 20 20          .DB     "    addr:"
       00:1CFD: 61 64 64 72 
       00:1D01: 3A 
  1865 00:1D02: 00                   .DB     $00
  1866                        ; BCD multiplicand table:
  1867                        ;
  1868 00:1D03: 00 00 00 00  HMULTAB .DB $00, $00, $00, $00, $01             ;BCD weight of least significant HEX digit
       00:1D07: 01 
  1869 00:1D08: 00 00 00 00          .DB $00, $00, $00, $00, $16
       00:1D0C: 16 
  1870 00:1D0D: 00 00 00 02          .DB $00, $00, $00, $02, $56
       00:1D11: 56 
  1871 00:1D12: 00 00 00 40          .DB $00, $00, $00, $40, $96
       00:1D16: 96 
  1872 00:1D17: 00 00 06 55          .DB $00, $00, $06, $55, $36
  Sun Mar 30 2025  9:15                                                                                                    Page 51


       00:1D1B: 36 
  1873 00:1D1C: 00 01 04 85          .DB $00, $01, $04, $85, $76
       00:1D20: 76 
  1874 00:1D21: 00 16 77 72          .DB $00, $16, $77, $72, $16
       00:1D25: 16 
  1875 00:1D26: 02 68 43 54          .DB $02, $68, $43, $54, $56             ;BCD weight of most significant HEX digit
       00:1D2A: 56 
  1876                        ;
  1877                        ; HEX multiplicand table:
  1878                        ;
  1879 00:1D2B: 00 00 00 01  DMULTAB .DB  $00, $00, $00, $01                 ;HEX weight of least significant BCD digit
  1880 00:1D2F: 00 00 00 0A          .DB  $00, $00, $00, $0A
  1881 00:1D33: 00 00 00 64          .DB  $00, $00, $00, $64
  1882 00:1D37: 00 00 03 E8          .DB  $00, $00, $03, $E8
  1883 00:1D3B: 00 00 27 10          .DB  $00, $00, $27, $10
  1884 00:1D3F: 00 01 86 A0          .DB  $00, $01, $86, $A0
  1885 00:1D43: 00 0F 42 40          .DB  $00, $0F, $42, $40
  1886 00:1D47: 00 98 96 80          .DB  $00, $98, $96, $80
  1887 00:1D4B: 05 F5 E1 00          .DB  $05, $F5, $E1, $00
  1888 00:1D4F: 3B 9A CA 00          .DB  $3B, $9A, $CA, $00                 ;HEX weight of most significant BCD digit
  1889                        ;
  1890                        ; Data variables used
  1891                        ;
  1892 00:1D53: 10           ROWS    .DB     #$10                            ;Default to 16 rows of displayed data
  1893                        ;
  1894                        ; LBA word count variables
  1895                        ;
  1896 00:1D54: 00 00        LBA_LOW_WORD    .DW     $0000                   ;Low word for LBA count
  1897 00:1D56: 00 00        LBA_HIGH_WORD   .DW     $0000                   ;High word for LBA count
  1898                        ;
  1899                        ; MicroDrive Error codes
  1900                        ;       These are the error codes per the Hitachi MicroDrive documentation.
  1901                        ;       The codes are read after an error is returned from a command
  1902                        ;       by executing an IDE Get Status command from BIOS.
  1903                        ;
  1904                        ;The X register will contaim the error code as detailed below:
  1905                        ;
  1906                        ; Error Register:
  1907                        ;Bit 7 - CRC Error or Bad Block error
  1908                        ;Bit 6 - Uncorrectable Data Error
  1909                        ;Bit 5 - 0 (not used) MC (used for Removable-Media drives)
  1910                        ;Bit 4 - ID Not Found
  1911                        ;Bit 3 - 0 (not used) MCR (used for Removable-Media drives)
  1912                        ;Bit 2 - Aborted Command error
  1913                        ;Bit 1 - Track Zero not found error
  1914                        ;Bit 0 - Data Address Mark Not Found
  1915                        ;
  1916                        ; The codes are indexed here and as they are received, the appropriate
  1917                        ; error message will be displayed.
  1918                        ;
  1919                        IDE_ERROR_CODES
  1920                        ;
  1921 00:1D58: 80                   .DB     %10000000                       ;CRC or Bad Block
  1922 00:1D59: 40                   .DB     %01000000                       ;Uncorrectable Data Error
  1923 00:1D5A: 10                   .DB     %00010000                       ;ID Not Found
  1924 00:1D5B: 04                   .DB     %00000100                       ;Aborted Command
  1925 00:1D5C: 02                   .DB     %00000010                       ;Track Zero not found
  1926 00:1D5D: 01                   .DB     %00000001                       ;Data Address Mark not found
  1927                        ;
  1928                        ; IDE Error handler addresses
  1929                        ;       These are the addresses for the error messages.
  1930                        ;       These are indexed as above, so once the error message is matched
  1931                        ;       above, the index is multiplied by two and the address is used for the
  Sun Mar 30 2025  9:15                                                                                                    Page 52


  1932                        ;       error message text string.
  1933                        ;
  1934                        IDE_ERROR_ADDRESS
  1935                        ;
  1936 00:1D5E: 6A 1D                .DW     IDE_ERROR_00                    ;CRC or Bad Block
  1937 00:1D60: 81 1D                .DW     IDE_ERROR_01                    ;Uncorrectable Data Error
  1938 00:1D62: 9A 1D                .DW     IDE_ERROR_02                    ;ID Not Found
  1939 00:1D64: AD 1D                .DW     IDE_ERROR_03                    ;Aborted Command
  1940 00:1D66: BD 1D                .DW     IDE_ERROR_04                    ;Track Zero not found
  1941 00:1D68: D2 1D                .DW     IDE_ERROR_05                    ;Data Address Mark not found
  1942                        ;
  1943                        ; Error messages are here:
  1944                        ;
  1945                        IDE_ERROR_00
  1946 00:1D6A: 43 52 43 20          .DB     "CRC or Bad Block Error"
       00:1D6E: 6F 72 20 42 
       00:1D72: 61 64 20 42 
       00:1D76: 6C 6F 63 6B 
       00:1D7A: 20 45 72 72 
       00:1D7E: 6F 72 
  1947 00:1D80: 00                   .DB     $00
  1948                        ;
  1949                        IDE_ERROR_01
  1950 00:1D81: 55 6E 63 6F          .DB     "Uncorrectable Data Error"
       00:1D85: 72 72 65 63 
       00:1D89: 74 61 62 6C 
       00:1D8D: 65 20 44 61 
       00:1D91: 74 61 20 45 
       00:1D95: 72 72 6F 72 
  1951 00:1D99: 00                   .DB     $00
  1952                        ;
  1953                        IDE_ERROR_02
  1954 00:1D9A: 42 6C 6F 63          .DB     "Block ID Not Found"
       00:1D9E: 6B 20 49 44 
       00:1DA2: 20 4E 6F 74 
       00:1DA6: 20 46 6F 75 
       00:1DAA: 6E 64 
  1955 00:1DAC: 00                   .DB     $00
  1956                        ;
  1957                        IDE_ERROR_03
  1958 00:1DAD: 41 62 6F 72          .DB     "Aborted Command"
       00:1DB1: 74 65 64 20 
       00:1DB5: 43 6F 6D 6D 
       00:1DB9: 61 6E 64 
  1959 00:1DBC: 00                   .DB     $00
  1960                        ;
  1961                        IDE_ERROR_04
  1962 00:1DBD: 54 72 61 63          .DB     "Track Zero not Found"
       00:1DC1: 6B 20 5A 65 
       00:1DC5: 72 6F 20 6E 
       00:1DC9: 6F 74 20 46 
       00:1DCD: 6F 75 6E 64 
  1963 00:1DD1: 00                   .DB     $00
  1964                        ;
  1965                        IDE_ERROR_05
  1966 00:1DD2: 44 61 74 61          .DB     "Data Address Mark not found"
       00:1DD6: 20 41 64 64 
       00:1DDA: 72 65 73 73 
       00:1DDE: 20 4D 61 72 
       00:1DE2: 6B 20 6E 6F 
       00:1DE6: 74 20 66 6F 
       00:1DEA: 75 6E 64 
  1967 00:1DED: 00                   .DB     $00
  Sun Mar 30 2025  9:15                                                                                                    Page 53


  1968                        ;
  1969                        IDE_ERROR_06
  1970 00:1DEE: 55 6E 6B 6E          .DB     "Unknown Error"
       00:1DF2: 6F 77 6E 20 
       00:1DF6: 45 72 72 6F 
       00:1DFA: 72 
  1971 00:1DFB: 00                   .DB     $00
  1972                        ;
  1973                                .ORG    $/256*256+256                   ;Benchmark Buffer (start on page boundary)
  1974                        BENCH_BUFFER
  1975                        ;
  1976                                .END


      Lines assembled: 2482
      Errors: 0
