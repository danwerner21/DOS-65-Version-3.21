  Tue Apr 29 2025  4:23                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;
     2                        ;**************************************************************************************************
     3                        ;DOS/65 (CMOS) RAM Version
     4                        ;
     5                        ;This is Version 3.21 - 6th March 2025 - KM
     6                        ;This is the bootable image for a RAM loaded version of DOS/65
     7                        ;
     8                        ;**************************************************************************************************
     9                        ; Based on Richard A. Leary's DOS/65 V3 code - many thanks Richard!!
    10                        ; below is Richard's license text from his V3 ROM version.
    11                        ;
    12                        ; The DOS/65 V3 ROM software and all other DOS/65 software are free software;
    13                        ; you can redistribute it and/or modify it under the terms of the GNU General Public License as
    14                        ; published by the Free Software Foundation; either version 3 of the license, or any later version.
    15                        ; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
    16                        ; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    17                        ; See the GNU General Public License for more details.
    18                        ; You should have received a copy of the GNU General Public License along with this
    19                        ; program; if not, see <http://www.gnu.org/licenses/>.
    20                        ; CP/M is a trademark of Caldera.
    21                        ;
    22                        ; Note that CCM and PEM have undergone a major rewrite by Kevin E. Maier (me).
    23                        ; SIM is a completely new version (by me) that interfaces directly to my C02BIOS.
    24                        ; I also make all of my code available with the same GNU GPL license as above.
    25                        ;
    26                        ;**************************************************************************************************
    27                        ; The target platform for this build is:
    28                        ;  A prototype 3.3-Volt system based on the C02 Pocket SBC - KM
    29                        ;  This prototype uses a NXP 28L92 DUART and a Hitachi MicroDrive PATA interface (IDE)
    30                        ;  The system has been modified for more RAM, now 60KB RAM and 4KB ROM (less I/O), 8MHz CPU
    31                        ;
    32                        ;**************************************************************************************************
    33                        ; Assembler directives
    34                        ;
    35                                        PW      132             ;Page width
    36                                        PL      66              ;Page Length
    37                                        CHIP    W65C02S         ;Enable WDC 65C02 instructions
    38                                        GLOBALS ON              ;
    39                                        CASE    OFF             ;Ignore upper vs lower case
    40                                        INCLIST ON              ;Include list of include files
    41                        ;
    42                        ;**************************************************************************************************
    43                        ;
    44                        ; This version uses CMOS instructions and addressing modes!
    45                        ;
    46                        ; There are multiple modules that make up this bootable version and use "include" to
    47                        ; add them into the main code. The Code Modules are:
    48                        ;       DOS65-MAIN-V321.ASM (This file)
    49                        ;       DOS65-CCM-V321.ASM - Concurrent Command Module
    50                        ;       DOS65-PEM-V321.ASM - Primitive Execution Module
    51                        ;       DOS65-SIM-V321.ASM - System Interface Module
    52                        ;
    53                        ; Other files required contain system variables and constants for C02BIOS and C02Monitor,
    54                        ; which are included in the SIM source module.
    55                        ;       C02Constants.asm - C02 BIOS/Monitor constants file
    56                        ;       C02JMP_Table.asm - C02 BIOS/Monitor JMP table for routines
    57                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 2


    58                        ;  The current BIOS and Monitor versions for the Prototype system are 5.0
    59                        ; - Note that SIM is the only code module that calls the C02 BIOS. No C02 Monitors calls are used.
    60                        ;
    61                        ;**************************************************************************************************
    62                        ;
    63                        ;               18 February 2023 - KM
    64                        ;Major revision! This is an entirely RAM based version of DOS/65
    65                        ;
    66                        ; Based on my 3.20 CMOS RAM Version
    67                        ; - All data areas are included in the linked modules
    68                        ; - Allocation Maps for 8 drives are zeroed and adds 2KB to the 6KB of DOS/65 code
    69                        ; - Supports 8- 8MB drives configured on the Microdrive.
    70                        ;
    71                        ; CCM and PEM modules have been reworked for RAM based and include data areas.
    72                        ; - Page Zero usage has been reduced - currently, 8 bytes are used.
    73                        ;
    74                        ;               03 March 2023 - KM
    75                        ; Major updates to this version, now V3.20:
    76                        ; - Traditional Track/Sector call structure has been eliminated!
    77                        ; - All calls for disk drives are at a 128-byte record level.
    78                        ; - PEM has been changed to only make calls for record numbers.
    79                        ; - SIM has been re-written to accept record numbers and perform blocking/de-blocking for LBAs.
    80                        ; - All checksum code has been removed from PEM, no longer needed with IDE block devices.
    81                        ; - Drive range (A-H) is managed with an invalid drive message shown for invalid drives.
    82                        ; - DCB structure has changed: track/sector to record based and no checksum table (now 11 bytes).
    83                        ;
    84                        ;               02 April 2023 - KM
    85                        ; Update to SIM for this version:
    86                        ; - Record Writes are now more efficient with proper blocking to the 512-byte block size of the
    87                        ;   physical media being used. This provides a significant performance advantage.
    88                        ; - PEM has been updated to remove the rest of the code associated with diskette based media.
    89                        ;
    90                        ;               20 December 2023 - KM
    91                        ; Update to CCM and PEM to consolidate routines, now V3.20:
    92                        ; - There were some routines that are called only by CCM, but were contained in the PEM source.
    93                        ;   These were likely put there to manage the overall size of CCM. Now that Version 3.21 has
    94                        ;   resulted in a smaller memory footprint, this version consolidates those routines into CCM.
    95                        ;
    96                        ; The routines are:
    97                        ; - tstdec
    98                        ; - tsthex
    99                        ; - mv128
   100                        ; - adjdb
   101                        ;
   102                        ; An additional routine in PEM is used by both PEM and CCM:
   103                        ; - tstchr
   104                        ;
   105                        ; This routine is called once from CCM and twice from within PEM.
   106                        ; The decision here is to replicate this code in CCM without a JSR/RTS to reduce size and
   107                        ; execution time. It increases the CCM code size, but has no affect on PEM.
   108                        ;
   109                        ;               2 December 2024 - KM
   110                        ; New updates and changes to Version 3.21
   111                        ;
   112                        ; - Disk Parameter tables changed to 4KB Block size - reduces allocation tables by 50% (now 2KB).
   113                        ; - Moved DOS/65 Start location in RAM to $C000 - increases TEA size by 2KB for user programs.
   114                        ; - Expanded CCM jump table to PEM calls. Reduces execution time with an increase in memory usage.
   115                        ;
   116                        ;               27th February 2025 - KM
   117                        ; Some changes to CCM:
   118                        ;
   119                        ; - A new SYSTEM command has been added to CCM, it displays system memory details:
   120                        ;   Page Zero free range
  Tue Apr 29 2025  4:23                                                                                                    Page 3


   121                        ;   Memory location of system BIOS
   122                        ;   Memory Ranges for TEA, CCM, PEM, SIM and Disk Allocation Maps
   123                        ;
   124                        ; - Removed Switch routine in PEM. No longer needed as PEM is not reloaded on a Warm Boot.
   125                        ;
   126                        ;               6th March 2025 - KM
   127                        ; Change to CCM:
   128                        ;
   129                        ; - Changed the erase command to search for the filespec before attempting to erase it.
   130                        ;   this simlpy displays a NOT FOUND message if the file entered to be erased does not
   131                        ;   exist. It also shows the error message if a partial wildcard name is entered.
   132                        ;
   133                        ;**************************************************************************************************
   134                        ;
   135                        ;Base addresses and definitions
   136                        ;
   137                        ; Page Zero is allocated from the top ($FF) down. For end user applications, there is a contiguous
   138                        ; amount of memory from pzbase, which should normally start at $00, to the start of Page Zero
   139                        ; memory which is used by DOS/65.
   140                        ;
   141                        ; The BIOS location for the C02 Pocket is contained in the upper 2KB of the address map and also
   142                        ; contains the I/O addresses for the reauired hardware. The uppermost address is $FFFF.
   143                        ; Currently, the C02 Monitor is allocated 6KB of space starting at $E000.
   144                        ;
   145             00000000   pzbase          .EQU    $00             ;Start of page zero available space
   146             000000A0   pzend           .EQU    $A0             ;End of page zero available space
   147             000000C0   pzstrt          .EQU    $C0             ;Start of page zero space for DOS/65
   148             0000F000   monitor         .EQU    $F000           ;Start of Monitor for C02 Pocket (optional)
   149             0000F800   bios            .EQU    $F800           ;Start of BIOS for C02 Pocket
   150                        ;
   151                        ; Page Zero is allocated from the top ($FF) to the bottom ($00)
   152                        ; The C02BIOS allocates 48 bytes to support all of the hardware devices and a fair anumber of
   153                        ; variables, pointers and minimal buffer space. The C02Monitor also allocates 48 bytes to
   154                        ; support it's functions. This equates to 96 bytes which should not be altered by DOS/65!
   155                        ; The only Page Zero space required by Version 3.21 is 8 bytes starting as shown above.
   156                        ;
   157                        ; Note that the current SIM module does access certain BIOS variables for printing a string
   158                        ; and for checking on console data being available. As I move away from a ROM based Monitor
   159                        ; to a streamlined BIOS that automatically boots from the IDE port, this access will also be
   160                        ; minimized further.
   161                        ;
   162                        ;Declare a low memory start address for DOS/65.
   163                        ;
   164                        ; The initial default is to use the lower part of Page $01, which is the Stack.
   165                        ; It's possible to move this... BUT... all utilities and applications would need
   166                        ; to be updated (assembled or compiled) to work with any changes to low memory.
   167                        ;
   168                        ; I'm not suggesting that this be the case, but if you have an operating environment
   169                        ; which requires a large amount of CPU stack space, this could be a workaround.
   170                        ;
   171             00000100   d65_low         .EQU    $100            ;Start of DOS/65 low memory usage
   172                        ;
   173             00000100   btejmp          .EQU    d65_low+$00     ;Warm boot jump (3 bytes)
   174             00000103   pemjmp          .EQU    d65_low+$03     ;Jump to PEM    (3 bytes)
   175             00000106   iostat          .EQU    d65_low+$06     ;I/O status     (1 byte)
   176             00000107   dflfcb          .EQU    d65_low+$07     ;Default FCB    (32 bytes)
   177             00000128   dflbuf          .EQU    d65_low+$28     ;Default buffer (128 bytes)
   178                        ;
   179                        ; The TEA defaults to $0800 in memory. This is due in part to the 65C02 hardware features and
   180                        ; the software structure of the C02 Pocket. The lower 2KB of RAM is allocated for the BIOS,
   181                        ; Monitor, serial port buffers, IDE LBA buffer, Vectors and hardware configuration data.
   182                        ;
   183             00000800   tea             .EQU    $800            ;TEA start
  Tue Apr 29 2025  4:23                                                                                                    Page 4


   184                        ;
   185                        ;C02 Pocket SBC memory parameters - 3.3V prototype
   186                        ; RAM is now from $0000 - $EFFF (60KB)
   187                        ; ROM is now from $F000 - $FFFF (4KB less I/O)
   188                        ;
   189                        ; The next iteration of the C02 Pocket SBC will decrease ROM and I/O to 2KB.
   190                        ; This will yield a total of 62KB of contiguous RAM. This will allow DOS/65
   191                        ; to have an additional 2KB of TEA space, allowing for larger applications.
   192                        ;
   193             0000D000   ramstrt         .EQU    $D000           ;Starting RAM location for assembly
   194             00000600   hstbuf          .EQU    $0600           ;IDE host LBA buffer
   195                        ;
   196                        ;Fixed parameters
   197             00000008   bs              .EQU    $08             ;Backspace
   198             0000000A   lf              .EQU    $0A             ;Linefeeed
   199             0000000D   cr              .EQU    $0D             ;Return
   200             0000001A   eof             .EQU    $1A             ;End of file
   201             00000000   null            .EQU    0               ;Null
   202             00000003   ctlc            .EQU    3               ;Abort
   203             00000005   ctle            .EQU    5               ;Physical cr lf - not referenced!
   204             00000009   ctli            .EQU    9               ;Tab character
   205             00000010   ctlp            .EQU    $10             ;Toggle printer
   206             00000012   ctlr            .EQU    $12             ;Repeat line
   207             00000013   ctls            .EQU    $13             ;Freeze
   208             00000018   ctlx            .EQU    $18             ;Cancel
   209             0000003B   semico          .EQU    $3B             ;Semicolon
   210             0000007F   delete          .EQU    $7F             ;Delete character
   211             00000025   numcmd          .EQU    37              ;Number of PEM commands
   212             00000008   maxdrv          .EQU    8               ;Maximum number of drives suppported
   213                        ;
   214                        ;Page Zero use
   215                                        PAGE0
   216                        ;CCM / PEM
   217             000000C0   addinp          .EQU    pzstrt          ;Initialized to a,y
   218             000000C2   bufadd          .EQU    addinp+2        ;Buffer address
   219             000000C4   alcpnt          .EQU    bufadd+2        ;Allocation map pointer
   220                        ;
   221             000000C6   d65flg          .EQU    alcpnt+2        ;DOS/65 flag for CCM/PEM usage
   222                                                                ;bit 7 used for blmode flag in PEM
   223                                                                ;bit 6 used for exrwfl flag in PEM
   224                                                                ;bit 5 used for drvflg flag in PEM
   225                                                                ;bit 4 used for outflg flag in PEM
   226                                                                ;bits 3,2,1 unused
   227                                                                ;bit 0 used for submit flag in CCM
   228                        ;
   229                        ;SIM
   230             000000C7   sim_recflg      .EQU    d65flg+1        ;Disk I/O status flag for SIM
   231                                                                ;bit 7 used for valid LBA
   232                                                                ;bit 6 used for dirty block
   233                                                                ;bit 5 used for read operation
   234                                                                ;bit 4 used for write operation
   235                                                                ;bits 3,2 unused
   236                                                                ;bits 1,0 used for record offset
   237                        ;
   238                                        ENDS
   239                        ;
   240                        ;**************************************************************************************************
   241                        ;
   242                        ; Main program code starts here:
   243                                        .ORG     ramstrt
   244                        ;
   245                        LOAD_HEADER
   246                        ;Below is the Load Header required by the BOOT RECORD!
  Tue Apr 29 2025  4:23                                                                                                    Page 5


   247                        ; it contains parameters required to complete the loading and configuration of the Boot Image
   248                        ; before execution. The load header is a 16-byte field located at the start of the Boot Image file.
   249                        ; It is structured as:
   250                        ;
   251                        ; - The 16-bit address to start loading the Boot Image.
   252                        ; - The 16-bit address to execute the Boot Image (BOOT RECORD code jumps to this address).
   253                        ; - The 16-bit address for loading the offset to the start of disk data.
   254                        ; - A long word for the size of the required disk space (for all assigned drives).
   255                        ; - A 1 byte count that defines how many blocks are loaded for the image.
   256                        ; - A 5 character string ID to validate the Boot Image.
   257                        ;
   258                        ;Note that this is not yet being used...
   259                        ; this will be used when the boot record setup is finalized.
   260                        ; timing is everything... and the timing for this part is not yet.
   261                        ;
   262 00:D000: 00 D0                .DW     ramstrt         ;Address to load Boot Image
   263 00:D002: 00 E4                .DW     simram          ;Cold Start location for SIM
   264 00:D004: CD E6                .DW     part_offset     ;Location to copy LBA offset
   265 00:D006: 00 00 02 00          .LONG   131072          ;64MB for 8-drives (at 8MB each)
   266 00:D00A: 10                   .DB     #16             ;Block count 16 = 8KB (number of blocks to copy to ramstrt)
   267                        ;
   268                        string_id
   269 00:D00B: 64 6F 73 36          .DB     "dos65"         ;ID string to validate Boot image
       00:D00F: 35 
   270                        ;
   271                        ;**************************************************************************************************
   272                        ;
   273                                include         DOS65-CCM-V321.ASM      ;Include CCM Module
     1                        ;
     2                        ;-------------------------------
     3                        ;DOS/65 Console Command Module
     4                        ;-------------------------------
     5                        ;
     6                        ; Version 3.21 - 6th March 2025
     7                        ;
     8                        ;CCM unique definitions
     9             00000009   nbuilt  equ     9               ;number built in commands
    10             00000004   dirpln  equ     4               ;number dir listings per line
    11                        ;
    12                        ccmram
    13                        ;
    14                        ;main program - entry point
    15 00:D010: D8           CCMStr  cld                     ;ensure binary mode
    16 00:D011: AD 06 01             lda     iostat          ;get drive / user numbers
    17 00:D014: 4A                   lsr     a               ;move user to low nibble
    18 00:D015: 4A                   lsr     a
    19 00:D016: 4A                   lsr     a
    20 00:D017: 4A                   lsr     a
    21 00:D018: A2 24                ldx     #36             ;set user number
    22 00:D01A: 20 03 01             jsr     pemjmp          ;call pem
    23 00:D01D: AD 06 01             lda     iostat          ;get data again
    24 00:D020: 29 07                and     #%00000111      ;mask for drive only
    25 00:D022: 8D E9 D9             sta     dfldsk          ;save it
    26 00:D025: A2 0E                ldx     #14             ;select drive
    27 00:D027: 20 03 01             jsr     pemjmp          ;call pem
    28 00:D02A: A9 28                lda     #<DflBuf        ;set default buffer
    29 00:D02C: A0 01                ldy     #>DflBuf        ;address
    30 00:D02E: A2 1A                ldx     #26             ;set buffer
    31 00:D030: 20 03 01             jsr     pemjmp          ;call pem
    32 00:D033: A2 0D                ldx     #13             ;get reset disk
    33 00:D035: 20 03 01             jsr     pemjmp          ;call pem
    34                        ;now see if $$$.sub file on A
    35 00:D038: 07 C6                rmb0    d65flg          ;clear submit flag
  Tue Apr 29 2025  4:23                                                                                                    Page 6


    36 00:D03A: 20 70 D1             jsr     prpsub          ;get ready for $$$.sub
    37 00:D03D: A2 11                ldx     #17             ;get search file
    38 00:D03F: 20 03 01             jsr     pemjmp          ;call pem
    39                        ;if $$$.sub file present set subflg to use file
    40 00:D042: 30 04                bmi     nosub           ;flag ok if a=255
    41 00:D044: 87 C6                smb0    d65flg          ;set submit flag
    42 00:D046: 80 03                bra     ccmlpe          ;and go to main loop
    43 00:D048: 20 83 D1     nosub   jsr     rcvdsk          ;return to original default
    44 00:D04B: A2 FF        ccmlpe  ldx     #$ff            ;set
    45 00:D04D: 9A                   txs                     ;stack
    46 00:D04E: A9 28                lda     #<DflBuf        ;get default buffer
    47 00:D050: A0 01                ldy     #>DflBuf        ;address
    48 00:D052: A2 1A                ldx     #26             ;set buffer
    49 00:D054: 20 03 01             jsr     pemjmp          ;call pem
    50 00:D057: 20 A0 D5             jsr     hdrout          ;send header
    51 00:D05A: A9 3E                lda     #'>'            ;then print
    52 00:D05C: A2 02                ldx     #2              ;console output
    53 00:D05E: 20 03 01             jsr     pemjmp          ;call pem
    54                        ;at this point we check flag for use of $$$.SUB file
    55 00:D061: 8F C6 02             bbs0    d65flg,L01      ;test submit flag, branch if set
    56 00:D064: 80 61                bra     usecns          ;else clear use console
    57                        ;we must use $$$.SUB file
    58 00:D066: 20 7E D1     L01     jsr     setsub          ;get FCB pointer
    59 00:D069: A2 0F                ldx     #15             ;get open file
    60 00:D06B: 20 03 01             jsr     pemjmp          ;call pem
    61 00:D06E: 10 05                bpl     L02             ;use if OK
    62 00:D070: 20 8E D1             jsr     delsub          ;get rid of file
    63 00:D073: 80 52                bra     usecns          ;use console if no open
    64 00:D075: AE D3 D9     L02     ldx     subrc           ;get record count
    65 00:D078: CA                   dex
    66 00:D079: 8E E4 D9             stx     subcr           ;and read last record
    67 00:D07C: 20 7E D1             jsr     setsub          ;get ready for sub
    68 00:D07F: A2 14                ldx     #20             ;get read record
    69 00:D081: 20 03 01             jsr     pemjmp          ;call pem
    70 00:D084: F0 05                beq     L03             ;if OK get data
    71 00:D086: 20 8E D1             jsr     delsub          ;else clean up from EOF
    72 00:D089: 80 3C                bra     usecns          ;and use console
    73                        ;read was OK so move record to command buffer
    74 00:D08B: A2 00        L03     ldx     #0
    75 00:D08D: BD 28 01     movsub  lda     dflbuf,x        ;get char
    76 00:D090: 9D 22 D9             sta     cnslng,x        ;move it
    77 00:D093: E8                   inx                     ;bump index
    78 00:D094: 10 F7                bpl     movsub          ;loop until index is 128
    79                        ;now delete record
    80 00:D096: CE D3 D9             dec     subrc           ;drop number records by one
    81 00:D099: 20 7E D1             jsr     setsub          ;get ready for sub
    82 00:D09C: A2 10                ldx     #16             ;get close file
    83 00:D09E: 20 03 01             jsr     pemjmp          ;call pem
    84 00:D0A1: 10 05                bpl     typbuf          ;if OK go type line
    85 00:D0A3: 20 8E D1             jsr     delsub          ;then delete $$$.SUB
    86 00:D0A6: 80 1F                bra     usecns          ;switch to console if bad
    87                        ;send command line to console
    88 00:D0A8: A2 00        typbuf  ldx     #0              ;start one past length
    89 00:D0AA: BD 23 D9     print0  lda     cnstxt,x        ;get char
    90 00:D0AD: F0 06                beq     gotend          ;done if zero
    91 00:D0AF: 20 C1 D5             jsr     cotsxy          ;save x and send to console
    92 00:D0B2: E8                   inx
    93 00:D0B3: 10 F5                bpl     print0          ;do next
    94 00:D0B5: A2 0B        gotend  ldx     #11             ;check console for keypress
    95 00:D0B7: 20 03 01             jsr     pemjmp          ;call pem
    96 00:D0BA: F0 14                beq     nobrak          ;no break if no key
    97 00:D0BC: A2 06                ldx     #6              ;get console read w/o echo
    98 00:D0BE: 20 03 01             jsr     pemjmp          ;call pem
  Tue Apr 29 2025  4:23                                                                                                    Page 7


    99 00:D0C1: 20 8E D1             jsr     delsub          ;stop $$$.SUB use
   100 00:D0C4: 4C 10 D0             jmp     CCMStr          ;and go back to start
   101                        ;next line is the entry that stops $$$.SUB processing
   102 00:D0C7: A9 21        usecns  lda     #<cnsbuf        ;point to start
   103 00:D0C9: A0 D9                ldy     #>cnsbuf        ;of buffer
   104 00:D0CB: A2 0A                ldx     #10             ;get read buffer
   105 00:D0CD: 20 03 01             jsr     pemjmp          ;call pem
   106                        ;next line is the entry point from $$$.SUB read
   107 00:D0D0: A0 00        nobrak  ldy     #0              ;clear index
   108 00:D0D2: AE 22 D9             ldx     cnslng          ;get length
   109 00:D0D5: D0 02                bne     lwrupr          ;continue
   110 00:D0D7: 80 73                bra     ccmlp2          ;loop if empty
   111 00:D0D9: B9 23 D9     lwrupr  lda     cnstxt,y        ;else get char
   112 00:D0DC: C9 61                cmp     #'a'            ;if less than a
   113 00:D0DE: 90 09                bcc     nxtchg          ;skip convert
   114 00:D0E0: C9 7B                cmp     #'z'+1          ;if over z
   115 00:D0E2: B0 05                bcs     nxtchg          ;skip convert
   116 00:D0E4: 29 5F                and     #%01011111      ;else convert
   117 00:D0E6: 99 23 D9             sta     cnstxt,y        ;put back in buffer
   118 00:D0E9: C8           nxtchg  iny                     ;bump index
   119 00:D0EA: CA                   dex                     ;count down
   120 00:D0EB: D0 EC                bne     lwrupr          ;loop if more
   121 00:D0ED: 8A                   txa                     ;set a to zero
   122 00:D0EE: 99 23 D9             sta     cnstxt,y        ;insert stopper
   123 00:D0F1: 8D E8 D9             sta     cnbfpt          ;initialize pointer
   124 00:D0F4: 20 0C D7     mrecmd  jsr     stdflb          ;set default buffer
   125 00:D0F7: A2 19                ldx     #25             ;get init disk
   126 00:D0F9: 20 03 01             jsr     pemjmp          ;call pem
   127 00:D0FC: 8D E9 D9             sta     dfldsk          ;store as default
   128 00:D0FF: 20 03 D6             jsr     prslin          ;parse command
   129 00:D102: D0 4E                bne     cmderr          ;error if afn
   130 00:D104: AD EA D9             lda     tmpdsk          ;get temporary
   131 00:D107: F0 04                beq     nodrch          ;if zero ok
   132 00:D109: A9 12                lda     #nbuilt*2       ;else set and
   133 00:D10B: 80 2A                bra     dotrns          ;do transient
   134 00:D10D: A2 00        nodrch  ldx     #0              ;zero table index
   135 00:D10F: 9C EC D9             stz     count           ;and clear count
   136 00:D112: A0 01        tsnxfn  ldy     #1              ;set fcb index
   137 00:D114: BD EF D8     tsnxch  lda     fnctbl,x        ;get table entry
   138 00:D117: F0 1A                beq     gotcmd          ;if zero got it
   139 00:D119: D9 A3 D9             cmp     fcbone,y        ;else test
   140 00:D11C: D0 04                bne     nocmpr          ;no good if not =
   141 00:D11E: E8                   inx                     ;bump
   142 00:D11F: C8                   iny                     ;pointers
   143 00:D120: D0 F2                bne     tsnxch          ;and loop
   144 00:D122: E8           nocmpr  inx                     ;go to end
   145 00:D123: BD EF D8             lda     fnctbl,x        ;of table
   146 00:D126: D0 FA                bne     nocmpr          ;entry
   147 00:D128: E8                   inx                     ;point to next
   148 00:D129: EE EC D9             inc     count           ;bump count
   149 00:D12C: AD EC D9             lda     count           ;and if not
   150 00:D12F: C9 09                cmp     #nbuilt         ;limit then
   151 00:D131: D0 DF                bne     tsnxfn          ;try next
   152 00:D133: AD EC D9     gotcmd  lda     count           ;get count
   153 00:D136: 0A                   asl     a               ;multiply by two
   154 00:D137: AA           dotrns  tax                     ;use as index
   155 00:D138: 20 4F D1             jsr     ccm_cmd         ;call execute command
   156 00:D13B: 20 67 D5     extcmd  jsr     rstddr          ;restore default
   157 00:D13E: 20 03 D6     extwod  jsr     prslin          ;parse more
   158 00:D141: AD A4 D9             lda     fcbone+1        ;if first
   159 00:D144: 38                   sec                     ;character
   160 00:D145: E9 20                sbc     #' '            ;not a space
   161 00:D147: 0D EA D9             ora     tmpdsk          ;or if temporary
  Tue Apr 29 2025  4:23                                                                                                    Page 8


   162 00:D14A: D0 06                bne     cmderr          ;then an error
   163 00:D14C: 4C 4B D0     ccmlp2  jmp     ccmlpe          ;else loop
   164 00:D14F: 7C 09 D8     ccm_cmd jmp     (xqfntb,x)      ;execute command
   165                        ;
   166                        ;command error syntax handler
   167 00:D152: 20 59 D5     cmderr  jsr     ccrlf           ;do a cr lf
   168 00:D155: AC ED D9             ldy     curpnt          ;get command pointer
   169 00:D158: B9 23 D9     cmerlp  lda     cnstxt,y        ;get char
   170 00:D15B: F0 0A                beq     cmerex          ;if null then done
   171 00:D15D: C9 20                cmp     #' '            ;if space
   172 00:D15F: F0 06                beq     cmerex          ;then done
   173 00:D161: 20 C1 D5             jsr     cotsxy          ;output with save
   174 00:D164: C8                   iny                     ;point to next
   175 00:D165: D0 F1                bne     cmerlp          ;and loop
   176 00:D167: A9 3F        cmerex  lda     #'?'            ;send a ?
   177 00:D169: A2 02                ldx     #2              ;console output
   178 00:D16B: 20 03 01             jsr     pemjmp          ;call pem
   179 00:D16E: 80 DC                bra     ccmlp2          ;and start over
   180                        ;
   181                        ;$$$.sub related subroutines
   182                        ;prepare drive A and FCB pointer for $$$.sub operation
   183 00:D170: AD E9 D9     PrpSUB  lda     dfldsk          ;get default drive
   184 00:D173: 8D EB D9             sta     dsksav          ;save it
   185 00:D176: 9C E9 D9             stz     dfldsk          ;set default to A
   186 00:D179: A2 0E                ldx     #14             ;select drive
   187 00:D17B: 20 03 01             jsr     pemjmp          ;call pem
   188                        ;set up submit FCB pointer
   189 00:D17E: A9 C4        setsub  lda     #<subfcb        ;low byte address
   190 00:D180: A0 D9                ldy     #>subfcb        ;high byte address
   191 00:D182: 60                   rts                     ;return to caller
   192                        ;recover disk assignments after $$$.sub ops
   193 00:D183: AD EB D9     RcvDsk  lda     dsksav          ;get saved drive,
   194 00:D186: 8D E9 D9             sta     dfldsk          ;make it default,
   195 00:D189: A2 0E                ldx     #14             ;select drive
   196 00:D18B: 4C 03 01             jmp     pemjmp          ;call pem
   197                        ;delete $$$.SUB file and clear flag
   198 00:D18E: 20 7E D1     delsub  jsr     setsub          ;set up .SUB FCB address
   199 00:D191: A2 13                ldx     #19             ;delete file
   200 00:D193: 20 03 01             jsr     pemjmp          ;call pem
   201 00:D196: 20 83 D1             jsr     rcvdsk          ;restore drives
   202 00:D199: 07 C6                rmb0    d65flg          ;clear submit flag
   203 00:D19B: 60           extdir  rts                     ;return to caller
   204                        ;
   205                        ;execute dir command
   206                        ; dir <afn>
   207 00:D19C: 20 03 D6     dir     jsr     prslin          ;find object file
   208 00:D19F: 20 15 D7             jsr     clrslt          ;clear auto and select
   209 00:D1A2: A9 20                lda     #' '            ;if name
   210 00:D1A4: CD A4 D9             cmp     fcbone+1        ;and
   211 00:D1A7: D0 0F                bne     findfr          ;type are
   212 00:D1A9: CD AC D9             cmp     fcbone+9        ;not empty
   213 00:D1AC: D0 0A                bne     findfr          ;then use it
   214 00:D1AE: A9 3F                lda     #'?'            ;else
   215 00:D1B0: A0 0B                ldy     #11             ;fill
   216 00:D1B2: 99 A3 D9     fillqu  sta     fcbone,y        ;fcb
   217 00:D1B5: 88                   dey                     ;with
   218 00:D1B6: D0 FA                bne     fillqu          ;question marks
   219 00:D1B8: 20 94 D5     findfr  jsr     srchf1          ;search for first match
   220 00:D1BB: 30 60                bmi     notfnd          ;error if none
   221 00:D1BD: A9 04        fnddir  lda     #dirpln         ;set across
   222 00:D1BF: 8D F5 D9             sta     across          ;to entries per line
   223 00:D1C2: 20 59 D5             jsr     ccrlf           ;do a crlf
   224 00:D1C5: 20 A3 D5     dirl    jsr     hdr             ;do header
  Tue Apr 29 2025  4:23                                                                                                    Page 9


   225 00:D1C8: A9 3A                lda     #':'            ;then a
   226 00:D1CA: A2 02                ldx     #2              ;console output
   227 00:D1CC: 20 03 01             jsr     pemjmp          ;call pem
   228 00:D1CF: AD EE D9             lda     diradd          ;get number
   229 00:D1D2: 0A                   asl     a               ;and
   230 00:D1D3: 0A                   asl     a               ;multiply
   231 00:D1D4: 0A                   asl     a               ;by
   232 00:D1D5: 0A                   asl     a               ;thirty two
   233 00:D1D6: 0A                   asl     a               ;then
   234 00:D1D7: 29 60                and     #%01100000      ;mask out insignificant
   235 00:D1D9: A8                   tay                     ;make a pointer
   236 00:D1DA: C8                   iny                     ;and bump
   237 00:D1DB: A2 01                ldx     #1              ;set counter
   238 00:D1DD: B9 28 01     nmelpe  lda     dflbuf,y        ;get name
   239 00:D1E0: 20 C1 D5             jsr     cotsxy          ;else send to console
   240 00:D1E3: C8           noname  iny                     ;bump index
   241 00:D1E4: E8                   inx                     ;and count
   242 00:D1E5: E0 0C                cpx     #12             ;if count is 12
   243 00:D1E7: F0 0B                beq     endnme          ;then done
   244 00:D1E9: E0 09                cpx     #9              ;or if not 9
   245 00:D1EB: D0 F0                bne     nmelpe          ;then loop
   246 00:D1ED: A9 2E                lda     #'.'            ;else send
   247 00:D1EF: 20 C1 D5             jsr     cotsxy          ;a period
   248 00:D1F2: 80 E9                bra     nmelpe          ;and loop
   249 00:D1F4: A2 0B        endnme  ldx     #11             ;check console status
   250 00:D1F6: 20 03 01             jsr     pemjmp          ;call pem
   251 00:D1F9: D0 A0                bne     extdir          ;if key down quit
   252 00:D1FB: 20 F7 D5             jsr     setone          ;else point to fcb
   253 00:D1FE: A2 12                ldx     #18             ;get search next
   254 00:D200: 20 03 01             jsr     pemjmp          ;call pem
   255 00:D203: 8D EE D9             sta     diradd          ;save number
   256 00:D206: 30 93                bmi     extdir          ;quit if not found
   257 00:D208: CE F5 D9             dec     across          ;drop count
   258 00:D20B: F0 B0                beq     fnddir          ;new line if 0
   259 00:D20D: A9 20                lda     #' '            ;output space
   260 00:D20F: A2 02                ldx     #2              ;console output
   261 00:D211: 20 03 01             jsr     pemjmp          ;call pem
   262 00:D214: A9 20                lda     #' '            ;output space
   263 00:D216: A2 02                ldx     #2              ;console output
   264 00:D218: 20 03 01             jsr     pemjmp          ;call pem
   265 00:D21B: 80 A8                bra     dirl            ;loop for more filenames
   266                        ;not found error handler
   267 00:D21D: A0 33        notfnd  ldy     #ntfnms         ;point to message
   268 00:D21F: 80 5F                bra     remsg           ;send and exit
   269                        ;
   270                        ;execute ren command
   271                        ; ren <ufn> <ufn>
   272                        ;where first ufn is from name and second is to name
   273 00:D221: 20 03 D6     ren     jsr     prslin          ;get old name
   274 00:D224: D0 55                bne     renerr          ;error if afn
   275 00:D226: 20 FC D5             jsr     tmpold          ;save drive
   276 00:D229: 20 15 D7             jsr     clrslt          ;clear auto and select
   277 00:D22C: 20 94 D5             jsr     srchf1          ;if file does not exist
   278 00:D22F: 30 4D                bmi     fntfnd          ;then branch for error
   279 00:D231: 20 47 D7             jsr     frssec          ;move name to second half
   280 00:D234: AC E8 D9             ldy     cnbfpt          ;get pointer
   281 00:D237: B9 23 D9             lda     cnstxt,y        ;and then char
   282 00:D23A: C9 20                cmp     #' '            ;if not a space
   283 00:D23C: D0 3A                bne     rensyn          ;then error
   284 00:D23E: 20 03 D6             jsr     prslin          ;get new name
   285 00:D241: D0 35                bne     rensyn          ;error if afn
   286 00:D243: AD EA D9             lda     tmpdsk          ;get new drive
   287 00:D246: F0 10                beq     nonwdr          ;if zero ok
  Tue Apr 29 2025  4:23                                                                                                    Page 10


   288 00:D248: CD F2 D9             cmp     oldtmp          ;compare to old
   289 00:D24B: F0 0B                beq     nonwdr          ;ok if same
   290 00:D24D: 3A                   dec     a               ;subtract one ;-)
   291 00:D24E: CD E9 D9             cmp     dfldsk          ;if not default
   292 00:D251: D0 25                bne     rensyn          ;is error
   293 00:D253: AD F2 D9             lda     oldtmp          ;and then if from not
   294 00:D256: D0 20                bne     rensyn          ;default is error
   295 00:D258: AD F2 D9     nonwdr  lda     oldtmp          ;else get old
   296 00:D25B: 8D EA D9             sta     tmpdsk          ;and save
   297 00:D25E: 9C B3 D9             stz     fcbone+16       ;clear fcb offset
   298 00:D261: 20 15 D7             jsr     clrslt          ;reselect
   299 00:D264: 20 94 D5             jsr     srchf1          ;search for old
   300 00:D267: 10 0B                bpl     filexs          ;error if found
   301 00:D269: 20 47 D7             jsr     frssec          ;swap names
   302 00:D26C: 20 F7 D5             jsr     setone          ;point to fcb
   303 00:D26F: A2 17                ldx     #23             ;get rename file
   304 00:D271: 4C 03 01             jmp     pemjmp          ;call pem/return
   305                        ;ren file exists error handler
   306 00:D274: A0 3D        filexs  ldy     #flexms         ;point to
   307 00:D276: 80 08                bra     remsg           ;and send
   308                        ;ren syntax error handler
   309 00:D278: 20 67 D5     rensyn  jsr     rstddr          ;restore default
   310 00:D27B: 4C 52 D1     renerr  jmp     cmderr          ;do error
   311                        ;ren source file not found error handler
   312 00:D27E: A0 33        fntfnd  ldy     #ntfnms         ;point to
   313 00:D280: 4C 28 D7     remsg   jmp     sndmsg          ;and send
   314                        ;
   315                        ;execute save command
   316                        ; save <length> <drive:>ufn (<address>)
   317 00:D283: A9 00        save    lda     #<tea           ;set start address to tea start
   318 00:D285: A0 08                ldy     #>tea
   319 00:D287: 8D FB D9             sta     sadr
   320 00:D28A: 8C FC D9             sty     sadr+1
   321 00:D28D: 20 6C D7             jsr     bldnum          ;calculate length
   322 00:D290: D0 E9                bne     renerr          ;error if > 255 pages
   323 00:D292: 8D F1 D9             sta     length          ;else save low
   324 00:D295: 0D F1 D9             ora     length          ;test for zero length
   325 00:D298: F0 E1                beq     renerr          ;error if is
   326 00:D29A: 20 03 D6             jsr     prslin          ;get file name
   327 00:D29D: D0 DC                bne     renerr          ;error if afn
   328 00:D29F: 20 47 D7             jsr     frssec          ;move name to second half
   329 00:D2A2: 20 FC D5             jsr     tmpold          ;save drive
   330 00:D2A5: 20 6C D7             jsr     bldnum          ;it is so find value
   331 00:D2A8: AE A4 D9             ldx     fcbone+1        ;see if there
   332 00:D2AB: E0 20                cpx     #' '
   333 00:D2AD: F0 0A                beq     nosadr          ;it is not
   334 00:D2AF: 8D FB D9             sta     sadr            ;and set address
   335 00:D2B2: 8C FC D9             sty     sadr+1
   336 00:D2B5: C0 02                cpy     #2              ;make sure is high enough
   337 00:D2B7: 90 C2                bcc     renerr          ;error if not
   338 00:D2B9: 20 5A D7     nosadr  jsr     secfrs          ;move name back
   339 00:D2BC: 20 15 D7             jsr     clrslt          ;clear auto and select
   340 00:D2BF: 20 F7 D5             jsr     setone          ;point to fcb
   341 00:D2C2: A2 13                ldx     #19             ;delete file
   342 00:D2C4: 20 03 01             jsr     pemjmp          ;call pem
   343 00:D2C7: 20 F7 D5             jsr     setone          ;then create
   344 00:D2CA: A2 16                ldx     #22             ;get create file
   345 00:D2CC: 20 03 01             jsr     pemjmp          ;call pem
   346 00:D2CF: 30 54                bmi     noroom          ;say no room if error
   347 00:D2D1: 20 7D D5             jsr     open1           ;open file
   348 00:D2D4: 30 53                bmi     noopen          ;if error
   349 00:D2D6: 18                   clc                     ;now find end page
   350 00:D2D7: AD FC D9             lda     sadr+1
  Tue Apr 29 2025  4:23                                                                                                    Page 11


   351 00:D2DA: 6D F1 D9             adc     length
   352 00:D2DD: 8D F1 D9             sta     length
   353 00:D2E0: AD FB D9             lda     sadr            ;get start address
   354 00:D2E3: AC FC D9             ldy     sadr+1
   355 00:D2E6: 8D F3 D9     wrtmre  sta     dskbuf          ;set
   356 00:D2E9: 8C F4 D9             sty     dskbuf+1        ;buffer
   357                        ;
   358                        ;move record from disk buffer to default buffer
   359                        ; A/Y regs contain buffer address
   360 00:D2EC: 8D F5 D2             sta     mvfrom+1        ;and set pointer
   361 00:D2EF: 8C F6 D2             sty     mvfrom+2
   362 00:D2F2: A2 00                ldx     #0              ;clear index
   363 00:D2F4: BD FF FF     mvfrom  lda     $FFFF,x         ;get byte
   364 00:D2F7: 9D 28 01             sta     dflbuf,x        ;move it
   365 00:D2FA: E8                   inx
   366 00:D2FB: 10 F7                bpl     mvfrom          ;loop until done
   367                        ;
   368 00:D2FD: 20 F7 D5             jsr     setone          ;point to fcb
   369 00:D300: A2 15                ldx     #21             ;get write record
   370 00:D302: 20 03 01             jsr     pemjmp          ;call pem
   371 00:D305: D0 26                bne     wrterr          ;exit if error
   372 00:D307: 18                   clc                     ;else
   373 00:D308: AD F3 D9             lda     dskbuf          ;get old
   374 00:D30B: AC F4 D9             ldy     dskbuf+1        ;buffer
   375 00:D30E: 69 80                adc     #128            ;add 128
   376 00:D310: 90 03                bcc     donotc          ;if carry
   377 00:D312: C8                   iny                     ;bump upper
   378 00:D313: F0 05                beq     clssav          ;done if page zero
   379 00:D315: CC F1 D9     donotc  cpy     length          ;loop if upper
   380 00:D318: D0 CC                bne     wrtmre          ;not at limit
   381 00:D31A: 20 F7 D5     clssav  jsr     setone          ;else point to
   382 00:D31D: A2 10                ldx     #16             ;get close file
   383 00:D31F: 20 03 01             jsr     pemjmp          ;call pem
   384 00:D322: 30 0D                bmi     cantcl          ;say so if error
   385 00:D324: 60           extera  rts                     ;return to caller
   386                        ;save no room error handler
   387 00:D325: A0 00        noroom  ldy     #nospms         ;point to
   388 00:D327: 80 77                bra     temsg           ;and send
   389                        ;save can not open error handler
   390 00:D329: A0 54        noopen  ldy     #cnnoms         ;point to
   391 00:D32B: 80 73                bra     temsg           ;and send
   392                        ;save write error handler
   393 00:D32D: A0 61        wrterr  ldy     #wrerms         ;point
   394 00:D32F: 80 6F                bra     temsg           ;to and send
   395                        ;save can not close error
   396 00:D331: A0 09        cantcl  ldy     #ntclms         ;point to
   397 00:D333: 80 6B                bra     temsg           ;and send
   398                        ;
   399                        ;execute era command
   400                        ;
   401                        ; ** Update to the erase command - 6th March 2025 - KEM
   402                        ; standard erase command does not check for the filename
   403                        ; to be erased. If the file doesn't exist, erase completes
   404                        ; without any error message. This has been changed to
   405                        ; to check for the filename first... if it doesn't exist,
   406                        ; an error message of NOT FOUND is displayed. Otherwise,
   407                        ; erase completes after erasing the file.
   408                        ;
   409                        ; era <afn>
   410 00:D335: 20 03 D6     era     jsr     prslin          ;get file name
   411 00:D338: C9 0B                cmp     #11             ;if not all ?
   412 00:D33A: D0 15                bne     nteral          ;then skip verify
   413 00:D33C: A0 17                ldy     #alflms         ;else point to
  Tue Apr 29 2025  4:23                                                                                                    Page 12


   414 00:D33E: 20 28 D7             jsr     sndmsg          ;and send all files
   415 00:D341: A2 01                ldx     #1              ;console read
   416 00:D343: 20 03 01             jsr     pemjmp          ;call pem
   417 00:D346: 48                   pha                     ;and save
   418 00:D347: 20 59 D5             jsr     ccrlf           ;do a cr lf
   419 00:D34A: 68                   pla                     ;restore char
   420 00:D34B: 29 5F                and     #$5f            ;convert to upper case
   421 00:D34D: C9 59                cmp     #'Y'            ;if not y
   422 00:D34F: D0 D3                bne     extera          ;then quit
   423 00:D351: 20 15 D7     nteral  jsr     clrslt          ;clear auto and select
   424 00:D354: 20 94 D5             jsr     srchf1          ;check for file exists
   425 00:D357: 30 45                bmi     notype          ;no file to erase, branch
   426 00:D359: 20 F7 D5             jsr     setone          ;point to fcb (safety)
   427 00:D35C: A2 13                ldx     #19             ;delete file function
   428 00:D35E: 4C 03 01             jmp     pemjmp          ;call pem/return
   429                        ;
   430                        ;execute type command
   431                        ; type d:ufn
   432 00:D361: 20 03 D6     type    jsr     prslin          ;get file
   433 00:D364: D0 31                bne     typafn          ;error if afn
   434 00:D366: 20 7A D5             jsr     casdo1          ;clear - select - open file 1
   435 00:D369: 30 33                bmi     notype          ;error if not found
   436 00:D36B: 20 59 D5             jsr     ccrlf           ;else do cr lf
   437 00:D36E: 20 8C D5     typmre  jsr     read1           ;read record
   438 00:D371: F0 04                beq     okread          ;if ok continue
   439 00:D373: 10 AF                bpl     extera          ;exit if just end
   440 00:D375: 30 23                bmi     typerr          ;else error
   441 00:D377: A2 00        okread  ldx     #0              ;clear index
   442 00:D379: BD 28 01     typlpe  lda     dflbuf,x        ;get char
   443 00:D37C: C9 1A                cmp     #eof            ;if eof
   444 00:D37E: F0 A4                beq     extera          ;then exit
   445 00:D380: 20 C1 D5             jsr     cotsxy          ;else send
   446 00:D383: A2 0B                ldx     #11             ;check console for key down
   447 00:D385: 20 03 01             jsr     pemjmp          ;call pem
   448 00:D388: D0 0A                bne     exttok          ;then exit
   449 00:D38A: AE EF D9             ldx     savx            ;else get index
   450 00:D38D: E8                   inx                     ;bump it
   451 00:D38E: 10 E9                bpl     typlpe          ;and loop if < 128
   452 00:D390: 30 DC                bmi     typmre          ;else read more
   453 00:D392: A2 06                ldx     #6              ;get console read w/o echo
   454 00:D394: 4C 03 01     exttok  jmp     pemjmp          ;call pem/return
   455                        ;type syntax error handler
   456 00:D397: 4C 52 D1     typafn  jmp     cmderr          ;error return
   457                        ;type read error handler
   458 00:D39A: A0 28        typerr  ldy     #rderms         ;point to
   459 00:D39C: 80 02                bra     temsg           ;and send
   460                        ;type not found error handler
   461 00:D39E: A0 33        notype  ldy     #ntfnms         ;point to
   462 00:D3A0: 4C 28 D7     temsg   jmp     sndmsg          ;and send
   463                        ;
   464                        ;execute load command
   465                        ; load <ufn> (<address>)
   466 00:D3A3: 20 3C D7     load    jsr     setddb          ;set load start to tea start
   467 00:D3A6: 20 03 D6             jsr     prslin          ;build fcb
   468 00:D3A9: D0 EC                bne     typafn          ;error if afn
   469 00:D3AB: 20 47 D7             jsr     frssec          ;save in second half
   470 00:D3AE: 20 FC D5             jsr     tmpold          ;save file
   471 00:D3B1: 20 6C D7             jsr     bldnum          ;find start address
   472 00:D3B4: AE A4 D9             ldx     fcbone+1        ;see if number
   473 00:D3B7: E0 20                cpx     #' '
   474 00:D3B9: F0 03                beq     usedfl          ;if none use default
   475 00:D3BB: 20 40 D7             jsr     setdb           ;and set
   476 00:D3BE: 20 5A D7     usedfl  jsr     secfrs          ;move name back
  Tue Apr 29 2025  4:23                                                                                                    Page 13


   477 00:D3C1: 20 7A D5             jsr     casdo1          ;clear - select - open file 1
   478 00:D3C4: 30 D8                bmi     notype          ;exit if not found
   479 00:D3C6: AD F3 D9             lda     dskbuf          ;get load start
   480 00:D3C9: AC F4 D9             ldy     dskbuf+1
   481 00:D3CC: A2 1A        lcmdlp  ldx     #26             ;set disk buffer
   482 00:D3CE: 20 03 01             jsr     pemjmp          ;call pem
   483 00:D3D1: 20 8C D5             jsr     read1           ;read record
   484 00:D3D4: D0 05                bne     loadnd          ;done if not zero
   485 00:D3D6: 20 F7 D7             jsr     adjdb           ;bump address
   486 00:D3D9: 80 F1                bra     lcmdlp          ;and loop
   487 00:D3DB: 30 BD        loadnd  bmi     typerr          ;if error say so
   488 00:D3DD: 4C 0C D7             jmp     stdflb          ;back to default buffer
   489                        ;
   490                        ;execute GO command
   491                        ; go (<address>)
   492 00:D3E0: 20 6C D7     go      jsr     bldnum          ;get address
   493 00:D3E3: AE A4 D9             ldx     fcbone+1        ;get first char
   494 00:D3E6: E0 20                cpx     #' '            ;see if nothing
   495 00:D3E8: F0 03                beq     nolnum          ;nothing so use tea
   496 00:D3EA: 4C EB D4             jmp     godoit          ;then execute
   497 00:D3ED: 4C E7 D4     nolnum  jmp     gotea
   498                        ;
   499                        ;execute USER command
   500                        ; user (<number>)
   501 00:D3F0: 20 6C D7     user    jsr     bldnum          ;build number
   502 00:D3F3: AE A4 D9             ldx     fcbone+1        ;get first character
   503 00:D3F6: E0 20                cpx     #' '            ;see if nothing
   504 00:D3F8: F0 26                beq     usrext          ;done if nothing
   505 00:D3FA: AD F8 D9             lda     num+1           ;check high
   506 00:D3FD: D0 0C                bne     usrerr          ;error if too big
   507 00:D3FF: AD F7 D9             lda     num             ;get low
   508 00:D402: C9 10                cmp     #16             ;see if too big
   509 00:D404: B0 05                bcs     usrerr          ;error if is
   510                        ;set user code from A reg
   511 00:D406: A2 24        setusr  ldx     #36             ;set user
   512 00:D408: 4C 03 01             jmp     pemjmp          ;call pem/return
   513                        ;
   514                        ;bad user number entered
   515 00:D40B: A0 6D        usrerr  ldy     #userms         ;get error message
   516 00:D40D: 80 91                bra     temsg
   517                        ;user code (usrcde) related routines
   518                        ;get user code from PEM
   519 00:D40F: A9 FF        getusr  lda     #255            ;query parameter
   520 00:D411: 80 F3                bra     setusr          ;branch to get user code
   521                        ;
   522                        ;Save user code in A in case of action that may
   523                        ;destroy or alter it.
   524 00:D413: 20 0F D4     savusr  jsr     getusr          ;get usrcde from PEM
   525 00:D416: 0A                   asl     a               ;shift code to high nibble
   526 00:D417: 0A                   asl     a
   527 00:D418: 0A                   asl     a
   528 00:D419: 0A                   asl     a
   529 00:D41A: 0D E9 D9             ora     dfldsk          ;paste default disk into
   530 00:D41D: 8D 06 01             sta     iostat          ;iostat and save
   531 00:D420: 60           usrext  rts                     ;return to caller
   532                        ;
   533                        ;execute SYSTEM command
   534                        ; New command for Version 3.21
   535                        ; shows locations for:
   536                        ; - Zero Page, BIOS, TEA, CCM, PEM, SIM and Disc Allocation Maps
   537                        ;
   538 00:D421: A2 00        system  ldx     #0              ;clear index
   539 00:D423: BC CC D8     mem_lp  ldy     msgtb,x         ;get message index #
  Tue Apr 29 2025  4:23                                                                                                    Page 14


   540 00:D426: DA                   phx                     ;save index
   541 00:D427: 20 31 D7             jsr     lpesnd          ;send to console
   542 00:D42A: FA                   plx                     ;restore index
   543 00:D42B: BD D3 D8             lda     memstl,x        ;get low byte
   544 00:D42E: BC DA D8             ldy     memsth,x        ;get high byte
   545 00:D431: DA                   phx                     ;save index
   546 00:D432: 20 7E D4             jsr     prword          ;send to console
   547 00:D435: FA                   plx                     ;restore index
   548 00:D436: BD E1 D8             lda     memenl,x        ;get low byte
   549 00:D439: BC E8 D8             ldy     memenh,x        ;get high byte
   550 00:D43C: DA                   phx                     ;save index
   551 00:D43D: 20 71 D4             jsr     snddsh          ;finish subtract and send to console
   552 00:D440: FA                   plx                     ;restore index
   553 00:D441: E8                   inx                     ;increment index
   554 00:D442: E0 07                cpx     #7              ;compare for 7 loops
   555 00:D444: D0 DD                bne     mem_lp          ;loop back till done
   556 00:D446: 4C 59 D5             jmp     ccrlf           ;send cr/lf and return
   557                        ;
   558                        ;BIN2ASC subroutine: Convert single byte to two ASCII HEX digits
   559                        ; Enter: A Register contains byte value to convert
   560                        ; Return: A Register = high digit, Y Register = low digit
   561 00:D449: 48           bin2asc  pha                     ;save A Reg on stack
   562 00:D44A: 29 0F                 and     #$0f            ;mask off high nibble
   563 00:D44C: 20 55 D4              jsr     ascii           ;convert nibble to ASCII HEX digit
   564 00:D44F: A8                    tay                     ;move to Y Reg
   565 00:D450: 68                    pla                     ;get character back from stack
   566 00:D451: 4A                    lsr     a               ;shift high nibble to lower 4 bits
   567 00:D452: 4A                    lsr     a
   568 00:D453: 4A                    lsr     a
   569 00:D454: 4A                    lsr     a
   570                        ;
   571 00:D455: C9 0A        ascii    cmp     #$0a            ;check for 10 or less
   572 00:D457: 90 02                 bcc     ascok           ;branch if less than 10
   573 00:D459: 69 06                 adc     #$06            ;add $06+CF ($07) for A-F
   574 00:D45B: 69 30        ascok    adc     #$30            ;add $30 for ASCII
   575 00:D45D: 60                    rts                     ;return to caller
   576                        ;
   577                        ;PRBYTE subroutine: Converts a single Byte to 2 HEX ASCII characters and sends to console on
   578                        ; entry, A Reg contains the Byte to convert/send. Register contents are preserved on entry/exit.
   579 00:D45E: 48           prbyte   pha                     ;save A Register
   580 00:D45F: 5A                    phy                     ;save Y Register
   581 00:D460: 20 49 D4     prbyt2   jsr     bin2asc         ;convert A Reg to 2 ASCII Hex characters
   582 00:D463: A2 02                 ldx     #2              ;console output
   583 00:D465: 20 03 01              jsr     pemjmp          ;call pem
   584 00:D468: 98                    tya                     ;transfer low nibble to A Reg
   585 00:D469: A2 02                 ldx     #2              ;console output
   586 00:D46B: 20 03 01              jsr     pemjmp          ;call pem
   587 00:D46E: 7A                    ply                     ;restore Y Register
   588 00:D46F: 68                    pla                     ;restore A Register
   589 00:D470: 60                    rts                     ;return to caller
   590                        ;
   591                        ;Send Dash routine
   592 00:D471: 48           snddsh  pha                     ;save A reg
   593 00:D472: A9 2D                lda     #"-"            ;get a dash character
   594 00:D474: A2 02                ldx     #2              ;console output
   595 00:D476: 20 03 01             jsr     pemjmp          ;call pem
   596 00:D479: 68                   pla                     ;restore A reg
   597                        ;
   598                        ;Decrement by one (16-bit)
   599                        ; - note Z flag set from PLA above
   600 00:D47A: D0 01        dec16   bne     skphb           ;branch if low byte (A reg) is non-zero
   601 00:D47C: 88                   dey                     ;else, decrement high byte
   602 00:D47D: 3A           skphb   dec     a               ;decrement low byte
  Tue Apr 29 2025  4:23                                                                                                    Page 15


   603                        ;
   604                        ;PRWORD subroutine: Converts a 16-bit word to 4 HEX ASCII characters and sends to console. On
   605                        ; entry, A Reg contains Low Byte, Y Reg contains High Byte. Registers are preserved on entry/exit.
   606                        ; NOTE: Routine changed for consistency; A Reg = Low byte, Y Reg = High byte on 2nd May 2020
   607 00:D47E: 48           prword   pha                     ;save A Register (Low)
   608 00:D47F: 5A                    phy                     ;save Y Register (High)
   609 00:D480: 48                    pha                     ;save Low byte again
   610 00:D481: 98                    tya                     ;xfer High byte to A Reg
   611 00:D482: 20 5E D4              jsr     prbyte          ;convert and print one HEX character (00-FF)
   612 00:D485: 68                    pla                     ;get Low byte value
   613 00:D486: 80 D8                 bra     prbyt2          ;finish up Low Byte and exit
   614                        ;
   615                        ;execute trns (transient) command
   616                        ; <ufn> (<fn>) (<fn>)
   617 00:D488: AD A4 D9     trns    lda     fcbone+1        ;get first char
   618 00:D48B: C9 20                cmp     #' '            ;if not space
   619 00:D48D: D0 11                bne     chktyp          ;check type
   620 00:D48F: AD EA D9             lda     tmpdsk          ;else test temp
   621 00:D492: F0 09                beq     skpdrv          ;if none skip
   622 00:D494: 3A                   dec     a               ;subtract one ;-)
   623 00:D495: 8D E9 D9             sta     dfldsk          ;set default
   624 00:D498: A2 0E                ldx     #14             ;select drive
   625 00:D49A: 20 03 01             jsr     pemjmp          ;call pem
   626 00:D49D: 4C 3E D1     skpdrv  jmp     extwod          ;return
   627 00:D4A0: AD AC D9     chktyp  lda     fcbone+9        ;get type
   628 00:D4A3: C9 20                cmp     #' '            ;if space
   629 00:D4A5: F0 03                beq     typemp          ;then ok
   630 00:D4A7: 4C 51 D5             jmp     trnerr          ;else error
   631 00:D4AA: A2 02        typemp  ldx     #2              ;make
   632 00:D4AC: BD E5 D9     setcom  lda     typcom,x        ;type
   633 00:D4AF: 9D AC D9             sta     fcbone+9,x      ;com
   634 00:D4B2: CA                   dex                     ;then
   635 00:D4B3: 10 F7                bpl     setcom          ;continue
   636 00:D4B5: 20 7A D5             jsr     casdo1          ;clear - select - open file one
   637 00:D4B8: 10 03                bpl     gottrn          ;jump if ok
   638 00:D4BA: 4C 4E D5             jmp     topner          ;else do error
   639 00:D4BD: 20 3C D7     gottrn  jsr     setddb          ;set start to tea
   640 00:D4C0: A2 1A        nxtrcr  ldx     #26             ;set buffer address
   641 00:D4C2: 20 03 01             jsr     pemjmp          ;call pem
   642 00:D4C5: 20 8C D5             jsr     read1           ;read fcb 1
   643 00:D4C8: D0 1B                bne     endlde          ;branch if error or eof
   644 00:D4CA: 20 F7 D7             jsr     adjdb           ;adjust address up by 128
   645 00:D4CD: C9 10                cmp     #<ccmram        ;if new low
   646 00:D4CF: 90 06                bcc     tryhig          ;ok try high
   647 00:D4D1: C0 D0                cpy     #>ccmram        ;else if high
   648 00:D4D3: 90 EB                bcc     nxtrcr          ;ok do more
   649 00:D4D5: B0 06                bcs     chklnd          ;else check for end
   650 00:D4D7: C0 D0        tryhig  cpy     #>ccmram        ;if high less
   651 00:D4D9: 90 E5                bcc     nxtrcr          ;then ok
   652 00:D4DB: F0 E3                beq     nxtrcr          ;or ok if same
   653 00:D4DD: 20 0C D7     chklnd  jsr     stdflb          ;set buffer to default
   654 00:D4E0: 20 8C D5             jsr     read1           ;read (should be eof)
   655 00:D4E3: F0 6F                beq     tlderr          ;error if more
   656 00:D4E5: 30 6D        endlde  bmi     tlderr          ;do error
   657 00:D4E7: A9 00        gotea   lda     #<tea           ;set go address to tea start
   658 00:D4E9: A0 08                ldy     #>tea
   659 00:D4EB: 8D 41 D5     godoit  sta     do+1            ;set to ay
   660 00:D4EE: 8C 42 D5             sty     do+2
   661 00:D4F1: 20 67 D5             jsr     rstddr          ;else restore default
   662 00:D4F4: 20 03 D6             jsr     prslin          ;parse file
   663 00:D4F7: AD EA D9             lda     tmpdsk          ;set auto
   664 00:D4FA: 8D A3 D9             sta     fcbone          ;select position
   665 00:D4FD: A2 10                ldx     #16             ;do a second
  Tue Apr 29 2025  4:23                                                                                                    Page 16


   666 00:D4FF: 20 05 D6             jsr     prsmre          ;fcb if there
   667 00:D502: AD EA D9             lda     tmpdsk          ;set auto select
   668 00:D505: 8D B3 D9             sta     fcbone+16       ;again
   669 00:D508: A0 00                ldy     #0              ;clear record
   670 00:D50A: 8C C3 D9             sty     fcbone+32       ;counter
   671 00:D50D: A2 20                ldx     #32             ;move
   672 00:D50F: BD A3 D9     movfcb  lda     fcbone,x        ;all
   673 00:D512: 9D 07 01             sta     dflfcb,x        ;to
   674 00:D515: CA                   dex                     ;default
   675 00:D516: 10 F7                bpl     movfcb          ;fcb
   676 00:D518: E8                   inx                     ;set x to zero
   677 00:D519: B9 23 D9     tstbuf  lda     cnstxt,y        ;get char
   678 00:D51C: F0 07                beq     isnull          ;if null jump
   679 00:D51E: C9 20                cmp     #' '            ;or if space
   680 00:D520: F0 03                beq     isnull          ;jump
   681 00:D522: C8                   iny                     ;else bump pointer
   682 00:D523: D0 F4                bne     tstbuf          ;and loop
   683 00:D525: 9C 28 01     isnull  stz     dflbuf          ;clear count
   684 00:D528: B9 23 D9     movbuf  lda     cnstxt,y        ;get char
   685 00:D52B: 9D 29 01             sta     dflbuf+1,x      ;and move
   686 00:D52E: F0 07                beq     fillov          ;exit if null
   687 00:D530: E8                   inx                     ;increment
   688 00:D531: C8                   iny                     ;counters
   689 00:D532: EE 28 01             inc     dflbuf          ;and length
   690 00:D535: D0 F1                bne     movbuf          ;and loop
   691 00:D537: 20 59 D5     fillov  jsr     ccrlf           ;do a cr lf
   692 00:D53A: 20 0C D7             jsr     stdflb          ;set default
   693 00:D53D: 20 13 D4             jsr     savusr          ;save user code
   694 00:D540: 20 00 08     do      jsr     tea             ;call execute jmp
   695 00:D543: AD E9 D9             lda     dfldsk          ;get default
   696 00:D546: A2 0E                ldx     #14             ;select drive
   697 00:D548: 20 03 01             jsr     pemjmp          ;call pem
   698 00:D54B: 4C 4B D0             jmp     ccmlpe          ;then loop to start
   699                        ;trns syntax error handler
   700 00:D54E: 20 67 D5     topner  jsr     rstddr          ;restore default
   701 00:D551: 4C 52 D1     trnerr  jmp     cmderr          ;do error
   702                        ;trns load error
   703 00:D554: A0 49        tlderr  ldy     #lderms         ;point to
   704 00:D556: 4C 28 D7             jmp     sndmsg          ;and send it, then return
   705                        ;
   706                        ;carriage return and linefeed
   707 00:D559: A9 0D        ccrlf   lda     #cr             ;get a cr
   708 00:D55B: A2 02                ldx     #2              ;console output
   709 00:D55D: 20 03 01             jsr     pemjmp          ;call pem
   710 00:D560: A9 0A                lda     #lf             ;get a lf
   711 00:D562: A2 02                ldx     #2              ;console output
   712 00:D564: 4C 03 01             jmp     pemjmp          ;call pem/return
   713                        ;
   714                        ;restore default drive
   715 00:D567: AD EA D9     rstddr  lda     tmpdsk          ;get temp drive,
   716 00:D56A: F0 1F                beq     extddr          ;if zero, exit
   717 00:D56C: 3A                   dec     a               ;else, subtract one
   718 00:D56D: CD E9 D9             cmp     dfldsk          ;compare to default
   719 00:D570: F0 19                beq     extddr          ;exit if same
   720 00:D572: AD E9 D9     seldfl  lda     dfldsk          ;else, get default
   721 00:D575: A2 0E                ldx     #14             ;select drive
   722 00:D577: 4C 03 01             jmp     pemjmp          ;call pem/return
   723                        ;
   724                        ;clear auto - select disk - open file at fcbone
   725 00:D57A: 20 15 D7     casdo1  jsr     clrslt          ;clear auto and select
   726                        ;open file one
   727                        ; returns:n=1 if not found
   728 00:D57D: 9C C3 D9     open1   stz     fcbone+32       ;clear record number
  Tue Apr 29 2025  4:23                                                                                                    Page 17


   729 00:D580: 20 F7 D5             jsr     setone          ;point to fcb
   730 00:D583: A2 0F                ldx     #15             ;get open file
   731 00:D585: 20 03 01             jsr     pemjmp          ;call pem
   732 00:D588: 8D EE D9             sta     diradd          ;save number
   733 00:D58B: 60           extddr  rts                     ;return to caller
   734                        ;read file one
   735 00:D58C: 20 F7 D5     read1   jsr     setone          ;point to fcb
   736 00:D58F: A2 14                ldx     #20             ;get read record
   737 00:D591: 4C 03 01             jmp     pemjmp          ;call pem/return
   738                        ;search for first file one
   739                        ; returns:n=1 if not found
   740 00:D594: 20 F7 D5     srchf1  jsr     setone          ;point to fcb
   741 00:D597: A2 11                ldx     #17             ;get search file
   742 00:D599: 20 03 01             jsr     pemjmp          ;call pem
   743 00:D59C: 8D EE D9             sta     diradd          ;save number
   744 00:D59F: 60                   rts                     ;return to caller
   745                        ;header output
   746 00:D5A0: 20 59 D5     hdrout  jsr     ccrlf           ;do cr lf
   747 00:D5A3: A2 19        hdr     ldx     #25             ;get init disk
   748 00:D5A5: 20 03 01             jsr     pemjmp          ;call pem
   749 00:D5A8: 18                   clc                     ;add "A" to make it
   750 00:D5A9: 69 41                adc     #'A'            ;a drive letter
   751 00:D5AB: 20 C1 D5             jsr     cotsxy          ;send drive letter
   752                        ;drive letter is written now do user number
   753 00:D5AE: 20 0F D4             jsr     getusr          ;get user number
   754 00:D5B1: C9 0A                cmp     #10             ;see if < 10
   755 00:D5B3: 90 0A                bcc     usr09           ;if so use as is
   756 00:D5B5: 48                   pha                     ;else, save number,
   757 00:D5B6: A9 31                lda     #'1'            ;send an ASCII 1
   758 00:D5B8: 20 C1 D5             jsr     cotsxy          ;to the console
   759 00:D5BB: 68                   pla                     ;get user number back
   760 00:D5BC: 38                   sec                     ;subtract 10,
   761 00:D5BD: E9 0A                sbc     #10             ;then get remainder
   762 00:D5BF: 09 30        usr09   ora     #'0'            ;convert to ASCII
   763                        ;
   764                        ;drop in to cotsxy
   765                        ;
   766                        ;output with save of x and y
   767 00:D5C1: 8E EF D9     cotsxy  stx     savx            ;save x
   768 00:D5C4: 8C F0 D9             sty     savy            ;and y
   769                        ;test character
   770                        ; input:a=character
   771                        ; returns:c=0 if control or c=1 if printing
   772                        ; alters:p
   773 00:D5C7: C9 0D                cmp     #cr             ;if cr
   774 00:D5C9: F0 0A                beq     tstcxt          ;quit
   775 00:D5CB: C9 0A                cmp     #lf             ;if linefeed
   776 00:D5CD: F0 06                beq     tstcxt          ;quit
   777 00:D5CF: C9 09                cmp     #ctli           ;if tab
   778 00:D5D1: F0 02                beq     tstcxt          ;quit
   779 00:D5D3: C9 20                cmp     #' '            ;see if control
   780                        ;
   781                        tstcxt
   782 00:D5D5: B0 14                bcs     isprnt          ;jump if is
   783 00:D5D7: 48                   pha                     ;else save
   784 00:D5D8: AD 3B E4             lda     sysdef+4        ;get invert
   785 00:D5DB: A2 02                ldx     #2              ;console output
   786 00:D5DD: 20 03 01             jsr     pemjmp          ;call pem
   787 00:D5E0: 68                   pla                     ;get char
   788 00:D5E1: 09 40                ora     #'@'            ;make printing
   789 00:D5E3: A2 02                ldx     #2              ;console output
   790 00:D5E5: 20 03 01             jsr     pemjmp          ;call pem
   791 00:D5E8: AD 3A E4             lda     sysdef+3        ;get normal
  Tue Apr 29 2025  4:23                                                                                                    Page 18


   792 00:D5EB: A2 02        isprnt  ldx     #2              ;console output
   793 00:D5ED: 20 03 01             jsr     pemjmp          ;call pem
   794 00:D5F0: AC F0 D9             ldy     savy            ;get y
   795 00:D5F3: AE EF D9             ldx     savx            ;and x
   796 00:D5F6: 60                   rts                     ;return to caller
   797                        ;
   798                        ;set up fcb one pointer
   799 00:D5F7: A9 A3        setone  lda     #<fcbone        ;low
   800 00:D5F9: A0 D9                ldy     #>fcbone        ;and high
   801 00:D5FB: 60                   rts                     ;return to caller
   802                        ;
   803                        ;save tmpdsk in oldtmp
   804 00:D5FC: AD EA D9     tmpold  lda     tmpdsk
   805 00:D5FF: 8D F2 D9             sta     oldtmp
   806 00:D602: 60                   rts                     ;return to caller
   807                        ;
   808                        ;parse command line
   809 00:D603: A2 00        prslin  ldx     #0              ;clear index
   810 00:D605: DA           prsmre  phx                     ;save index
   811 00:D606: 9C EA D9             stz     tmpdsk          ;clear temp drive flag
   812 00:D609: AC E8 D9             ldy     cnbfpt          ;get buffer pointer
   813 00:D60C: 20 DA D6             jsr     skpspc          ;find first non-space
   814 00:D60F: 8C ED D9             sty     curpnt          ;save index
   815 00:D612: F0 0D                beq     nulchr          ;branch if null
   816                        ;
   817                        ;The "and" instruction below is to strip off ascii bits that are drive letter related!
   818                        ; by doing so, A - H becomes %0001 - %1000 (1-8), which can be a real problem...
   819                        ; if the next character is a semicolon (:). that 4-bit masked value becomes the
   820                        ; TMPDSK variable, which is spliced into the FCB and becomes the selected drive.
   821                        ; As a result, any ascii character can be entered and you wind up with a list of
   822                        ; phantom drive letters, depending on what was entered, alpha or not.
   823                        ;
   824                        ; The fix here is to mask off the lower 7 bits for true ascii, then let this
   825                        ; routine below starting at "drvinp" complete the check for a valid drive letter.
   826                        ;
   827 00:D614: 29 7F                and     #%01111111      ;strip off bit 7 for ascii only
   828 00:D616: 48                   pha                     ;and save to stack
   829 00:D617: C8                   iny                     ;point to next char
   830 00:D618: B9 23 D9             lda     cnstxt,y        ;and get it
   831 00:D61B: C9 3A                cmp     #':'            ;if it's a colon
   832 00:D61D: F0 0A                beq     drvinp          ;branch and set drive
   833 00:D61F: 68                   pla                     ;else clear stack
   834 00:D620: 88                   dey                     ;backup the index
   835 00:D621: AD E9 D9     nulchr  lda     dfldsk          ;set automatic
   836 00:D624: 9D A3 D9             sta     fcbone,x        ;to default drive
   837 00:D627: 80 1A                bra     trynme          ;then branch to parse name
   838                        ;
   839                        ;at this stage, we get the ascii character back from the stack, which is the
   840                        ; assumed drive letter. Now we need to range check this and ensure it's within
   841                        ; the range of a-z or A-Z. First, we'll convert lower case to upper case, then
   842                        ; check for the proper range. If the character is outside of the range, we can
   843                        ; simply set it for the acceptable range plus one. This will be caught by the
   844                        ; PEM routine and flagged as a drive out of range.
   845                        ;
   846 00:D629: 68           drvinp  pla                     ;get the "drive letter" back
   847 00:D62A: C9 61                cmp     #$61            ;check for lower case ascii/control characters
   848 00:D62C: 90 02                bcc     ucok            ;if lower, upper case is okay
   849 00:D62E: E9 20                sbc     #$20            ;else subtract $20 to convert to upper case
   850 00:D630: C9 41        ucok    cmp     #'A'            ;compare for ascii "A" or higher
   851 00:D632: 90 04                bcc     baddrv          ;branch if too low
   852 00:D634: C9 49                cmp     #maxdrv+$41     ;check for ascii of maxdrv or higher
   853 00:D636: 90 02                bcc     drvok           ;if okay, branch and set drive
   854 00:D638: A9 49        baddrv  lda     #maxdrv+$41     ;else, get first out of range drive
  Tue Apr 29 2025  4:23                                                                                                    Page 19


   855                        ;
   856 00:D63A: 29 0F        drvok   and     #%00001111      ;mask off upper 4 bits
   857 00:D63C: 8D EA D9             sta     tmpdsk          ;set as temp disk
   858 00:D63F: 9D A3 D9             sta     fcbone,x        ;and into fcb
   859 00:D642: C8                   iny                     ;increment pointer past colon
   860 00:D643: A9 08        trynme  lda     #8              ;set name count
   861 00:D645: 8D EC D9             sta     count           ;to eight
   862 00:D648: 20 E7 D6     tstnme  jsr     tstlgl          ;test for illegal
   863 00:D64B: F0 1D                beq     flnmsp          ;if illegal jump
   864 00:D64D: E8                   inx                     ;bump pointer
   865 00:D64E: C9 2A                cmp     #'*'            ;if not *
   866 00:D650: D0 07                bne     notafn          ;skip ? fill
   867 00:D652: A9 3F                lda     #'?'            ;get a ?
   868 00:D654: 9D A3 D9             sta     fcbone,x        ;store it,
   869 00:D657: 80 04                bra     nxtout          ;then branch
   870 00:D659: 9D A3 D9     notafn  sta     fcbone,x        ;store char
   871 00:D65C: C8                   iny                     ;bump source
   872 00:D65D: CE EC D9     nxtout  dec     count           ;drop counter down
   873 00:D660: D0 E6                bne     tstnme          ;and loop
   874 00:D662: 20 E7 D6     skpmre  jsr     tstlgl          ;if illegal
   875 00:D665: F0 11                beq     trytyp          ;try type
   876 00:D667: C8                   iny                     ;else bump index
   877 00:D668: D0 F8                bne     skpmre          ;and loop
   878 00:D66A: E8           flnmsp  inx                     ;next position
   879 00:D66B: A9 20                lda     #' '            ;get a space
   880 00:D66D: 9D A3 D9             sta     fcbone,x        ;store
   881 00:D670: CE EC D9             dec     count           ;count down
   882 00:D673: D0 F5                bne     flnmsp          ;and loop
   883 00:D675: B9 23 D9             lda     cnstxt,y        ;get char again
   884 00:D678: 48           trytyp  pha                     ;save char
   885 00:D679: A9 03                lda     #3              ;set count
   886 00:D67B: 8D EC D9             sta     count           ;to three
   887 00:D67E: 68                   pla                     ;get char
   888 00:D67F: C9 2E                cmp     #'.'            ;if not .
   889 00:D681: D0 23                bne     fltysp          ;then fill spaces
   890 00:D683: C8                   iny                     ;else bump source
   891 00:D684: 20 E7 D6     tsttyp  jsr     tstlgl          ;if not legal
   892 00:D687: F0 1D                beq     fltysp          ;then fill spaces
   893 00:D689: E8                   inx                     ;else bump index
   894 00:D68A: C9 2A                cmp     #'*'            ;if not *
   895 00:D68C: D0 07                bne     notaft          ;then skip fill
   896 00:D68E: A9 3F                lda     #'?'            ;else get ?
   897 00:D690: 9D A3 D9             sta     fcbone,x        ;move to fcb
   898 00:D693: D0 04                bne     mrtyfl          ;and loop
   899 00:D695: 9D A3 D9     notaft  sta     fcbone,x        ;move char to fcb
   900 00:D698: C8                   iny                     ;bump source
   901 00:D699: CE EC D9     mrtyfl  dec     count           ;count down
   902 00:D69C: D0 E6                bne     tsttyp          ;and loop
   903 00:D69E: 20 E7 D6     nttype  jsr     tstlgl          ;if illegal
   904 00:D6A1: F0 0E                beq     filnul          ;fill out nulls
   905 00:D6A3: C8                   iny                     ;else bump source
   906 00:D6A4: D0 F8                bne     nttype          ;and loop
   907 00:D6A6: E8           fltysp  inx                     ;bump fcb pointer
   908 00:D6A7: A9 20                lda     #' '            ;get space
   909 00:D6A9: 9D A3 D9             sta     fcbone,x        ;put in fcb
   910 00:D6AC: CE EC D9             dec     count           ;count down
   911 00:D6AF: D0 F5                bne     fltysp          ;and continue
   912 00:D6B1: A9 03        filnul  lda     #3              ;clear
   913 00:D6B3: 8D EC D9             sta     count           ;three
   914 00:D6B6: E8           mrnlty  inx                     ;bump fcb pointer
   915 00:D6B7: 9E A3 D9             stz     fcbone,x        ;clear fcb
   916 00:D6BA: CE EC D9             dec     count           ;count down
   917 00:D6BD: D0 F7                bne     mrnlty          ;loop until done
  Tue Apr 29 2025  4:23                                                                                                    Page 20


   918 00:D6BF: 8C E8 D9             sty     cnbfpt          ;update start pointer
   919 00:D6C2: 9C EC D9             stz     count           ;clear count
   920 00:D6C5: 7A                   ply                     ;restore stack
   921 00:D6C6: A2 0B                ldx     #11             ;counter to 11
   922 00:D6C8: C8           tstqus  iny                     ;point to
   923 00:D6C9: B9 A3 D9             lda     fcbone,y        ;and get char
   924 00:D6CC: C9 3F                cmp     #'?'            ;if not a ?
   925 00:D6CE: D0 03                bne     nxtqus          ;then jump
   926 00:D6D0: EE EC D9             inc     count           ;else bump count
   927 00:D6D3: CA           nxtqus  dex                     ;loop until
   928 00:D6D4: D0 F2                bne     tstqus          ;11 tested
   929 00:D6D6: AD EC D9             lda     count           ;get count
   930 00:D6D9: 60                   rts                     ;and return
   931                        ;skip space
   932 00:D6DA: B9 23 D9     skpspc  lda     cnstxt,y        ;get char
   933 00:D6DD: F0 07                beq     extskp          ;jump if null
   934 00:D6DF: C9 20                cmp     #' '            ;if not space
   935 00:D6E1: D0 03                bne     extskp          ;then exit
   936 00:D6E3: C8                   iny                     ;else go to next
   937 00:D6E4: D0 F4                bne     skpspc          ;and test
   938 00:D6E6: 60           extskp  rts                     ;return to caller
   939                        ;test legal
   940 00:D6E7: B9 23 D9     tstlgl  lda     cnstxt,y        ;get char
   941 00:D6EA: F0 1C                beq     extlgl
   942 00:D6EC: C9 20                cmp     #' '            ;if space
   943 00:D6EE: 90 19                bcc     badinp          ;ok - less is error
   944 00:D6F0: F0 16                beq     extlgl
   945 00:D6F2: C9 3D                cmp     #'='
   946 00:D6F4: F0 12                beq     extlgl
   947 00:D6F6: C9 2E                cmp     #'.'
   948 00:D6F8: F0 0E                beq     extlgl
   949 00:D6FA: C9 3A                cmp     #':'
   950 00:D6FC: F0 0A                beq     extlgl
   951 00:D6FE: C9 3B                cmp     #semico
   952 00:D700: F0 06                beq     extlgl
   953 00:D702: C9 3C                cmp     #'<'
   954 00:D704: F0 02                beq     extlgl
   955 00:D706: C9 3E                cmp     #'>'
   956 00:D708: 60           extlgl  rts                     ;return to caller
   957 00:D709: 4C 52 D1     badinp  jmp     cmderr
   958                        ;
   959                        ;set default buffer address
   960 00:D70C: A9 28        stdflb  lda     #<dflbuf        ;point to
   961 00:D70E: A0 01                ldy     #>dflbuf        ;location
   962 00:D710: A2 1A                ldx     #26             ;set buffer
   963 00:D712: 4C 03 01             jmp     pemjmp          ;call pem/return
   964                        ;
   965                        ;clear automatic and select
   966 00:D715: 9C A3 D9     clrslt  stz     fcbone          ;clear auto select
   967 00:D718: AD EA D9     slttmp  lda     tmpdsk          ;get temp
   968 00:D71B: F0 29                beq     extsnd          ;if zero exit
   969 00:D71D: 3A                   dec     a               ;subtract one ;-)
   970 00:D71E: CD E9 D9             cmp     dfldsk          ;if same as default
   971 00:D721: F0 23                beq     extsnd          ;then quit
   972 00:D723: A2 0E                ldx     #14             ;select drive
   973 00:D725: 4C 03 01             jmp     pemjmp          ;call pem/return
   974                        ;
   975                        ;send message
   976 00:D728: 8C F0 D9     sndmsg  sty     savy            ;save index
   977 00:D72B: 20 59 D5             jsr     ccrlf           ;do cr and lf
   978 00:D72E: AC F0 D9             ldy     savy            ;get index
   979 00:D731: B9 1D D8     lpesnd  lda     msgtbl,y        ;get char
   980 00:D734: F0 10                beq     extsnd          ;if null quit
  Tue Apr 29 2025  4:23                                                                                                    Page 21


   981 00:D736: 20 C1 D5             jsr     cotsxy          ;else send
   982 00:D739: C8                   iny                     ;point to next
   983 00:D73A: 80 F5                bra     lpesnd          ;and loop
   984                        ;
   985                        ;set load start address
   986 00:D73C: A9 00        setddb  lda     #<tea           ;to tea start
   987 00:D73E: A0 08                ldy     #>tea
   988 00:D740: 8D F3 D9     setdb   sta     dskbuf          ;to ay
   989 00:D743: 8C F4 D9             sty     dskbuf+1
   990 00:D746: 60           extsnd  rts                     ;return to caller
   991                        ;
   992                        ;move first part of fcb to second half
   993                        ;and move second part to first part.
   994                        ;only ren depends upon this routine to actually
   995                        ;swap fcb halves.
   996                        ;alters:a,x,p
   997                        ;returns:x=$ff
   998 00:D747: A2 0F        frssec  ldx     #15             ;set index to last
   999 00:D749: BD A3 D9     frsclp  lda     fcbone,x        ;get byte
  1000 00:D74C: BC B3 D9             ldy     fcbone+16,x
  1001 00:D74F: 9D B3 D9             sta     fcbone+16,x     ;move it
  1002 00:D752: 98                   tya
  1003 00:D753: 9D A3 D9             sta     fcbone,x
  1004 00:D756: CA                   dex
  1005 00:D757: 10 F0                bpl     frsclp          ;until 16 moved
  1006 00:D759: 60                   rts                     ;return to caller
  1007                        ;
  1008                        ;move second part of fcb to first half
  1009                        ;restore tmpdsk from save location
  1010                        ;alters:a,x,p
  1011                        ;returns:x=$ff
  1012 00:D75A: A2 0F        secfrs  ldx     #15             ;set index to last
  1013 00:D75C: BD B3 D9     scfrlp  lda     fcbone+16,x     ;get byte
  1014 00:D75F: 9D A3 D9             sta     fcbone,x        ;move it
  1015 00:D762: CA                   dex
  1016 00:D763: 10 F7                bpl     scfrlp          ;loop until done
  1017 00:D765: AD F2 D9             lda     oldtmp          ;get old flag
  1018 00:D768: 8D EA D9             sta     tmpdsk          ;and set
  1019 00:D76B: 60                   rts                     ;return to caller
  1020                        ;
  1021                        ;build a number from command line and leave in num
  1022                        ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
  1023                        ;move parse index past number
  1024                        ;modifies:all
  1025                        ;returns:a,y set to low and high of number
  1026                        ; flags set according to y which is high part of number
  1027 00:D76C: A9 09        bldnum  lda     #9              ;preset to decimal
  1028 00:D76E: 8D F6 D9             sta     moduls
  1029 00:D771: 20 03 D6             jsr     prslin          ;put in fcb
  1030 00:D774: AD EA D9             lda     tmpdsk          ;if temp
  1031 00:D777: D0 6D                bne     numerr          ;is error
  1032 00:D779: 8D F7 D9             sta     num             ;else clear num
  1033 00:D77C: 8D F8 D9             sta     num+1
  1034 00:D77F: A8                   tay                     ;and index
  1035 00:D780: B9 A4 D9             lda     fcbone+1,y      ;get first char
  1036 00:D783: C9 24                cmp     #'$'            ;see if hex signal
  1037 00:D785: D0 06                bne     bnumlp          ;skip if not
  1038 00:D787: A9 0F                lda     #15             ;set for modulus
  1039 00:D789: 8D F6 D9             sta     moduls
  1040 00:D78C: C8                   iny                     ;bump past $
  1041 00:D78D: C8           bnumlp  iny                     ;next char
  1042 00:D78E: B9 A3 D9             lda     fcbone,y        ;get digit
  1043 00:D791: C9 20                cmp     #' '            ;see if space
  Tue Apr 29 2025  4:23                                                                                                    Page 22


  1044 00:D793: F0 54                beq     endnlp          ;done if is
  1045                        ;
  1046                        ;test for decimal digit
  1047                        ;if decimal then c=0 else c=1
  1048 00:D795: C9 30                cmp     #'0'            ;if under 0
  1049 00:D797: 90 4D                bcc     numerr          ;then not decimal
  1050 00:D799: C9 3A                cmp     #'9'+1          ;if 9 or under is ok
  1051 00:D79B: 90 11                bcc     usedig
  1052                        ;
  1053                        ;test for hexadecimal digit
  1054                        ;if hex then c=0 else c=1
  1055 00:D79D: C9 41                cmp     #'A'            ;if under A
  1056 00:D79F: 90 45                bcc     numerr          ;then not hex
  1057 00:D7A1: C9 47                cmp     #'F'+1          ;if F or under is ok
  1058                        ;
  1059 00:D7A3: B0 41                bcs     numerr          ;error if not
  1060 00:D7A5: E9 06                sbc     #6              ;remove offset
  1061 00:D7A7: A2 0F                ldx     #15             ;test for hex modulus
  1062 00:D7A9: EC F6 D9             cpx     moduls
  1063 00:D7AC: D0 38                bne     numerr          ;error if not
  1064 00:D7AE: 29 0F        usedig  and     #%00001111      ;eliminate ascii bias
  1065 00:D7B0: 48                   pha                     ;save result
  1066 00:D7B1: AD F7 D9             lda     num             ;move number to temp
  1067 00:D7B4: 8D F9 D9             sta     tnum
  1068 00:D7B7: AD F8 D9             lda     num+1
  1069 00:D7BA: 8D FA D9             sta     tnum+1
  1070 00:D7BD: AE F6 D9             ldx     moduls          ;get modulus
  1071 00:D7C0: 18                   clc
  1072 00:D7C1: AD F7 D9     addlpe  lda     num             ;add number to itself
  1073 00:D7C4: 6D F9 D9             adc     tnum
  1074 00:D7C7: 8D F7 D9             sta     num
  1075 00:D7CA: AD F8 D9             lda     num+1           ;modulus times
  1076 00:D7CD: 6D FA D9             adc     tnum+1
  1077 00:D7D0: 8D F8 D9             sta     num+1
  1078 00:D7D3: B0 11                bcs     numerr          ;error if carry out
  1079 00:D7D5: CA                   dex
  1080 00:D7D6: D0 E9                bne     addlpe          ;loop if more
  1081 00:D7D8: 68                   pla                     ;get input back
  1082 00:D7D9: 6D F7 D9             adc     num             ;add in
  1083 00:D7DC: 8D F7 D9             sta     num
  1084 00:D7DF: 90 AC                bcc     bnumlp          ;loop if no carry
  1085 00:D7E1: EE F8 D9             inc     num+1           ;else bump high
  1086 00:D7E4: D0 A7                bne     bnumlp          ;and loop for more
  1087                        ;error in bldnum - handle and quit
  1088 00:D7E6: 4C 52 D1     numerr  jmp     cmderr          ;do general error
  1089                        ;end of use of name part - check type
  1090 00:D7E9: AD AC D9     endnlp  lda     fcbone+9        ;get first
  1091 00:D7EC: C9 20                cmp     #' '            ;see if space
  1092 00:D7EE: D0 F6                bne     numerr          ;error if not
  1093 00:D7F0: AD F7 D9             lda     num             ;return with result
  1094 00:D7F3: AC F8 D9             ldy     num+1
  1095 00:D7F6: 60                   rts                     ;return to caller
  1096                        ;
  1097                        ;bump load address by 128 and return in ay
  1098 00:D7F7: 18           adjdb   clc                     ;clear carry for add
  1099 00:D7F8: AD F3 D9             lda     dskbuf          ;get low addr
  1100 00:D7FB: 69 80                adc     #128            ;add in 128
  1101 00:D7FD: 8D F3 D9             sta     dskbuf          ;save it back
  1102 00:D800: 90 03                bcc     adjend          ;if carry clear, done
  1103 00:D802: EE F4 D9             inc     dskbuf+1        ;else, increment high
  1104 00:D805: AC F4 D9     adjend  ldy     dskbuf+1        ;get high addr
  1105 00:D808: 60                   rts                     ;return
  1106                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 23


  1107                        ;function entry vector table
  1108 00:D809: 9C D1        xqfntb  .DW     dir
  1109 00:D80B: 83 D2                .DW     save
  1110 00:D80D: 35 D3                .DW     era
  1111 00:D80F: 61 D3                .DW     type
  1112 00:D811: 21 D2                .DW     ren
  1113 00:D813: E0 D3                .DW     go
  1114 00:D815: A3 D3                .DW     load
  1115 00:D817: F0 D3                .DW     user
  1116 00:D819: 21 D4                .DW     system
  1117 00:D81B: 88 D4                .DW     trns
  1118                        ;
  1119                        ;Messages
  1120                        msgtbl
  1121                        ;
  1122             00000000   nospms  .EQU    *-msgtbl
  1123 00:D81D: 4E 4F 20 53          .DB     "NO SPACE",0
       00:D821: 50 41 43 45 
       00:D825: 00 
  1124             00000009   ntclms  .EQU    *-msgtbl
  1125 00:D826: 43 41 4E 20          .DB     "CAN NOT CLOSE",0
       00:D82A: 4E 4F 54 20 
       00:D82E: 43 4C 4F 53 
       00:D832: 45 00 
  1126             00000017   alflms  .EQU    *-msgtbl
  1127 00:D834: 41 4C 4C 20          .DB     "ALL FILES (Y/N)?",0
       00:D838: 46 49 4C 45 
       00:D83C: 53 20 28 59 
       00:D840: 2F 4E 29 3F 
       00:D844: 00 
  1128             00000028   rderms  .EQU    *-msgtbl
  1129 00:D845: 52 45 41 44          .DB     "READ ERROR",0
       00:D849: 20 45 52 52 
       00:D84D: 4F 52 00 
  1130             00000033   ntfnms  .EQU    *-msgtbl
  1131 00:D850: 4E 4F 54 20          .DB     "NOT FOUND",0
       00:D854: 46 4F 55 4E 
       00:D858: 44 00 
  1132             0000003D   flexms  .EQU    *-msgtbl
  1133 00:D85A: 46 49 4C 45          .DB     "FILE EXISTS",0
       00:D85E: 20 45 58 49 
       00:D862: 53 54 53 00 
  1134             00000049   lderms  .EQU    *-msgtbl
  1135 00:D866: 4C 4F 41 44          .DB     "LOAD ERROR",0
       00:D86A: 20 45 52 52 
       00:D86E: 4F 52 00 
  1136             00000054   cnnoms  .EQU    *-msgtbl
  1137 00:D871: 43 41 4E 20          .DB     "CAN NOT OPEN",0
       00:D875: 4E 4F 54 20 
       00:D879: 4F 50 45 4E 
       00:D87D: 00 
  1138             00000061   wrerms  .EQU    *-msgtbl
  1139 00:D87E: 57 52 49 54          .DB     "WRITE ERROR",0
       00:D882: 45 20 45 52 
       00:D886: 52 4F 52 00 
  1140             0000006D   userms  .EQU    *-msgtbl
  1141 00:D88A: 49 4E 56 41          .DB     "INVALID USER",0
       00:D88E: 4C 49 44 20 
       00:D892: 55 53 45 52 
       00:D896: 00 
  1142             0000007A   pgzusg  .EQU    *-msgtbl
  1143 00:D897: 0D 0A 50 5A          .DB     cr,lf,"PZ: ",0
       00:D89B: 3A 20 00 
  Tue Apr 29 2025  4:23                                                                                                    Page 24


  1144             00000081   biousg  .EQU    *-msgtbl
  1145 00:D89E: 20 42 49 4F          .DB     " BIOS: ",0
       00:D8A2: 53 3A 20 00 
  1146             00000089   teausg  .EQU    *-msgtbl
  1147 00:D8A6: 0D 0A 54 45          .DB     cr,lf,"TEA: ",0
       00:D8AA: 41 3A 20 00 
  1148             00000091   ccmusg  .EQU    *-msgtbl
  1149 00:D8AE: 20 43 43 4D          .DB     " CCM: ",0
       00:D8B2: 3A 20 00 
  1150             00000098   pemusg  .EQU    *-msgtbl
  1151 00:D8B5: 20 50 45 4D          .DB     " PEM: ",0
       00:D8B9: 3A 20 00 
  1152             0000009F   simusg  .EQU    *-msgtbl
  1153 00:D8BC: 20 53 49 4D          .DB     " SIM: ",0
       00:D8C0: 3A 20 00 
  1154             000000A6   almusg  .EQU    *-msgtbl
  1155 00:D8C3: 20 44 4D 41          .DB     " DMAPS: ",0
       00:D8C7: 50 53 3A 20 
       00:D8CB: 00 
  1156                        ;
  1157                        ; Tables for System Command:
  1158                        ; - basically to save some space...
  1159                        ;
  1160                        msgtb
  1161 00:D8CC: 7A                   .DB     pgzusg
  1162 00:D8CD: 81                   .DB     biousg
  1163 00:D8CE: 89                   .DB     teausg
  1164 00:D8CF: 91                   .DB     ccmusg
  1165 00:D8D0: 98                   .DB     pemusg
  1166 00:D8D1: 9F                   .DB     simusg
  1167 00:D8D2: A6                   .DB     almusg
  1168                        ;
  1169                        memstl
  1170 00:D8D3: 00                   .DB     #<pzbase
  1171 00:D8D4: 00                   .DB     #<bios
  1172 00:D8D5: 00                   .DB     #<tea
  1173 00:D8D6: 10                   .DB     #<ccmram
  1174 00:D8D7: 00                   .DB     #<pemram
  1175 00:D8D8: 00                   .DB     #<simram
  1176 00:D8D9: 00                   .DB     #<almpa
  1177                        memsth
  1178 00:D8DA: 00                   .DB     #>pzbase
  1179 00:D8DB: F8                   .DB     #>bios
  1180 00:D8DC: 08                   .DB     #>tea
  1181 00:D8DD: D0                   .DB     #>ccmram
  1182 00:D8DE: DA                   .DB     #>pemram
  1183 00:D8DF: E4                   .DB     #>simram
  1184 00:D8E0: E8                   .DB     #>almpa
  1185                        memenl
  1186 00:D8E1: C0                   .DB     #<pzstrt
  1187 00:D8E2: 00                   .DB     #0
  1188 00:D8E3: 00                   .DB     #<pemram
  1189 00:D8E4: 00                   .DB     #<pemram
  1190 00:D8E5: 00                   .DB     #<simram
  1191 00:D8E6: 00                   .DB     #<almpa
  1192 00:D8E7: 00                   .DB     #<mapend
  1193                        memenh
  1194 00:D8E8: 00                   .DB     #0
  1195 00:D8E9: 00                   .DB     #0
  1196 00:D8EA: DA                   .DB     #>pemram
  1197 00:D8EB: DA                   .DB     #>pemram
  1198 00:D8EC: E4                   .DB     #>simram
  1199 00:D8ED: E8                   .DB     #>almpa
  Tue Apr 29 2025  4:23                                                                                                    Page 25


  1200 00:D8EE: F0                   .DB     #>mapend
  1201                        ;
  1202                        ;Function name table
  1203                        fnctbl
  1204 00:D8EF: 44 49 52 20          .DB     "DIR ",0
       00:D8F3: 00 
  1205 00:D8F4: 53 41 56 45          .DB     "SAVE ",0
       00:D8F8: 20 00 
  1206 00:D8FA: 45 52 41 20          .DB     "ERA ",0
       00:D8FE: 00 
  1207 00:D8FF: 54 59 50 45          .DB     "TYPE ",0
       00:D903: 20 00 
  1208 00:D905: 52 45 4E 20          .DB     "REN ",0
       00:D909: 00 
  1209 00:D90A: 47 4F 20 00          .DB     "GO ",0
  1210 00:D90E: 4C 4F 41 44          .DB     "LOAD ",0
       00:D912: 20 00 
  1211 00:D914: 55 53 45 52          .DB     "USER ",0
       00:D918: 20 00 
  1212 00:D91A: 53 59 53 54          .DB     "SYSTEM",0
       00:D91E: 45 4D 00 
  1213                        ;
  1214                        ;ccm variable storage
  1215                        ;
  1216                        ;input buffer
  1217                        cnsbuf
  1218 00:D921: 7F           cnsmax  .DB     127
  1219 00:D922: 00           cnslng  .DB     0
  1220 00:D923:              cnstxt  DEFS    128              ;set to 128 for safety
  1221                        ;fcb one
  1222 00:D9A3:              fcbone  DEFS    33
  1223                        ;
  1224                        ;submit FCB
  1225 00:D9C4: 00           subfcb  .DB     0               ;will be drive A
  1226 00:D9C5: 24 24 24 20          .DB     '$$$     '      ;name field
       00:D9C9: 20 20 20 20 
  1227 00:D9CD: 53 55 42             .DB     'SUB'           ;type field
  1228 00:D9D0: 00                   .DB     0               ;extent
  1229 00:D9D1: 00 00                .DB     0,0             ;unused
  1230 00:D9D3: 00           SUBRC   .DB     0               ;number of records
  1231 00:D9D4:                      DEFS    16              ;block number area
  1232 00:D9E4: 00           SUBCR   .DB     0               ;current record to read
  1233                        ;
  1234                        ;com type field
  1235 00:D9E5: 43 4F 4D     typcom  .DB     "COM"
  1236                        ;
  1237                        ;variable storage
  1238 00:D9E8: 00           cnbfpt  .DB     0               ;buffer index
  1239 00:D9E9: 00           dfldsk  .DB     0               ;default drive
  1240 00:D9EA: 00           tmpdsk  .DB     0               ;temporary drive
  1241 00:D9EB: 00           dsksav  .DB     0               ;save default during $$$.sub ops
  1242 00:D9EC: 00           count   .DB     0               ;counter
  1243 00:D9ED: 00           curpnt  .DB     0               ;input parse start
  1244 00:D9EE: 00           diradd  .DB     0               ;directory number
  1245 00:D9EF: 00           savx    .DB     0               ;save x location
  1246 00:D9F0: 00           savy    .DB     0               ;save y location
  1247 00:D9F1: 00           length  .DB     0               ;number pages to save
  1248 00:D9F2: 00           oldtmp  .DB     0               ;temp drive in ren
  1249 00:D9F3: 00 08        dskbuf  .DW     tea             ;disk buffer start
  1250 00:D9F5: 00           across  .DB     0               ;dir count on line
  1251 00:D9F6: 09           moduls  .DB     9               ;modulus-1 for number input
  1252 00:D9F7: 00 00        num     .DW     0               ;input number
  1253 00:D9F9: 00 00        tnum    .DW     0               ;temp in bldnum
  Tue Apr 29 2025  4:23                                                                                                    Page 26


  1254 00:D9FB: 00 08        sadr    .DW     tea             ;save start address
  1255                        ;
  1256                                END
   274                        ;
   275                                        .ORG    $/256*256+256           ;Align to Page address
   276                        ;
   277                                include         DOS65-PEM-V321.ASM      ;Include PEM Module
     1                        ;
     2                        ;----------------------------------------
     3                        ;DOS/65 primitive execution module (pem)
     4                        ;----------------------------------------
     5                        ;
     6                        ; Version 3.21 - 6th March 2025 - KM
     7                        ;
     8                        ;This version of DOS/65 works only with Block
     9                        ; type devices (IDE, SD-Card, SCSI, etc.),
    10                        ; which are non-removable devices.
    11                        ;
    12                        ; All routines which support removable media,
    13                        ; such as diskettes have been removed.
    14                        ;
    15                        ;main program
    16                        ; input:x=command,a=value,a&y=address
    17                        ; returns:a=value,a&y=address
    18                        ; alters: all registers
    19 00:DA00: D8           pemram  cld                     ;ensure binary mode
    20 00:DA01: 85 C0                sta     addinp          ;save value and/or
    21 00:DA03: 84 C1                sty     addinp+1        ;address to pointers
    22 00:DA05: E0 25                cpx     #numcmd         ;check for valid cmd number
    23 00:DA07: B0 2C                bcs     notval          ;exit if command over
    24 00:DA09: 8A                   txa                     ;xfer command to A reg
    25 00:DA0A: 0A                   asl     a               ;multiply command by two
    26 00:DA0B: AA                   tax                     ;xfer back for index pointer
    27 00:DA0C: 9C A0 E3             stz     tmpdrv          ;clear drive switch flag
    28 00:DA0F: A5 C0                lda     addinp          ;get input value back
    29 00:DA11: 20 3C DA             jsr     cmd_exe         ;call execute PEM command
    30                        ;
    31                        ;The next line is the entry location to exit all
    32                        ;PEM calls, sans a warm boot.
    33 00:DA14: 8D 9D E3             sta     bytout          ;save value
    34 00:DA17: 8C 9E E3             sty     addout+1        ;and address
    35                        ;First step is to restore original drive
    36 00:DA1A: AD A0 E3             lda     tmpdrv          ;see if temp drive flag set
    37 00:DA1D: F0 09                beq     notmpd          ;if not, skip the following
    38 00:DA1F: AD A7 E3             lda     olddrv          ;get original drive number
    39 00:DA22: 8D 94 E3             sta     drvcmd          ;set up like input
    40 00:DA25: 20 CD DC             jsr     chgdrv          ;change drive back
    41                        ;
    42                        ;At this point OLDDRV is mapped with USRCDE in
    43                        ;byte 0 of FCB. Now clear that byte and restore
    44                        ;the original drive designator.
    45 00:DA28: 5F C6 0A     notmpd  bbr5    d65flg,notval   ;test flag, branch if clear
    46 00:DA2B: 57 C6                rmb5    d65flg          ;else, clear drive flag bit
    47                        ;
    48 00:DA2D: AD A0 E3             lda     tmpdrv          ;get temp drive
    49 00:DA30: 92 C0                sta     (addinp)        ;put back into fcb
    50 00:DA32: 9C A0 E3             stz     tmpdrv          ;clear temp drive
    51 00:DA35: AC 9E E3     notval  ldy     addout+1        ;get address (high)
    52 00:DA38: AD 9D E3             lda     bytout          ;and value/address (low)
    53 00:DA3B: 60                   rts                     ;return to caller
    54                        ;
    55 00:DA3C: 7C 3F DA     cmd_exe jmp     (cmdtbl,x)      ;execute PEM command via table
    56                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 27


    57                        ;command vector table
    58                        cmdtbl
    59 00:DA3F: 9D DA                .DW     xwboot          ;warm boot (x=0)
    60 00:DA41: 80 DC                .DW     xcnsin          ;console input with echo (x=1)
    61 00:DA43: A9 E1                .DW     sndchr          ;console output (x=2)
    62 00:DA45: 15 E4                .DW     simram+21       ;tape reader (x=3)
    63 00:DA47: 12 E4                .DW     simram+18       ;tape punch (x=4)
    64 00:DA49: 0F E4                .DW     simram+15       ;printer output (x=5)
    65 00:DA4B: 30 E1                .DW     getcon          ;console input w/o echo (x=6)
    66 00:DA4D: CB DA                .DW     xgtios          ;read i/o status (x=7)
    67 00:DA4F: CF DA                .DW     xstios          ;set i/o status (x=8)
    68 00:DA51: 5F E1                .DW     sndstr          ;print buffer (x=9)
    69 00:DA53: 18 E2                .DW     bufinp          ;read buffer (x=10)
    70 00:DA55: 3B E1                .DW     kbdsts          ;test console ready (x=11)
    71 00:DA57: 2D E4                .DW     simram+45       ;read list status (x=12)
    72 00:DA59: E7 DC                .DW     xintds          ;initialize system (x=13)
    73 00:DA5B: C4 DC                .DW     xchgdr          ;log in drive (x=14)
    74 00:DA5D: BE DE                .DW     xopen           ;open file (x=15)
    75 00:DA5F: F9 DE                .DW     xclose          ;close file (x=16)
    76 00:DA61: 23 DF                .DW     xfndfr          ;find first match (x=17)
    77 00:DA63: ED DA                .DW     xfndnx          ;find next match (x=18)
    78 00:DA65: 53 DB                .DW     xdltfl          ;delete file (x=19)
    79 00:DA67: F5 DA                .DW     xread           ;read record (x=20)
    80 00:DA69: 78 DB                .DW     xwrite          ;write record (x=21)
    81 00:DA6B: C1 DF                .DW     xmake           ;create file (x=22)
    82 00:DA6D: 31 DB                .DW     xrenme          ;rename file (x=23)
    83 00:DA6F: E5 DA                .DW     xintlg          ;interrogate log in status (x=24)
    84 00:DA71: E1 DA                .DW     xintdr          ;interrogate current drive (x=25)
    85 00:DA73: 99 DC                .DW     chgdma          ;set buffer address (x=26)
    86 00:DA75: DA DA                .DW     xrdalv          ;read allocation map start (x=27)
    87 00:DA77: 94 DE                .DW     setron          ;set r/w status (x=28)
    88 00:DA79: E9 DA                .DW     xrdros          ;read r/w status (x=29)
    89 00:DA7B: 89 DA                .DW     setlst          ;set list echo status (x=30)
    90 00:DA7D: 8D DA                .DW     lststs          ;read list echo status (x=31)
    91 00:DA7F: AD DA                .DW     xrtclo          ;read low clock (x=32)
    92 00:DA81: C1 DA                .DW     xrtchi          ;read high clock (x=33)
    93 00:DA83: D3 DA                .DW     xrddcb          ;read dcb address (x=34)
    94 00:DA85: 33 E4                .DW     simram+51       ;translate sector (x=35) - obsolete
    95 00:DA87: 91 DA                .DW     xgsusr          ;get or set user code (x=36)
    96                        ;
    97                        ;set list echo status
    98 00:DA89: 8D 9B E3     setlst  sta     lstflg          ;set flag
    99 00:DA8C: 60                   rts
   100                        ;
   101                        ;read list echo status
   102 00:DA8D: AD 9B E3     lststs  lda     lstflg          ;read flag
   103 00:DA90: 60                   rts
   104                        ;
   105                        ;execute get or set user code
   106                        ; when A reg is #255, it's a request to get the user code
   107                        ; otherwise, A reg is #0-15 to set the user code
   108 00:DA91: C9 FF        xgsusr  cmp     #255            ;check if request
   109 00:DA93: F0 04                beq     rtnusr          ;if #255, get user code
   110 00:DA95: 8D 95 E3             sta     usrcde          ;else, set user code
   111 00:DA98: 60                   rts                     ;then exit
   112 00:DA99: AD 95 E3     rtnusr  lda     usrcde          ;get user code
   113 00:DA9C: 60                   rts                     ;then exit
   114                        ;
   115                        ;execute warm boot
   116                        ; ***this command does not return via pem***
   117                        ; SIM handles reloading of CCM only,
   118                        ; then initializes Page Zero, the CPU stack
   119                        ; and the PEM vectors at $0100, then jumps to CCM.
  Tue Apr 29 2025  4:23                                                                                                    Page 28


   120 00:DA9D: AD 95 E3     xwboot  lda     usrcde          ;get user code
   121 00:DAA0: 0A                   asl     a               ;shift to high nibble
   122 00:DAA1: 0A                   asl     a
   123 00:DAA2: 0A                   asl     a
   124 00:DAA3: 0A                   asl     a
   125 00:DAA4: 0D A8 E3             ora     curdrv          ;or in current drive
   126 00:DAA7: 8D 06 01             sta     iostat          ;save for SIM
   127 00:DAAA: 4C 03 E4             jmp     simram+3        ;go to SIM and execute
   128                        ;
   129                        ;execute read real time clock
   130 00:DAAD: 20 30 E4     xrtclo  jsr     simram+48       ;read clock
   131 00:DAB0: 8D C0 E3             sta     rtclk           ;save low
   132 00:DAB3: 8C C1 E3             sty     rtclk+1         ;middle
   133 00:DAB6: 8E C2 E3             stx     rtclk+2         ;high
   134 00:DAB9: 8A                   txa
   135 00:DABA: 29 80                and     #%10000000      ;test for valid
   136 00:DABC: A8                   tay
   137 00:DABD: AD C0 E3             lda     rtclk           ;get low
   138 00:DAC0: 60                   rts
   139                        ;
   140                        ;execute read real time clock high
   141 00:DAC1: AD C2 E3     xrtchi  lda     rtclk+2         ;get high
   142 00:DAC4: 29 7F                and     #%01111111      ;clear status
   143 00:DAC6: A8                   tay
   144 00:DAC7: AD C1 E3             lda     rtclk+1         ;get middle
   145 00:DACA: 60                   rts
   146                        ;
   147                        ;execute read i/o status
   148 00:DACB: AD 06 01     xgtios  lda     iostat          ;get status byte
   149 00:DACE: 60                   rts
   150                        ;
   151                        ;execute set i/o status
   152 00:DACF: 8D 06 01     xstios  sta     iostat          ;set status
   153 00:DAD2: 60                   rts
   154                        ;
   155                        ;execute read dcb address
   156 00:DAD3: AD 1A DD     xrddcb  lda     cptdcb+1        ;get address
   157 00:DAD6: AC 1B DD             ldy     cptdcb+2
   158 00:DAD9: 60                   rts
   159                        ;
   160                        ;execute read allocation map starting address
   161 00:DADA: AD CE E3     xrdalv  lda     alcmap          ;get alloc map
   162 00:DADD: AC CF E3             ldy     alcmap+1        ;starting address
   163 00:DAE0: 60                   rts                     ;then return
   164                        ;
   165                        ;execute interrogate current drive
   166 00:DAE1: AD A8 E3     xintdr  lda     curdrv          ;get number
   167 00:DAE4: 60                   rts
   168                        ;
   169                        ;execute read log in status
   170 00:DAE5: AD A9 E3     xintlg  lda     lginvc          ;get status
   171 00:DAE8: 60                   rts
   172                        ;
   173                        ;execute read read/write status
   174 00:DAE9: AD AA E3     xrdros  lda     ronlst          ;get status
   175 00:DAEC: 60                   rts
   176                        ;
   177                        ;execute find next match
   178 00:DAED: 20 A4 DC     xfndnx  jsr     autodr          ;auto drive select
   179 00:DAF0: A9 0D                lda     #13             ;match including
   180 00:DAF2: 4C 2D DF             jmp     search          ;extent
   181                        ;
   182                        ;execute read next record
  Tue Apr 29 2025  4:23                                                                                                    Page 29


   183 00:DAF5: 20 A4 DC     xread   jsr     autodr          ;auto drive select
   184 00:DAF8: 20 9E DE             jsr     inrcct          ;initialize record counters
   185 00:DAFB: AD B3 E3             lda     nxtrec          ;if next record less
   186 00:DAFE: CD B4 E3             cmp     numrec          ;then number records
   187 00:DB01: 90 11                bcc     tryrde          ;then try to read
   188 00:DB03: C9 80                cmp     #128            ;but if not and
   189 00:DB05: F0 03                beq     tryext          ;is max try to extend
   190 00:DB07: A9 01        rdeeof  lda     #1              ;else set eof
   191 00:DB09: 60                   rts                     ;code and return
   192 00:DB0A: E7 C6        tryext  smb6    d65flg          ;set bit for read
   193 00:DB0C: 20 FB DF             jsr     extend          ;file extension
   194 00:DB0F: D0 F6                bne     rdeeof          ;with jump back
   195 00:DB11: 8D B3 E3             sta     nxtrec          ;clear next record
   196 00:DB14: 20 66 E0     tryrde  jsr     getblk          ;and get block
   197 00:DB17: AD AE E3             lda     blknum          ;if block not zero
   198 00:DB1A: 0D AF E3             ora     blknum+1
   199 00:DB1D: D0 03                bne     dorde           ;do the read
   200 00:DB1F: A9 02                lda     #2              ;else set unwritten
   201 00:DB21: 60                   rts                     ;code and exit
   202 00:DB22: 20 70 DF     dorde   jsr     calrcn          ;calculate record number
   203 00:DB25: 20 4B DE             jsr     setrec          ;set record number
   204 00:DB28: 20 FA E0             jsr     rderec          ;do record read
   205 00:DB2B: 20 AD DE             jsr     updtrc          ;update counters
   206 00:DB2E: A9 00                lda     #0              ;return w/o error
   207 00:DB30: 60                   rts
   208                        ;
   209                        ;execute file rename
   210 00:DB31: 20 A4 DC     xrenme  jsr     autodr          ;automatic drive select
   211 00:DB34: 20 E2 E0             jsr     tstron          ;test for r/o
   212 00:DB37: A9 0C                lda     #12             ;match name
   213 00:DB39: 20 28 DF             jsr     frstsr          ;and type
   214 00:DB3C: 30 14                bmi     extren          ;exit if not found
   215 00:DB3E: B2 C0        doren   lda     (addinp)
   216 00:DB40: A0 10                ldy     #16             ;in new name
   217 00:DB42: 91 C0                sta     (addinp),y      ;part of fcb
   218 00:DB44: A9 0C                lda     #12             ;then move
   219 00:DB46: A2 10                ldx     #16             ;new name
   220 00:DB48: 20 90 DF             jsr     dirchg          ;to directory
   221 00:DB4B: A9 0C                lda     #12             ;see if
   222 00:DB4D: 20 2D DF             jsr     search          ;another match
   223 00:DB50: 10 EC                bpl     doren           ;loop if found
   224 00:DB52: 60           extren  rts                     ;number
   225                        ;
   226                        ;execute delete file
   227 00:DB53: 20 A4 DC     xdltfl  jsr     autodr          ;automatic drive select
   228 00:DB56: 20 E2 E0             jsr     tstron          ;test for r/o
   229 00:DB59: A9 0C                lda     #12             ;match name
   230 00:DB5B: 20 28 DF             jsr     frstsr          ;and type
   231 00:DB5E: 30 17                bmi     extdlt          ;done if not found
   232 00:DB60: A2 00        dodlt   ldx     #0              ;else do a
   233 00:DB62: 20 A6 E0             jsr     mapdir          ;delete
   234 00:DB65: AC AD E3             ldy     subrec          ;then change
   235 00:DB68: AD 7B E3             lda     empty           ;byte zero to
   236 00:DB6B: 91 C2                sta     (bufadd),y      ;empty code
   237 00:DB6D: 20 01 E1             jsr     wrtrec
   238 00:DB70: A9 0C                lda     #12             ;search
   239 00:DB72: 20 2D DF             jsr     search          ;for next
   240 00:DB75: 10 E9                bpl     dodlt           ;loop if found
   241 00:DB77: 60           extdlt  rts                     ;exit
   242                        ;
   243                        ;execute write next record
   244 00:DB78: 20 A4 DC     xwrite  jsr     autodr          ;automatic drive select
   245 00:DB7B: 20 E2 E0             jsr     tstron          ;test for r/o
  Tue Apr 29 2025  4:23                                                                                                    Page 30


   246 00:DB7E: 20 9E DE             jsr     inrcct          ;initialize counters
   247 00:DB81: AD B3 E3             lda     nxtrec          ;get next record
   248 00:DB84: C9 80                cmp     #128            ;compare to max
   249 00:DB86: 90 03                bcc     ntexte          ;continue if less
   250 00:DB88: A9 01                lda     #1              ;else flag as extend
   251 00:DB8A: 60                   rts                     ;error and exit
   252 00:DB8B: 20 66 E0     ntexte  jsr     getblk          ;calculate block num
   253 00:DB8E: AD AE E3             lda     blknum          ;get it and if
   254 00:DB91: 0D AF E3             ora     blknum+1
   255 00:DB94: F0 03                beq     zwrt            ;zero then get number
   256 00:DB96: 4C 51 DC             jmp     blkopn          ;else go write
   257 00:DB99: AD 97 E3     zwrt    lda     fcbind          ;get index from prior
   258 00:DB9C: 48                   pha                     ;and save
   259 00:DB9D: C9 10                cmp     #16             ;if first block
   260 00:DB9F: F0 16                beq     isfrst          ;then don't change
   261 00:DBA1: A8                   tay                     ;else make an index
   262 00:DBA2: 88                   dey                     ;point to last
   263 00:DBA3: 7F C6 01             bbr7    d65flg,blm0     ;test mode, branch if byte
   264 00:DBA6: 88                   dey                     ;else drop for word
   265 00:DBA7: B1 C0        blm0    lda     (addinp),y      ;and get that number
   266 00:DBA9: 8D AE E3             sta     blknum          ;store as starting
   267 00:DBAC: C8                   iny                     ;bump for word
   268 00:DBAD: A9 00                lda     #0              ;preset for byte
   269 00:DBAF: 7F C6 02             bbr7    d65flg,blm1     ;test mode, branch if byte
   270 00:DBB2: B1 C0                lda     (addinp),y      ;else get high
   271 00:DBB4: 8D AF E3     blm1    sta     blknum+1        ;then set high
   272 00:DBB7: AD AE E3     isfrst  lda     blknum          ;get block
   273 00:DBBA: 8D A3 E3             sta     lkdown          ;set lower and
   274 00:DBBD: 8D A5 E3             sta     lookup          ;upper pointers
   275 00:DBC0: AD AF E3             lda     blknum+1        ;now set high part
   276 00:DBC3: 8D A4 E3             sta     lkdown+1
   277 00:DBC6: 8D A6 E3             sta     lookup+1
   278 00:DBC9: AD A5 E3     srblag  lda     lookup          ;if upper pointer
   279 00:DBCC: CD C5 E3             cmp     maxblk          ;not at max
   280 00:DBCF: D0 08                bne     upnemx          ;then keep going
   281 00:DBD1: AC A6 E3             ldy     lookup+1        ;now check high
   282 00:DBD4: CC C6 E3             cpy     maxblk+1
   283 00:DBD7: F0 12                beq     tstdwn          ;go test down
   284 00:DBD9: EE A5 E3     upnemx  inc     lookup          ;else bump upper
   285 00:DBDC: D0 03                bne     skpup
   286 00:DBDE: EE A6 E3             inc     lookup+1
   287 00:DBE1: AD A3 E3     skpup   lda     lkdown          ;then if lower
   288 00:DBE4: 0D A4 E3             ora     lkdown+1
   289 00:DBE7: F0 18                beq     dotest          ;is zero start test
   290 00:DBE9: D0 0B                bne     dcdown          ;else drop lower
   291 00:DBEB: AD A3 E3     tstdwn  lda     lkdown          ;if upper & lower at
   292 00:DBEE: 0D A4 E3             ora     lkdown+1
   293 00:DBF1: D0 03                bne     dcdown          ;drop if not zero
   294 00:DBF3: A8                   tay                     ;also set y
   295 00:DBF4: F0 33                beq     extsbl          ;then exit
   296 00:DBF6: AD A3 E3     dcdown  lda     lkdown          ;drop lower
   297 00:DBF9: D0 03                bne     skpdn
   298 00:DBFB: CE A4 E3             dec     lkdown+1
   299 00:DBFE: CE A3 E3     skpdn   dec     lkdown
   300 00:DC01: AD A3 E3     dotest  lda     lkdown          ;get lower
   301 00:DC04: AC A4 E3             ldy     lkdown+1
   302                        ;
   303                        ;test block
   304                        ; input:a&y=block number
   305                        ; returns:z=1 if unassigned
   306                        ;          =0 if assigned and bit in a is set
   307                        ; alters:all
   308 00:DC07: 20 5D DE             jsr     blkmsk          ;get mask and index
  Tue Apr 29 2025  4:23                                                                                                    Page 31


   309 00:DC0A: 32 C4                and     (alcpnt)        ;mask with map entry
   310 00:DC0C: D0 08                bne     trylup          ;if full try upper
   311 00:DC0E: AD A3 E3             lda     lkdown          ;else use lower
   312 00:DC11: AC A4 E3             ldy     lkdown+1
   313 00:DC14: 80 13                bra     extsbl          ;as result
   314 00:DC16: AD A5 E3     trylup  lda     lookup          ;get upper
   315 00:DC19: AC A6 E3             ldy     lookup+1
   316                        ;
   317                        ;test block
   318                        ; input:a&y=block number
   319                        ; returns:z=1 if unassigned
   320                        ;          =0 if assigned and bit in a is set
   321                        ; alters:all
   322 00:DC1C: 20 5D DE             jsr     blkmsk          ;get mask and index
   323 00:DC1F: 32 C4                and     (alcpnt)        ;mask with map entry
   324 00:DC21: D0 A6                bne     srblag          ;then loop
   325 00:DC23: AD A5 E3             lda     lookup          ;else use upper
   326 00:DC26: AC A6 E3             ldy     lookup+1
   327 00:DC29: 8D AE E3     extsbl  sta     blknum          ;then save number
   328 00:DC2C: 8C AF E3             sty     blknum+1
   329 00:DC2F: 0D AF E3             ora     blknum+1        ;see if zero
   330 00:DC32: D0 04                bne     gtgood          ;then proceed
   331 00:DC34: 68                   pla                     ;clear stack
   332 00:DC35: A9 02                lda     #2              ;set end
   333 00:DC37: 60                   rts                     ;of data return
   334 00:DC38: AD AE E3     gtgood  lda     blknum          ;get low again
   335                        ;
   336 00:DC3B: 20 5D DE             jsr     blkmsk          ;get mask
   337 00:DC3E: 12 C4                ora     (alcpnt)        ;set bit
   338 00:DC40: 92 C4                sta     (alcpnt)        ;and put back
   339 00:DC42: 7A                   ply                     ;get block pointer back
   340 00:DC43: AD AE E3             lda     blknum          ;get number
   341 00:DC46: 91 C0                sta     (addinp),y      ;and put in fcb
   342 00:DC48: AD AF E3             lda     blknum+1        ;get high
   343 00:DC4B: C8                   iny
   344 00:DC4C: 7F C6 02             bbr7    d65flg,blkopn   ;test mode, branch if byte
   345 00:DC4F: 91 C0                sta     (addinp),y      ;else set high
   346 00:DC51: 20 70 DF     blkopn  jsr     calrcn          ;calculate record num
   347 00:DC54: 20 4B DE             jsr     setrec          ;set record number
   348 00:DC57: 20 01 E1             jsr     wrtrec          ;do write
   349 00:DC5A: AE B3 E3             ldx     nxtrec          ;get next record
   350 00:DC5D: EC B4 E3             cpx     numrec          ;if less than max
   351 00:DC60: 90 05                bcc     notful          ;then ok
   352 00:DC62: E8                   inx                     ;else bump count
   353 00:DC63: 8E B4 E3             stx     numrec          ;and save
   354 00:DC66: CA                   dex                     ;back down
   355 00:DC67: E0 7F        notful  cpx     #127            ;if not at max
   356 00:DC69: D0 0F                bne     noawex          ;skip extending
   357 00:DC6B: 20 AD DE             jsr     updtrc          ;update record counters
   358 00:DC6E: 67 C6                rmb6    d65flg          ;set bit to zero for write
   359 00:DC70: 20 FB DF             jsr     extend          ;file extension
   360 00:DC73: D0 0A                bne     extwrt          ;exit
   361 00:DC75: A9 FF                lda     #255            ;else start counter
   362 00:DC77: 8D B3 E3             sta     nxtrec          ;at one short
   363 00:DC7A: 20 AD DE     noawex  jsr     updtrc          ;then update counters
   364 00:DC7D: A9 00                lda     #0              ;good return
   365 00:DC7F: 60           extwrt  rts                     ;exit
   366                        ;
   367                        ;execute console input
   368 00:DC80: 20 30 E1     xcnsin  jsr     getcon          ;get input
   369                        ;
   370                        ;test character
   371                        ; input:a=character
  Tue Apr 29 2025  4:23                                                                                                    Page 32


   372                        ; returns:c=0 if control or c=1 if printing
   373                        ; alters:p
   374 00:DC83: C9 0D                cmp     #cr             ;if cr
   375 00:DC85: F0 0A                beq     chtxt2          ;quit
   376 00:DC87: C9 0A                cmp     #lf             ;if linefeed
   377 00:DC89: F0 06                beq     chtxt2          ;quit
   378 00:DC8B: C9 09                cmp     #ctli           ;if tab
   379 00:DC8D: F0 02                beq     chtxt2          ;quit
   380 00:DC8F: C9 20                cmp     #' '            ;see if control
   381 00:DC91: 90 05        chtxt2  bcc     extxci          ;if control exit
   382 00:DC93: 48                   pha                     ;else save
   383 00:DC94: 20 A9 E1             jsr     sndchr          ;echo it
   384 00:DC97: 68                   pla                     ;restore
   385 00:DC98: 60           extxci  rts                     ;return
   386                        ;
   387                        ;change dma address
   388                        ; input:addinp=address
   389                        ; returns:none
   390                        ; alters:all
   391 00:DC99: A5 C0        chgdma  lda     addinp          ;get low
   392 00:DC9B: A4 C1                ldy     addinp+1        ;and high address
   393 00:DC9D: 85 C2                sta     bufadd          ;then store
   394 00:DC9F: 84 C3                sty     bufadd+1        ;in address
   395 00:DCA1: 4C 24 E4             jmp     simram+36       ;then go to sim
   396                        ;
   397                        ;automatic drive select
   398                        ; input:(addinp) 0=no change
   399                        ; 1-8 or 'A'-'H' = change
   400                        ; returns:none
   401                        ; alters:all
   402 00:DCA4: B2 C0        autodr  lda     (addinp)        ;get first byte of fcb
   403 00:DCA6: F0 11                beq     qtatdr          ;if 0 skip drive set
   404 00:DCA8: 3A                   dec     a               ;else subtract one
   405 00:DCA9: 29 07                and     #%00000111      ;look at lower 3 bits
   406 00:DCAB: 8D 94 E3             sta     drvcmd          ;make parameter for CHGDRV
   407 00:DCAE: AD A8 E3             lda     curdrv          ;get current drive
   408 00:DCB1: 8D A7 E3             sta     olddrv          ;and save to old
   409 00:DCB4: B2 C0                lda     (addinp)        ;get fcb entry
   410 00:DCB6: 8D A0 E3             sta     tmpdrv          ;and save as flag
   411 00:DCB9: AD 95 E3     qtatdr  lda     usrcde          ;get user code
   412 00:DCBC: 92 C0                sta     (addinp)        ;save in byte zero in fcb
   413 00:DCBE: 20 CD DC             jsr     chgdrv          ;change the drive
   414 00:DCC1: D7 C6                smb5    d65flg          ;set drive flag bit
   415 00:DCC3: 60           drvsme  rts
   416                        ;
   417                        ;change drive
   418                        ; input:addinp
   419                        ; returns:none
   420                        ; alters:all
   421 00:DCC4: A5 C0        xchgdr  lda     addinp          ;get inout
   422 00:DCC6: C9 08                cmp     #maxdrv         ;check valid maxdrv range
   423 00:DCC8: B0 10                bcs     drnger          ;if over, send range error
   424 00:DCCA: 8D 94 E3             sta     drvcmd          ;and save
   425 00:DCCD: AD 94 E3     chgdrv  lda     drvcmd          ;get input
   426 00:DCD0: CD A8 E3             cmp     curdrv          ;if same as current
   427 00:DCD3: F0 EE                beq     drvsme          ;do nothing
   428 00:DCD5: 8D A8 E3             sta     curdrv          ;else change current
   429 00:DCD8: 80 1B                bra     mapdrv          ;then log it in
   430                        ;
   431 00:DCDA: 20 17 E1     drnger  jsr     pcrlf           ;send a CR/LF
   432 00:DCDD: A9 6D                lda     #<rngmsg        ;point to
   433 00:DCDF: A0 E3                ldy     #>rngmsg        ;select message
   434 00:DCE1: 20 5F E1             jsr     sndstr          ;and send it
  Tue Apr 29 2025  4:23                                                                                                    Page 33


   435 00:DCE4: 4C 9D DA             jmp     xwboot          ;and abort
   436                        ;
   437                        ;execute initialize system
   438                        ; input:none
   439                        ; returns:none
   440                        ; alters:all,lginvc,bufadd
   441 00:DCE7: 9C A9 E3     xintds  stz     lginvc          ;clear log in status
   442 00:DCEA: A9 28                lda     #<dflbuf        ;get default buffer
   443 00:DCEC: A0 01                ldy     #>dflbuf        ;address
   444 00:DCEE: 85 C0                sta     addinp          ;and set up
   445 00:DCF0: 84 C1                sty     addinp+1        ;parameters
   446 00:DCF2: 20 99 DC             jsr     chgdma          ;change address
   447                        ;
   448                        ;log in drive, set pointers and maps
   449                        ; input:curdrv
   450                        ; returns:none
   451                        ; alters:all
   452 00:DCF5: AD A8 E3     mapdrv  lda     curdrv          ;if current drive
   453 00:DCF8: C9 08                cmp     #maxdrv         ;check valid maxdrv range
   454 00:DCFA: 90 0D                bcc     vlddrv          ;then log it in
   455 00:DCFC: 20 21 E1     drserr  jsr     errout          ;send error message
   456 00:DCFF: A9 6A                lda     #<sltmsg        ;point to
   457 00:DD01: A0 E3                ldy     #>sltmsg        ;select message
   458 00:DD03: 20 5F E1             jsr     sndstr          ;and send it
   459 00:DD06: 4C 9D DA             jmp     xwboot          ;and abort
   460 00:DD09: 20 1B E4     vlddrv  jsr     simram+27       ;go to sim to set
   461 00:DD0C: 8D 1A DD             sta     cptdcb+1        ;save
   462 00:DD0F: 8C 1B DD             sty     cptdcb+2
   463 00:DD12: 0D 1B DD             ora     cptdcb+2        ;see if invalid
   464 00:DD15: F0 E5                beq     drserr          ;error if is
   465                        ;capture dcb
   466 00:DD17: A0 0A                ldy     #11-1           ;do 11 bytes (new DCB)
   467 00:DD19: B9 FF FF     cptdcb  lda     $FFFF,y         ;get value from sim
   468 00:DD1C: 99 C5 E3             sta     dcb,y           ;store it
   469 00:DD1F: 88                   dey
   470 00:DD20: 10 F7                bpl     cptdcb          ;loop for more
   471 00:DD22: AD CB E3             lda     blkscd          ;get block size code
   472 00:DD25: A8                   tay                     ;save in y
   473 00:DD26: 18                   clc
   474 00:DD27: 69 03                adc     #3              ;convert to sxb
   475 00:DD29: 8D BF E3             sta     sxb             ;and save
   476 00:DD2C: B9 8F E3             lda     sabtbl,y        ;get sab
   477 00:DD2F: 8D BE E3             sta     sab             ;and set
   478 00:DD32: AD CC E3             lda     maxdir          ;get max dir
   479 00:DD35: 8D BC E3             sta     maxdrc          ;set max dir record
   480 00:DD38: AD CD E3             lda     maxdir+1
   481 00:DD3B: 4A                   lsr     a               ;divide by 4
   482 00:DD3C: 6E BC E3             ror     maxdrc
   483 00:DD3F: 4A                   lsr     a
   484 00:DD40: 6E BC E3             ror     maxdrc
   485 00:DD43: 8D BD E3             sta     maxdrc+1        ;then save high
   486 00:DD46: 77 C6                rmb7    d65flg          ;reset mode to byte
   487 00:DD48: AD C6 E3             lda     maxblk+1        ;branch if max block
   488 00:DD4B: F0 03                beq     ntm255          ;not over 255
   489                        ; Y reg contains the block size code, which can be 0,
   490                        ; so the initial comment about it being an error is not
   491                        ; correct, so nothing to handle here as an error.
   492                        ;
   493 00:DD4D: 88                   dey                     ;back up index
   494 00:DD4E: F7 C6                smb7    d65flg          ;set mode to word
   495 00:DD50: B9 8C E3     ntm255  lda     exmtbl,y        ;get extent mask
   496 00:DD53: 8D D0 E3             sta     exm
   497 00:DD56: 38                   sec                     ;now calculate cexm1f
  Tue Apr 29 2025  4:23                                                                                                    Page 34


   498 00:DD57: A9 1F                lda     #31
   499 00:DD59: F9 8C E3             sbc     exmtbl,y
   500 00:DD5C: 8D D1 E3             sta     cexm1f
   501 00:DD5F: AE A8 E3             ldx     curdrv          ;get drive as pointer
   502 00:DD62: BD 84 E3             lda     bitmap,x        ;get bit
   503 00:DD65: 2D A9 E3             and     lginvc          ;if logged in
   504 00:DD68: D0 0B                bne     extstm          ;then exit
   505 00:DD6A: BD 84 E3             lda     bitmap,x        ;get bit back
   506 00:DD6D: 0D A9 E3             ora     lginvc          ;set in log-in
   507 00:DD70: 8D A9 E3             sta     lginvc          ;and update
   508 00:DD73: 80 01                bra     flinal          ;then fill in maps
   509 00:DD75: 60           extstm  rts                     ;and return
   510                        ;
   511                        ;fill in allocation map
   512                        flinal  
   513                        ;set current drive to r/w
   514                        ; input:curdrv,ronlst
   515                        ; returns:ronlst
   516                        ; alters:a,x,p,ronlst
   517 00:DD76: AE A8 E3     setrw   ldx     curdrv          ;get drive as index
   518 00:DD79: BD 84 E3             lda     bitmap,x        ;load the mask
   519 00:DD7C: 1C AA E3             trb     ronlst          ;reset drive bit
   520                        ;
   521 00:DD7F: AD C5 E3             lda     maxblk          ;divide max block by
   522 00:DD82: 8D C3 E3             sta     gpcnt           ;eight to get max
   523 00:DD85: AD C6 E3             lda     maxblk+1
   524                        ;
   525 00:DD88: 4A                   lsr     a               ;use a for speed
   526 00:DD89: 6E C3 E3             ror     gpcnt
   527 00:DD8C: 4A                   lsr     a               ;use a for speed
   528 00:DD8D: 6E C3 E3             ror     gpcnt
   529 00:DD90: 4A                   lsr     a               ;use a for speed
   530 00:DD91: 6E C3 E3             ror     gpcnt
   531                        ;
   532 00:DD94: 8D C4 E3             sta     gpcnt+1         ;save high
   533 00:DD97: EE C3 E3             inc     gpcnt           ;bump low by one
   534 00:DD9A: D0 03                bne     skpam
   535 00:DD9C: EE C4 E3             inc     gpcnt+1         ;with carry
   536 00:DD9F: AD CE E3     skpam   lda     alcmap          ;get map start
   537 00:DDA2: AC CF E3             ldy     alcmap+1
   538 00:DDA5: 85 C4                sta     alcpnt          ;set pointer to start
   539 00:DDA7: 84 C5                sty     alcpnt+1
   540 00:DDA9: A9 00        clraml  lda     #0              ;clear byte
   541 00:DDAB: 92 C4                sta     (alcpnt)        ;put in map
   542 00:DDAD: E6 C4                inc     alcpnt          ;bump pointer
   543 00:DDAF: D0 02                bne     skpal
   544 00:DDB1: E6 C5                inc     alcpnt+1        ;with carry
   545 00:DDB3: AD C3 E3     skpal   lda     gpcnt           ;get low of count
   546 00:DDB6: D0 03                bne     skpgp           ;skip if not zero
   547 00:DDB8: CE C4 E3             dec     gpcnt+1         ;else drop high
   548 00:DDBB: CE C3 E3     skpgp   dec     gpcnt           ;always drop low
   549 00:DDBE: AD C3 E3             lda     gpcnt           ;test for zero
   550 00:DDC1: 0D C4 E3             ora     gpcnt+1
   551 00:DDC4: D0 E3                bne     clraml          ;loop if more
   552                        ;at this point complete map is cleared
   553 00:DDC6: AD BC E3             lda     maxdrc          ;get low of max dir record
   554 00:DDC9: 8D C3 E3             sta     gpcnt
   555 00:DDCC: AD BD E3             lda     maxdrc+1        ;get high of max dir record in a
   556 00:DDCF: AE BF E3             ldx     sxb             ;set x according to block size
   557 00:DDD2: 4A           clcmdb  lsr     a               ;do division
   558 00:DDD3: 6E C3 E3             ror     gpcnt
   559 00:DDD6: CA                   dex
   560 00:DDD7: D0 F9                bne     clcmdb          ;until x is zero
  Tue Apr 29 2025  4:23                                                                                                    Page 35


   561 00:DDD9: 8D C4 E3             sta     gpcnt+1         ;set high
   562 00:DDDC: EE C3 E3             inc     gpcnt           ;then bump by one
   563 00:DDDF: D0 03                bne     skpgp2
   564 00:DDE1: EE C4 E3             inc     gpcnt+1
   565 00:DDE4: 9C AE E3     skpgp2  stz     blknum          ;clear block number
   566 00:DDE7: 9C AF E3             stz     blknum+1
   567                        ;
   568 00:DDEA: AD AE E3     fildal  lda     blknum          ;get block number
   569 00:DDED: AC AF E3             ldy     blknum+1
   570                        ;
   571 00:DDF0: 20 5D DE             jsr     blkmsk          ;get mask
   572 00:DDF3: 12 C4                ora     (alcpnt)        ;set bit
   573 00:DDF5: 92 C4                sta     (alcpnt)        ;and put back
   574                        ;
   575 00:DDF7: EE AE E3             inc     blknum          ;bump block number
   576 00:DDFA: D0 03                bne     skpblk
   577 00:DDFC: EE AF E3             inc     blknum+1
   578 00:DDFF: AD C3 E3     skpblk  lda     gpcnt           ;get low of count
   579 00:DE02: D0 03                bne     skpgp3          ;skip if not zero
   580 00:DE04: CE C4 E3             dec     gpcnt+1         ;else drop high
   581 00:DE07: CE C3 E3     skpgp3  dec     gpcnt           ;always do low
   582 00:DE0A: AD C3 E3             lda     gpcnt           ;test for zero
   583 00:DE0D: 0D C4 E3             ora     gpcnt+1
   584 00:DE10: D0 D8                bne     fildal          ;loop if more
   585                        ;
   586                        ;at this point directory space is mapped
   587 00:DE12: 20 3C E0             jsr     cldrnm          ;clear directory number
   588 00:DE15: 20 26 E0     fillpe  jsr     nxtdir          ;execute for next directory
   589 00:DE18: 30 10                bmi     extfil          ;done if invalid
   590 00:DE1A: AC AD E3             ldy     subrec          ;else, get offset
   591 00:DE1D: B1 C2                lda     (bufadd),y      ;get empty/valid flag
   592 00:DE1F: C9 E5                cmp     #$E5            ;if empty
   593 00:DE21: F0 F2                beq     fillpe          ;try next
   594 00:DE23: A2 01                ldx     #1              ;parameter for fill in
   595 00:DE25: 20 A6 E0             jsr     mapdir          ;do directory map
   596 00:DE28: 80 EB                bra     fillpe          ;then loop
   597 00:DE2A: 60           extfil  rts                     ;return
   598                        ;
   599                        ;directory record set up
   600                        ; input:dirnum
   601                        ; returns:none
   602                        ; alters:all,recnum,dirrec
   603 00:DE2B: AD AC E3     drrcsu  lda     dirnum+1        ;move high dir number
   604 00:DE2E: 8D AF E3             sta     recnum+1        ;to record number
   605 00:DE31: AD AB E3             lda     dirnum          ;divide
   606 00:DE34: 4E AF E3             lsr     recnum+1        ;directory by four
   607 00:DE37: 6A                   ror     a
   608 00:DE38: 4E AF E3             lsr     recnum+1
   609 00:DE3B: 6A                   ror     a
   610 00:DE3C: 8D B5 E3             sta     dirrec          ;and save
   611 00:DE3F: 8D AE E3             sta     recnum          ;set low record number
   612 00:DE42: AD AF E3             lda     recnum+1        ;get high
   613 00:DE45: 8D B6 E3             sta     dirrec+1        ;and set
   614 00:DE48: 9C B0 E3             stz     recnum+2
   615                        ;
   616                        ;new routine here for using Records
   617                        ; note that the SIM call has changed to xfer the requested Record
   618                        ;
   619                        ; input:recnum, resrec
   620                        ; returns:none
   621                        ; alters:all
   622                        ;
   623                        ; First, get the Reserved Record count and send to SIM.
  Tue Apr 29 2025  4:23                                                                                                    Page 36


   624                        ; Second, get the requested Record and send to SIM.
   625                        ; - the required record will be calculated in SIM.
   626                        ; - this saves some space in PEM and overall execution time.
   627                        ;
   628                        setrec
   629 00:DE4B: AD C9 E3             lda     resrec          ;get the reserved record lo count (4)
   630 00:DE4E: AC CA E3             ldy     resrec+1        ;get the reserved record hi count (4)
   631 00:DE51: 20 1E E4             jsr     simram+30       ;call sim to set reserved record count (6)
   632                        ;
   633 00:DE54: AD AE E3             lda     recnum          ;get record number lo (4)
   634 00:DE57: AC AF E3             ldy     recnum+1        ;get record number hi (4)
   635 00:DE5A: 4C 21 E4             jmp     simram+33       ;call sim to set requested record, return (3)
   636                        ;
   637                        ;get block bit mask and index
   638                        ; input:a&y=block number
   639                        ; returns:a=bit mask
   640                        ; alters:all and alcpnt
   641 00:DE5D: 48           blkmsk  pha                     ;save block number low byte
   642 00:DE5E: 84 C5                sty     alcpnt+1        ;store block number high byte
   643                        ;
   644 00:DE60: 46 C5                lsr     alcpnt+1        ;shift high byte by 3
   645 00:DE62: 6A                   ror     a
   646 00:DE63: 46 C5                lsr     alcpnt+1
   647 00:DE65: 6A                   ror     a
   648 00:DE66: 46 C5                lsr     alcpnt+1
   649 00:DE68: 6A                   ror     a
   650                        ;
   651 00:DE69: 18                   clc                     ;clear carry for add
   652 00:DE6A: 6D CE E3             adc     alcmap          ;then add in map start
   653 00:DE6D: 85 C4                sta     alcpnt
   654 00:DE6F: A5 C5                lda     alcpnt+1
   655 00:DE71: 6D CF E3             adc     alcmap+1
   656 00:DE74: 85 C5                sta     alcpnt+1
   657                        ;
   658 00:DE76: 68                   pla                     ;get block number low byte back
   659 00:DE77: 29 07                and     #%00000111      ;mask off the lower 3 bits
   660 00:DE79: AA                   tax                     ;xfer for index
   661 00:DE7A: BD 7C E3             lda     bitmsk,x        ;get the bit mask
   662 00:DE7D: 60                   rts                     ;and return
   663                        ;
   664                        ;alter block status
   665                        ; input:a&y=block number,x=1 if set
   666                        ;                        x=0 if reset
   667                        ; returns:none
   668                        ; alters:all and allocation map
   669 00:DE7E: E0 01        altalc  cpx     #1              ;if set
   670 00:DE80: F0 0A                beq     setblk          ;go do it
   671 00:DE82: 20 5D DE     clrblk  jsr     blkmsk          ;else get mask
   672 00:DE85: 49 FF                eor     #$FF            ;and complement
   673 00:DE87: 32 C4                and     (alcpnt)        ;preserve others
   674 00:DE89: 92 C4                sta     (alcpnt)        ;and save
   675 00:DE8B: 60                   rts                     ;then return
   676                        ;
   677 00:DE8C: 20 5D DE     setblk  jsr     blkmsk          ;get mask
   678 00:DE8F: 12 C4                ora     (alcpnt)        ;set bit
   679 00:DE91: 92 C4                sta     (alcpnt)        ;and put back
   680 00:DE93: 60                   rts                     ;then return
   681                        ;
   682                        ;set current drive to read only
   683                        ; input:curdrv,ronlst,bitmap
   684                        ; returns:none
   685                        ; alters:a,x,p and ronlst
   686 00:DE94: AE A8 E3     setron  ldx     curdrv          ;get number
  Tue Apr 29 2025  4:23                                                                                                    Page 37


   687 00:DE97: BD 84 E3             lda     bitmap,x        ;and get mask
   688 00:DE9A: 0C AA E3             tsb     ronlst          ;set drive bit
   689 00:DE9D: 60                   rts                     ;then return
   690                        ;
   691                        ;initialize record counters from fcb
   692                        ; input:fcb@(addinp)
   693                        ; returns:none
   694                        ; alters:a,y,p,nxtrec,numrec
   695 00:DE9E: A0 20        inrcct  ldy     #32             ;next record offset
   696 00:DEA0: B1 C0                lda     (addinp),y      ;get next record
   697 00:DEA2: 8D B3 E3             sta     nxtrec          ;and save
   698 00:DEA5: A0 0F                ldy     #15             ;number records offset
   699 00:DEA7: B1 C0                lda     (addinp),y      ;get number
   700 00:DEA9: 8D B4 E3             sta     numrec          ;and save
   701 00:DEAC: 60                   rts                     ;and return
   702                        ;
   703                        ;update record counters in fcb
   704                        ; input:nxtrec,numrec
   705                        ; returns:none
   706                        ; alters:all,fcb@(addinp)
   707 00:DEAD: AE B3 E3     updtrc  ldx     nxtrec          ;get next record
   708 00:DEB0: E8                   inx                     ;bump it
   709 00:DEB1: 8A                   txa                     ;transfer
   710 00:DEB2: A0 20                ldy     #32             ;set offset
   711 00:DEB4: 91 C0                sta     (addinp),y      ;and store in fcb
   712 00:DEB6: AD B4 E3             lda     numrec          ;get number
   713 00:DEB9: A0 0F                ldy     #15             ;and its offset
   714 00:DEBB: 91 C0                sta     (addinp),y      ;and store
   715 00:DEBD: 60                   rts                     ;then return
   716                        ;
   717                        ;execute open file
   718 00:DEBE: 20 A4 DC     xopen   jsr     autodr          ;auto drive select
   719                        ;
   720                        ;open file
   721                        ; input:fcb @ (addinp)
   722                        ; returns:n=1 if not found,a=dirmod (255 if not found)
   723                        ; alters:all
   724 00:DEC1: 20 26 DF     opnfle  jsr     fndf13          ;match all including extent
   725 00:DEC4: 30 32                bmi     extopn          ;done if not found
   726 00:DEC6: A9 0C                lda     #12             ;point to first char
   727 00:DEC8: 0D AD E3             ora     subrec          ;add offset
   728 00:DECB: A8                   tay                     ;make it a pointer
   729 00:DECC: B1 C2        nxopmv  lda     (bufadd),y      ;get buffer contents
   730 00:DECE: AA                   tax                     ;and save
   731 00:DECF: 98                   tya                     ;save index
   732 00:DED0: 29 1F                and     #%00011111      ;remove offset
   733 00:DED2: A8                   tay                     ;back to index
   734 00:DED3: 8A                   txa                     ;get byte back
   735 00:DED4: 91 C0                sta     (addinp),y      ;and store in fcb
   736 00:DED6: 98                   tya                     ;get index
   737 00:DED7: 0D AD E3             ora     subrec          ;add offset back
   738 00:DEDA: A8                   tay                     ;and make index again
   739 00:DEDB: C8                   iny                     ;next position
   740 00:DEDC: 98                   tya                     ;if index
   741 00:DEDD: 29 1F                and     #%00011111      ;not gone past
   742 00:DEDF: D0 EB                bne     nxopmv          ;end then loop
   743                        ;now correct extent and max records
   744 00:DEE1: A0 0C                ldy     #12             ;point at extent in fcb
   745 00:DEE3: AD 98 E3             lda     savext          ;get save from search
   746 00:DEE6: D1 C0                cmp     (addinp),y      ;compare
   747 00:DEE8: F0 0B                beq     extsme          ;jump ahead if same
   748 00:DEEA: 91 C0                sta     (addinp),y      ;else change extent
   749 00:DEEC: A9 80                lda     #128            ;assume fcb ext < dir ext
  Tue Apr 29 2025  4:23                                                                                                    Page 38


   750 00:DEEE: 90 01                bcc     fcbxls          ;jump ahead if true
   751 00:DEF0: 0A                   asl     a               ;clear a
   752 00:DEF1: A0 0F        fcbxls  ldy     #15             ;point to max
   753 00:DEF3: 91 C0                sta     (addinp),y      ;and set
   754 00:DEF5: AD B7 E3     extsme  lda     dirmod          ;else get number
   755 00:DEF8: 60           extopn  rts                     ;and return
   756                        ;
   757                        ;execute close file
   758 00:DEF9: 20 A4 DC     xclose  jsr     autodr          ;auto drive select
   759                        ;
   760                        ;close file
   761                        ;if file is r/o then no actual close
   762                        ;operation is performed.
   763                        ; input:fcb @ (addinp)
   764                        ; returns:n=1 if not valid,a=dirmod (255 if invalid)
   765                        ; alters:all
   766 00:DEFC: 20 26 DF     clsfle  jsr     fndf13          ;match including extent
   767 00:DEFF: 30 21                bmi     extcls          ;exit if not found
   768                        ;
   769                        ;check read/write status
   770                        ; input:curdrv,ronlst
   771                        ; returns:z=0 if r/o or z=1 if r/w
   772                        ; alters:a,x,p
   773 00:DF01: AE A8 E3             ldx     curdrv          ;get current drive
   774 00:DF04: BD 84 E3             lda     bitmap,x        ;get mask
   775 00:DF07: 2D AA E3             and     ronlst          ;and test status
   776 00:DF0A: D0 13                bne     noclse          ;branch if is
   777                        ;now set flag to ensure directory extent and number of
   778                        ;records fields are only changed if necessary.
   779                        ;The decision to change is determined by whether or
   780                        ;not the system is closing an extent less than the
   781                        ;maximum extent in the directory entry. If that is
   782                        ;the case, the directory extent and number of record
   783                        ;fields are not changed.
   784 00:DF0C: A0 0C                ldy     #12             ;get extent
   785 00:DF0E: B1 C0                lda     (addinp),y
   786 00:DF10: 48                   pha                     ;save it
   787 00:DF11: 98                   tya                     ;now look in directory
   788 00:DF12: 0D AD E3             ora     subrec
   789 00:DF15: A8                   tay
   790 00:DF16: 68                   pla                     ;get extent back
   791 00:DF17: D1 C2                cmp     (bufadd),y
   792 00:DF19: 6E 96 E3             ror     skpdir          ;save result
   793                        ;now go do it
   794 00:DF1C: 20 8C DF             jsr     updtdr          ;update directory
   795 00:DF1F: AD B7 E3     noclse  lda     dirmod          ;get directory number
   796 00:DF22: 60           extcls  rts                     ;and return
   797                        ;
   798                        ;execute find first match
   799 00:DF23: 20 A4 DC     xfndfr  jsr     autodr          ;auto drive select
   800 00:DF26: A9 0D        fndf13  lda     #13             ;match including extent
   801                        ;search for first match
   802                        ; input:a=number char to match
   803                        ; returns:n=1 if invalid,a=dirmod (255 if invalid)
   804                        ; alters:all
   805 00:DF28: 48           frstsr  pha                     ;save number to match
   806 00:DF29: 20 3C E0             jsr     cldrnm          ;clear directory number to -1
   807 00:DF2C: 68                   pla                     ;get number to match
   808                        ;search for directory match
   809                        ; input:a=number char to match
   810                        ; returns:n=1 if not found,a=dirmod (255 if invalid)
   811                        ; alters:all
   812 00:DF2D: 8D B1 E3     search  sta     chrcnt          ;save number
  Tue Apr 29 2025  4:23                                                                                                    Page 39


   813 00:DF30: 9C B2 E3     newtry  stz     cmppnt          ;clear pointer
   814 00:DF33: 20 26 E0             jsr     nxtdir          ;get next entry
   815 00:DF36: 30 37                bmi     exitsr          ;exit if not found
   816 00:DF38: AE B1 E3             ldx     chrcnt          ;get count
   817 00:DF3B: AC B2 E3     mremch  ldy     cmppnt          ;get pointer
   818 00:DF3E: EE B2 E3             inc     cmppnt          ;and bump
   819 00:DF41: B1 C0                lda     (addinp),y      ;get fcb entry
   820 00:DF43: C0 0C                cpy     #12             ;see if at extent
   821 00:DF45: D0 13                bne     notaex          ;jump if not
   822 00:DF47: 8D 98 E3             sta     savext          ;save for later use
   823 00:DF4A: 48                   pha                     ;save extent
   824 00:DF4B: 98                   tya                     ;change to directory
   825 00:DF4C: 0D AD E3             ora     subrec          ;coordinates
   826 00:DF4F: A8                   tay
   827 00:DF50: 68                   pla                     ;get extent back
   828 00:DF51: 51 C2                eor     (bufadd),y      ;exclusive or with dir
   829 00:DF53: 2D D1 E3             and     cexm1f          ;and with exm complement + 1f
   830 00:DF56: F0 11                beq     trynxt          ;ok if zero
   831 00:DF58: 80 D6                bra     newtry          ;else get next directory
   832 00:DF5A: C9 3F        notaex  cmp     #'?'            ;if a ? then
   833 00:DF5C: F0 0B                beq     trynxt          ;is a match
   834 00:DF5E: 48                   pha                     ;save char
   835 00:DF5F: 98                   tya                     ;then add
   836 00:DF60: 0D AD E3             ora     subrec          ;offset to
   837 00:DF63: A8                   tay                     ;make pointer
   838 00:DF64: 68                   pla                     ;get char back
   839 00:DF65: D1 C2                cmp     (bufadd),y      ;if not same
   840 00:DF67: D0 C7                bne     newtry          ;try next directory
   841 00:DF69: CA           trynxt  dex                     ;else count number down
   842 00:DF6A: D0 CF                bne     mremch          ;and loop if more
   843 00:DF6C: AD B7 E3             lda     dirmod          ;return with directory
   844 00:DF6F: 60           exitsr  rts                     ;number mod 4
   845                        ;
   846                        ;calculate logical record number
   847                        ; input:blknum
   848                        ; returns:none
   849                        ; alters:a,x,p,recnum
   850 00:DF70: AE BF E3     calrcn  ldx     sxb             ;set x according to blkscd
   851 00:DF73: 0E AE E3     mulmre  asl     blknum          ;multiply block
   852 00:DF76: 2E AF E3             rol     blknum+1        ;number
   853 00:DF79: 2E B0 E3             rol     blknum+2
   854 00:DF7C: CA                   dex                     ;by code
   855 00:DF7D: D0 F4                bne     mulmre
   856 00:DF7F: AD BE E3             lda     sab             ;set mask in a
   857 00:DF82: 2D B3 E3             and     nxtrec          ;and with next record
   858 00:DF85: 0D AE E3             ora     recnum          ;or with number
   859 00:DF88: 8D AE E3             sta     recnum          ;and save
   860 00:DF8B: 60                   rts
   861                        ;
   862                        ;update directory
   863 00:DF8C: A9 20        updtdr  lda     #32             ;change all
   864 00:DF8E: A2 00                ldx     #0              ;from start
   865                        ;
   866                        ;change directory entry
   867                        ; input:a=number char to change,x=starting position,fcb@(addinp)
   868                        ; returns:none
   869                        ; alters:all,directory,checksums
   870 00:DF90: 8D B1 E3     dirchg  sta     chrcnt          ;save count
   871 00:DF93: CE B1 E3             dec     chrcnt          ;back up
   872 00:DF96: 18           mrechg  clc                     ;clear carry
   873 00:DF97: 8A                   txa                     ;get offset
   874 00:DF98: 6D B1 E3             adc     chrcnt          ;compute index
   875 00:DF9B: A8                   tay                     ;and set
  Tue Apr 29 2025  4:23                                                                                                    Page 40


   876 00:DF9C: C0 0C                cpy     #12             ;see if at extent
   877 00:DF9E: F0 04                beq     docare          ;if so do special
   878 00:DFA0: C0 0F                cpy     #15             ;see if at number rec
   879 00:DFA2: D0 05                bne     dntcar          ;if not skip
   880 00:DFA4: 2C 96 E3     docare  bit     skpdir          ;check flag
   881 00:DFA7: 10 0D                bpl     nochng          ;skip if ok
   882 00:DFA9: B1 C0        dntcar  lda     (addinp),y      ;get char
   883 00:DFAB: 48                   pha                     ;save it
   884 00:DFAC: AD B1 E3             lda     chrcnt          ;get count
   885 00:DFAF: 0D AD E3             ora     subrec          ;add offset
   886 00:DFB2: A8                   tay                     ;make an index
   887 00:DFB3: 68                   pla                     ;get char back
   888 00:DFB4: 91 C2                sta     (bufadd),y      ;and put in buffer
   889 00:DFB6: CE B1 E3     nochng  dec     chrcnt          ;count down
   890 00:DFB9: 10 DB                bpl     mrechg          ;and loop
   891 00:DFBB: 20 2B DE             jsr     drrcsu          ;set it up
   892 00:DFBE: 4C 01 E1             jmp     wrtrec          ;write record
   893                        ;
   894                        ;execute create file
   895 00:DFC1: 20 A4 DC     xmake   jsr     autodr          ;auto drive select
   896                        ;
   897                        ;create file
   898                        ; input:fcb@(addinp)
   899                        ; returns:n=1 if not valid,a=dirmod (255 if not valid)
   900                        ; alters:dirnum,dirmod,fcb@(addinp)
   901 00:DFC4: 20 E2 E0     mkefle  jsr     tstron          ;test for r/o
   902 00:DFC7: A5 C0                lda     addinp          ;save fcb
   903 00:DFC9: 48                   pha                     ;address
   904 00:DFCA: A5 C1                lda     addinp+1        ;on
   905 00:DFCC: 48                   pha                     ;stack
   906 00:DFCD: A9 7B                lda     #<empty         ;then point
   907 00:DFCF: A0 E3                ldy     #>empty         ;to empty
   908 00:DFD1: 85 C0                sta     addinp          ;dummy
   909 00:DFD3: 84 C1                sty     addinp+1        ;fcb
   910 00:DFD5: A9 01                lda     #1              ;match only
   911 00:DFD7: 20 28 DF             jsr     frstsr          ;first char
   912 00:DFDA: 68                   pla                     ;restore
   913 00:DFDB: 85 C1                sta     addinp+1        ;fcb
   914 00:DFDD: 68                   pla                     ;address
   915 00:DFDE: 85 C0                sta     addinp          ;from stack
   916 00:DFE0: AD B7 E3             lda     dirmod          ;get number mod 4
   917 00:DFE3: 30 15                bmi     extmke          ;quit if not found
   918 00:DFE5: A0 0D                ldy     #13             ;else set up
   919 00:DFE7: A9 00                lda     #0              ;to clear
   920 00:DFE9: 91 C0        mkeagn  sta     (addinp),y      ;rest of
   921 00:DFEB: C8                   iny                     ;fcb
   922 00:DFEC: C0 21                cpy     #33             ;including next
   923 00:DFEE: D0 F9                bne     mkeagn          ;record
   924                        ;the next two lines ensure that the extent and
   925                        ;number of records fields are updated
   926 00:DFF0: 38                   sec
   927 00:DFF1: 6E 96 E3             ror     skpdir
   928 00:DFF4: 20 8C DF             jsr     updtdr          ;update directory
   929 00:DFF7: AD B7 E3             lda     dirmod          ;get number
   930 00:DFFA: 60           extmke  rts                     ;and quit
   931                        ;
   932                        ;extend file
   933                        ; input:fcb@(addinp), x=1 read
   934                        ;                     x=0 write
   935                        ; d65flg bit 6 used instead of X reg.
   936                        ; calling routine sets flag bit before calling here.
   937 00:DFFB: 20 FC DE     extend  jsr     clsfle          ;close current extent
   938 00:DFFE: 30 25                bmi     extext          ;exit if not found
  Tue Apr 29 2025  4:23                                                                                                    Page 41


   939 00:E000: A0 0C                ldy     #12             ;else
   940 00:E002: B1 C0                lda     (addinp),y      ;get extent
   941 00:E004: 1A                   inc     a               ;add one ;-)
   942 00:E005: 29 1F                and     #%00011111      ;see if overflow
   943 00:E007: F0 14                beq     exteof          ;eof if so
   944 00:E009: 91 C0                sta     (addinp),y      ;and save
   945 00:E00B: 20 26 DF             jsr     fndf13          ;see if next extent exists
   946 00:E00E: 10 08                bpl     opnext          ;if so open
   947 00:E010: EF C6 12             bbs6    d65flg,extext   ;test extend flag, branch if write
   948 00:E013: 20 C4 DF             jsr     mkefle          ;create file
   949 00:E016: 80 03                bra     tstext          ;and test
   950 00:E018: 20 C1 DE     opnext  jsr     opnfle          ;open
   951 00:E01B: 10 03        tstext  bpl     extnok          ;continue if ok
   952 00:E01D: A9 01        exteof  lda     #1              ;else set eof
   953 00:E01F: 60                   rts                     ;and return
   954 00:E020: 20 9E DE     extnok  jsr     inrcct          ;initialize counters
   955 00:E023: A9 00                lda     #0              ;0 for good
   956 00:E025: 60           extext  rts                     ;return
   957                        ;
   958                        ;set up next directory block
   959                        ; input:dirnum,x=1 for update checksum
   960                        ; returns:a=dirmod (255 if invalid),n=1 if invalid
   961                        ; alters:all,dirnum,dirmod
   962 00:E026: EE AB E3     nxtdir  inc     dirnum          ;bump directory
   963 00:E029: D0 03                bne     skpdr
   964 00:E02B: EE AC E3             inc     dirnum+1
   965 00:E02E: AD CC E3     skpdr   lda     maxdir          ;if not at limit continue
   966 00:E031: CD AB E3             cmp     dirnum
   967 00:E034: AD CD E3             lda     maxdir+1
   968 00:E037: ED AC E3             sbc     dirnum+1
   969 00:E03A: B0 0C                bcs     gtnxdr          ;then continue
   970                        ;
   971                        ;clear directory number to $FFFF
   972                        ; input:none
   973                        ; returns:a=$ff,n=1,z=0
   974                        ; alters:a,p,dirnum,dirmod
   975 00:E03C: A9 FF        cldrnm  lda     #$FF            ;set to $FF
   976 00:E03E: 8D AB E3             sta     dirnum
   977 00:E041: 8D AC E3             sta     dirnum+1
   978 00:E044: 8D B7 E3             sta     dirmod
   979 00:E047: 60                   rts
   980                        ;
   981 00:E048: AD AB E3     gtnxdr  lda     dirnum          ;get low again
   982 00:E04B: 29 03                and     #%00000011      ;look at 2 lsbs
   983 00:E04D: 8D B7 E3             sta     dirmod          ;save mod 4
   984 00:E050: 0A                   asl     a               ;multiply
   985 00:E051: 0A                   asl     a               ;by
   986 00:E052: 0A                   asl     a               ;32 to
   987 00:E053: 0A                   asl     a               ;get pointer
   988 00:E054: 0A                   asl     a               ;offset
   989 00:E055: 8D AD E3             sta     subrec          ;and save
   990 00:E058: F0 02                beq     getdir          ;if zero read new
   991 00:E05A: 80 06                bra     gotdir          ;and exit
   992 00:E05C: 20 2B DE     getdir  jsr     drrcsu          ;set up to read
   993 00:E05F: 20 FA E0             jsr     rderec          ;do read
   994 00:E062: AD B7 E3     gotdir  lda     dirmod          ;and return
   995 00:E065: 60                   rts                     ;with number
   996                        ;
   997                        ;get block number
   998                        ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
   999                        ; returns:none
  1000                        ; alters:all,blknum
  1001 00:E066: AE BF E3     getblk  ldx     sxb             ;set x according to blkscd
  Tue Apr 29 2025  4:23                                                                                                    Page 42


  1002 00:E069: AD B3 E3             lda     nxtrec          ;get next record
  1003 00:E06C: 4A           gblp    lsr     a               ;divide by 2 x times
  1004 00:E06D: CA                   dex
  1005 00:E06E: D0 FC                bne     gblp
  1006 00:E070: 8D AE E3             sta     blknum          ;save previous as temp
  1007                        ;use extent as offset but first use sxb to create param
  1008 00:E073: 38                   sec
  1009 00:E074: A9 08                lda     #8
  1010 00:E076: ED BF E3             sbc     sxb
  1011 00:E079: AA                   tax
  1012                        ;now get extent from fcb
  1013 00:E07A: A0 0C                ldy     #12
  1014 00:E07C: B1 C0                lda     (addinp),y
  1015 00:E07E: 2D D0 E3             and     exm             ;and with mask
  1016 00:E081: 4A                   lsr     a               ;shift with lsb to c
  1017 00:E082: 2A           gbxlp   rol     a               ;now go other way
  1018 00:E083: CA                   dex
  1019 00:E084: D0 FC                bne     gbxlp
  1020 00:E086: 18                   clc                     ;now add saved value
  1021 00:E087: 6D AE E3             adc     blknum          ;back
  1022 00:E08A: 7F C6 01             bbr7    d65flg,blm2     ;test mode, branch if byte
  1023 00:E08D: 0A                   asl     a               ;else times two
  1024 00:E08E: 18           blm2    clc                     ;then add
  1025 00:E08F: 69 10                adc     #16             ;offset into fcb
  1026 00:E091: 8D 97 E3             sta     fcbind          ;save for later
  1027 00:E094: A8                   tay                     ;set index
  1028 00:E095: B1 C0                lda     (addinp),y      ;get number
  1029 00:E097: 8D AE E3             sta     blknum          ;store
  1030 00:E09A: C8                   iny
  1031 00:E09B: A9 00                lda     #0              ;clear
  1032 00:E09D: 7F C6 02             bbr7    d65flg,blm3     ;test mode, branch if byte
  1033 00:E0A0: B1 C0                lda     (addinp),y      ;else get high
  1034 00:E0A2: 8D AF E3     blm3    sta     blknum+1        ;high byte
  1035 00:E0A5: 60                   rts                     ;and return
  1036                        ;
  1037                        ;change allocation map
  1038                        ; input:subrec,directory record @ (bufadd)
  1039                        ; returns:none
  1040                        ; alters:all,allocation map
  1041                        ;
  1042                        ; Note: the "gthibn" routine has been integrated
  1043                        ; into this routine. While it does take a few
  1044                        ; extra bytes of code space, it eliminates a pair
  1045                        ; of JSR/RTS sequences, improving performance.
  1046 00:E0A6: 18           mapdir  clc                     ;add 16 to
  1047 00:E0A7: AD AD E3             lda     subrec          ;to subrec to point
  1048 00:E0AA: 69 10                adc     #16             ;to block number field
  1049 00:E0AC: A8                   tay                     ;make index
  1050 00:E0AD: 8C BA E3     lpmpdr  sty     mpdrsy          ;save index
  1051 00:E0B0: DA                   phx                     ;save x operation
  1052 00:E0B1: B1 C2                lda     (bufadd),y      ;get block number
  1053 00:E0B3: 8D BB E3             sta     mpdrtm          ;save in temp
  1054 00:E0B6: C8                   iny                     ;bump index for word
  1055                        ;
  1056                        ;get high part of block number if word (zero if byte)
  1057                        ; input:y=index to high,blmode,directory@(bufadd)+subrec
  1058                        ; returns:a=high part of block number
  1059                        ; alters:a,p,mpdrsy if word
  1060                        ;
  1061 00:E0B7: A9 00                lda     #0              ;preset for byte
  1062 00:E0B9: 7F C6 05             bbr7    d65flg,mpdrnw   ;test mode, branch if byte
  1063 00:E0BC: B1 C2                lda     (bufadd),y      ;get high
  1064 00:E0BE: 8C BA E3             sty     mpdrsy          ;alter y
  Tue Apr 29 2025  4:23                                                                                                    Page 43


  1065 00:E0C1: 0D BB E3     mpdrnw  ora     mpdrtm          ;see if zero
  1066 00:E0C4: F0 11                beq     skpedr          ;skip if zero
  1067                        ;
  1068                        ;get high part of block number if word (zero if byte)
  1069                        ; input:y=index to high,blmode,directory@(bufadd)+subrec
  1070                        ; returns:a=high part of block number
  1071                        ; alters:a,p,mpdrsy if word
  1072                        ;
  1073 00:E0C6: A9 00                lda     #0              ;preset for byte
  1074 00:E0C8: 7F C6 05             bbr7    d65flg,gthiex   ;test mode, branch if byte
  1075 00:E0CB: B1 C2                lda     (bufadd),y      ;get high
  1076 00:E0CD: 8C BA E3             sty     mpdrsy          ;alter y
  1077 00:E0D0: A8           gthiex  tay                     ;move to y
  1078 00:E0D1: AD BB E3             lda     mpdrtm          ;get low again
  1079 00:E0D4: 20 7E DE             jsr     altalc          ;else alter map
  1080 00:E0D7: FA           skpedr  plx                     ;get operation back
  1081 00:E0D8: AC BA E3             ldy     mpdrsy          ;get index back
  1082 00:E0DB: C8                   iny                     ;bump it
  1083 00:E0DC: 98                   tya                     ;if still
  1084 00:E0DD: 29 0F                and     #%00001111      ;in field
  1085 00:E0DF: D0 CC                bne     lpmpdr          ;then loop
  1086 00:E0E1: 60           exttro  rts                     ;else quit
  1087                        ;
  1088                        ;test r/w status
  1089                        ;does warm boot if r/o
  1090                        ; input:curdrv,ronlst
  1091                        ; returns:none
  1092                        ; alters:a,x,p
  1093                        tstron
  1094 00:E0E2: AE A8 E3             ldx     curdrv          ;get current drive
  1095 00:E0E5: BD 84 E3             lda     bitmap,x        ;get mask
  1096 00:E0E8: 2D AA E3             and     ronlst          ;and test status
  1097                        ;
  1098 00:E0EB: F0 F4                beq     exttro          ;exit if r/w
  1099 00:E0ED: 20 21 E1             jsr     errout          ;else send error
  1100 00:E0F0: A9 23                lda     #<romsg         ;point to r/o
  1101 00:E0F2: A0 E3                ldy     #>romsg         ;message
  1102 00:E0F4: 20 5F E1             jsr     sndstr          ;send it
  1103 00:E0F7: 4C 9D DA     wrerr   jmp     xwboot          ;then abort
  1104                        ;
  1105                        ;read record
  1106 00:E0FA: 20 27 E4     rderec  jsr     simram+39       ;do read
  1107 00:E0FD: F0 E2                beq     exttro          ;done if A= zero
  1108 00:E0FF: 80 05                bra     rwerrt          ;else handle error
  1109                        ;
  1110                        ;write record
  1111 00:E101: 20 2A E4     wrtrec  jsr     simram+42       ;do write
  1112 00:E104: F0 DB        chkrwe  beq     exttro          ;done if A= zero
  1113                        ;
  1114                        ;read/write error
  1115 00:E106: 20 21 E1     rwerrt  jsr     errout          ;send error message
  1116 00:E109: A9 30                lda     #<bdsmsg        ;point to
  1117 00:E10B: A0 E3                ldy     #>bdsmsg        ;bad record message
  1118 00:E10D: 20 5F E1             jsr     sndstr          ;and send
  1119 00:E110: 20 30 E1             jsr     getcon          ;get input
  1120 00:E113: C9 0D                cmp     #cr             ;if a cr
  1121 00:E115: D0 E0                bne     wrerr           ;if not cr, exit
  1122                        ;
  1123                        ;lf and cr
  1124 00:E117: A9 0A        pcrlf   lda     #lf             ;then a
  1125 00:E119: 20 BA E1             jsr     pchrot          ;lf
  1126 00:E11C: A9 0D                lda     #cr             ;and a
  1127 00:E11E: 4C BA E1             jmp     pchrot          ;cr
  Tue Apr 29 2025  4:23                                                                                                    Page 44


  1128                        ;
  1129                        ;error output routine
  1130                        ; input:curdrv,pemmvc
  1131                        ; returns:none
  1132                        ; alters:all
  1133 00:E121: A9 5A        errout  lda     #<pemmsg        ;point to
  1134 00:E123: A0 E3                ldy     #>pemmsg        ;error message
  1135 00:E125: 20 5F E1             jsr     sndstr          ;send it
  1136 00:E128: AD A8 E3             lda     curdrv          ;get drive number
  1137 00:E12B: 18                   clc                     ;add
  1138 00:E12C: 69 41                adc     #'A'            ;ascii a
  1139 00:E12E: 80 79                bra     sndchr          ;and send it
  1140                        ;
  1141                        ;get console input
  1142                        ; input:pndkey
  1143                        ; returns:a=character
  1144                        ; alters:all,pndkey
  1145 00:E130: AD 9A E3     getcon  lda     pndkey          ;get pending key
  1146 00:E133: 9C 9A E3             stz     pndkey          ;clear pending key
  1147 00:E136: D0 26                bne     extkbd          ;exit if not null
  1148 00:E138: 4C 09 E4             jmp     simram+9        ;else get new key, return
  1149                        ;
  1150                        ;check keyboard status
  1151                        ;handles <ctl-s> for freeze and <ctl-c> for boot
  1152                        ; input:pndkey
  1153                        ; returns:a=0 if no input or <>0 if input
  1154                        ; alters:all,pndkey
  1155 00:E13B: AD 9A E3     kbdsts  lda     pndkey          ;get pending key
  1156 00:E13E: D0 1E                bne     extkbd          ;if there is one, exit
  1157 00:E140: 20 06 E4             jsr     simram+6        ;else check console status
  1158 00:E143: F0 19                beq     extkbd          ;if no character in console, exit
  1159 00:E145: 20 09 E4             jsr     simram+9        ;else get input from console
  1160 00:E148: C9 13                cmp     #ctls           ;check for freeze
  1161 00:E14A: D0 0D                bne     newpnd          ;if not, save input
  1162 00:E14C: 20 09 E4             jsr     simram+9        ;else wait for next input
  1163 00:E14F: C9 03                cmp     #ctlc           ;check for cancel
  1164 00:E151: D0 03                bne     nowarm          ;if not, then finish
  1165 00:E153: 4C 9D DA             jmp     xwboot          ;else do a warm boot
  1166 00:E156: A9 00        nowarm  lda     #0              ;clear
  1167 00:E158: 60                   rts                     ;and return
  1168 00:E159: 8D 9A E3     newpnd  sta     pndkey          ;save input
  1169 00:E15C: A9 FF                lda     #$FF            ;set ready
  1170 00:E15E: 60           extkbd  rts                     ;and return
  1171                        ;
  1172                        ;send string ending in $
  1173                        ; input:ay=string address
  1174                        ; returns:none
  1175                        ; alters:all,index,sndlpe+1 and +2
  1176 00:E15F: 8D 68 E1     sndstr  sta     sndlpe+1        ;set pointer
  1177 00:E162: 8C 69 E1             sty     sndlpe+2
  1178 00:E165: A0 00                ldy     #0
  1179 00:E167: B9 FF FF     sndlpe  lda     $FFFF,y         ;get char
  1180 00:E16A: C9 24                cmp     #'$'            ;if terminator
  1181 00:E16C: F0 08                beq     sndext          ;then exit
  1182 00:E16E: C8                   iny                     ;else bump
  1183 00:E16F: 5A                   phy                     ;save index
  1184 00:E170: 20 A9 E1             jsr     sndchr          ;send char
  1185 00:E173: 7A                   ply                     ;restore index
  1186 00:E174: D0 F1                bne     sndlpe          ;and loop
  1187 00:E176: 60           sndext  rts                     ;return
  1188                        ;
  1189                        ;send char to printer if enabled
  1190                        ; input:a=character,lstflg
  Tue Apr 29 2025  4:23                                                                                                    Page 45


  1191                        ; returns:a=character
  1192                        ; alters:x,y,p
  1193                        ; ensure A reg is preserved by SIM routine!
  1194 00:E177: 2C 9B E3     lstout  bit     lstflg          ;test flag
  1195 00:E17A: 10 FA                bpl     sndext          ;exit if off
  1196 00:E17C: CF C6 F7             bbs4    d65flg,sndext   ;test out flag, branch if set
  1197 00:E17F: 4C 0F E4             jmp     simram+15       ;send (dummy routine), return
  1198                        ;
  1199                        ;output a character
  1200                        ; input:a=character,console definition block in sim
  1201                        ; returns:none
  1202                        ; alters:all,positn
  1203                        output
  1204                        ;test character
  1205                        ; input:a=character
  1206                        ; returns:c=0 if control or c=1 if printing
  1207                        ; alters:p
  1208 00:E182: C9 0D                cmp     #cr             ;if cr
  1209 00:E184: F0 0A                beq     chtxt1          ;quit
  1210 00:E186: C9 0A                cmp     #lf             ;if linefeed
  1211 00:E188: F0 06                beq     chtxt1          ;quit
  1212 00:E18A: C9 09                cmp     #ctli           ;if tab
  1213 00:E18C: F0 02                beq     chtxt1          ;quit
  1214 00:E18E: C9 20                cmp     #' '            ;see if control
  1215                        chtxt1
  1216 00:E190: B0 17                bcs     sndchr          ;if not control jump
  1217 00:E192: 48                   pha                     ;else save
  1218 00:E193: AD 3B E4             lda     sysdef+4        ;get invert
  1219 00:E196: 20 C2 E1             jsr     nolist          ;send to console
  1220 00:E199: A9 5E                lda     #'^'            ;get arrow
  1221 00:E19B: 20 77 E1             jsr     lstout          ;send to printer
  1222 00:E19E: 68                   pla                     ;get character
  1223 00:E19F: 09 40                ora     #'A'-1          ;convert to ascii
  1224 00:E1A1: 20 BA E1             jsr     pchrot          ;send to all
  1225 00:E1A4: AD 3A E4             lda     sysdef+3        ;get normal
  1226 00:E1A7: 80 19                bra     nolist          ;to console
  1227 00:E1A9: C9 09        sndchr  cmp     #ctli           ;if not tab
  1228 00:E1AB: D0 0D                bne     pchrot          ;send
  1229 00:E1AD: A9 20        tabspc  lda     #' '            ;else get space
  1230 00:E1AF: 20 BA E1             jsr     pchrot          ;send
  1231 00:E1B2: AD 9C E3             lda     positn          ;get count
  1232 00:E1B5: 29 07                and     #7              ;if not mod 8
  1233 00:E1B7: D0 F4                bne     tabspc          ;loop
  1234 00:E1B9: 60                   rts                     ;else exit
  1235 00:E1BA: 48           pchrot  pha                     ;save char
  1236 00:E1BB: 20 3B E1             jsr     kbdsts          ;test input
  1237 00:E1BE: 68                   pla                     ;restore
  1238 00:E1BF: 20 77 E1             jsr     lstout          ;to printer if on
  1239 00:E1C2: 48           nolist  pha                     ;save again
  1240 00:E1C3: CF C6 03             bbs4    d65flg,no_oflg  ;test out flag, branch if set
  1241 00:E1C6: 20 0C E4             jsr     simram+12       ;send to console
  1242 00:E1C9: 68           no_oflg pla                     ;restore
  1243 00:E1CA: EE 9C E3             inc     positn          ;bump col
  1244 00:E1CD: C9 20                cmp     #' '            ;if space or more
  1245 00:E1CF: B0 24                bcs     extchr          ;is ok
  1246 00:E1D1: CD 39 E4             cmp     sysdef+2        ;also ok
  1247 00:E1D4: F0 1F                beq     extchr          ;if forward
  1248 00:E1D6: CE 9C E3             dec     positn          ;else drop back
  1249 00:E1D9: CD 37 E4             cmp     sysdef+0        ;see if bs
  1250 00:E1DC: D0 06                bne     tryotr          ;branch if not
  1251 00:E1DE: CE 9C E3             dec     positn          ;else drop again
  1252 00:E1E1: 30 0F                bmi     zrocol          ;zero if <0
  1253 00:E1E3: 60           lstext  rts                     ;else ok, return
  Tue Apr 29 2025  4:23                                                                                                    Page 46


  1254 00:E1E4: C9 0D        tryotr  cmp     #cr             ;if a cr
  1255 00:E1E6: F0 0A                beq     zrocol          ;clear col
  1256 00:E1E8: CD 3E E4             cmp     sysdef+7        ;if a formfeed
  1257 00:E1EB: F0 05                beq     zrocol          ;also clear
  1258 00:E1ED: CD 3F E4             cmp     sysdef+8        ;if not home
  1259 00:E1F0: D0 03                bne     extchr          ;then done
  1260 00:E1F2: 9C 9C E3     zrocol  stz     positn          ;column
  1261 00:E1F5: 60           extchr  rts                     ;and exit
  1262                        ;
  1263                        ;go to left and space past prompt
  1264                        ; input:frscol,positn
  1265                        ; returns:none
  1266                        ; alters:positn
  1267 00:E1F6: A9 0D        spcovr  lda     #cr             ;get cr
  1268 00:E1F8: 20 BA E1             jsr     pchrot          ;send to all
  1269 00:E1FB: A9 0A                lda     #lf             ;send lf
  1270                        ;
  1271                        ;send char to printer if enabled
  1272                        ; input:a=character,lstflg
  1273                        ; returns:a=character
  1274                        ; alters:x,y,p
  1275                        ; ensure A reg is preserved by SIM routine!
  1276 00:E1FD: 2C 9B E3             bit     lstflg          ;test flag
  1277 00:E200: 10 F3                bpl     extchr          ;exit if off
  1278 00:E202: CF C6 F0             bbs4    d65flg,extchr   ;test out flag, branch if set
  1279 00:E205: 20 0F E4             jsr     simram+15       ;send (dummy routine), return
  1280                        ;
  1281 00:E208: AD 99 E3     mreovr  lda     frscol          ;get first
  1282 00:E20B: CD 9C E3             cmp     positn          ;see if there
  1283 00:E20E: F0 E5                beq     extchr          ;done if is
  1284 00:E210: AD 39 E4             lda     sysdef+2        ;get forward
  1285 00:E213: 20 C2 E1             jsr     nolist          ;send it
  1286 00:E216: 80 F0                bra     mreovr          ;and loop
  1287                        ;
  1288                        ;buffered read
  1289                        ; input:buffer@(addinp)
  1290                        ; returns:none
  1291                        ; alters:all,buffer@(addinp)
  1292 00:E218: A9 00        bufinp  lda     #0              ;clear
  1293 00:E21A: A0 01                ldy     #1              ;length
  1294 00:E21C: 91 C0                sta     (addinp),y      ;position in buffer
  1295 00:E21E: 8C 9F E3             sty     bufpsn          ;set point to 1
  1296 00:E221: AD 9C E3             lda     positn          ;get current
  1297 00:E224: 8D 99 E3             sta     frscol          ;and save
  1298 00:E227: 20 30 E1     nxtinp  jsr     getcon          ;get input
  1299 00:E22A: AC 9F E3             ldy     bufpsn          ;get index
  1300 00:E22D: C9 0D                cmp     #cr             ;if not a cr
  1301 00:E22F: D0 03                bne     notcr           ;then jump
  1302 00:E231: 4C F1 E2             jmp     endlin          ;else done
  1303 00:E234: C9 7F        notcr   cmp     #delete         ;if not delete
  1304 00:E236: D0 59                bne     ntdelt          ;then jump
  1305 00:E238: C0 01                cpy     #1              ;else if start
  1306 00:E23A: F0 EB                beq     nxtinp          ;then loop
  1307 00:E23C: B1 C0                lda     (addinp),y      ;get last
  1308 00:E23E: 48                   pha                     ;save char
  1309 00:E23F: A0 01                ldy     #1              ;point to count
  1310 00:E241: 38                   sec                     ;set carry
  1311 00:E242: B1 C0                lda     (addinp),y      ;get count
  1312 00:E244: E9 01                sbc     #1              ;decrement
  1313 00:E246: 91 C0                sta     (addinp),y      ;then save
  1314 00:E248: 68                   pla                     ;restore char
  1315 00:E249: CE 9F E3             dec     bufpsn          ;backup pointer
  1316 00:E24C: C9 20                cmp     #' '            ;if space or more
  Tue Apr 29 2025  4:23                                                                                                    Page 47


  1317 00:E24E: B0 3C                bcs     nrmbs           ;just backspace
  1318 00:E250: C9 09                cmp     #ctli           ;see if tab
  1319 00:E252: D0 2C                bne     ctlbs           ;if not is control
  1320 00:E254: C7 C6                smb4    d65flg          ;set out flag bit
  1321 00:E256: AD 9C E3             lda     positn          ;get position and save
  1322 00:E259: 8D B9 E3             sta     lstcol
  1323 00:E25C: 20 F6 E1             jsr     spcovr          ;else go back
  1324 00:E25F: 20 F4 E2             jsr     rptlne          ;and retype
  1325 00:E262: AD 9C E3             lda     positn          ;get new last position
  1326 00:E265: 48                   pha                     ;save on stack
  1327 00:E266: 38                   sec                     ;subtract to get delta
  1328 00:E267: AD B9 E3             lda     lstcol
  1329 00:E26A: ED 9C E3             sbc     positn
  1330 00:E26D: 8D B9 E3             sta     lstcol          ;and save
  1331 00:E270: 47 C6                rmb4    d65flg          ;clear out flag bit
  1332 00:E272: 20 12 E3     bstab   jsr     dobs            ;do one
  1333 00:E275: CE B9 E3             dec     lstcol          ;drop count
  1334 00:E278: D0 F8                bne     bstab           ;loop if more
  1335 00:E27A: 68                   pla                     ;get position
  1336 00:E27B: 8D 9C E3             sta     positn          ;and set
  1337 00:E27E: 80 A7                bra     nxtinp          ;then loop
  1338 00:E280: AD 3A E4     ctlbs   lda     sysdef+3        ;get normal
  1339 00:E283: 20 0E E3             jsr     chkbs           ;bs if printing
  1340 00:E286: AD 3B E4             lda     sysdef+4        ;same for invert
  1341 00:E289: 20 0E E3             jsr     chkbs           ;then delete char itself
  1342 00:E28C: 20 12 E3     nrmbs   jsr     dobs            ;do a backspace
  1343 00:E28F: 80 96                bra     nxtinp          ;and loop
  1344 00:E291: C9 10        ntdelt  cmp     #ctlp           ;if not ctl-p
  1345 00:E293: D0 0A                bne     ntctlp          ;then jump
  1346 00:E295: AD 9B E3             lda     lstflg          ;else get printer flag
  1347 00:E298: 49 FF                eor     #$FF            ;complement
  1348 00:E29A: 8D 9B E3             sta     lstflg          ;save
  1349 00:E29D: 80 88                bra     nxtinp          ;and loop
  1350 00:E29F: C9 18        ntctlp  cmp     #ctlx           ;if not ctl-x
  1351 00:E2A1: D0 0C                bne     ntctlx          ;then jump
  1352 00:E2A3: 20 F6 E1             jsr     spcovr          ;restart
  1353 00:E2A6: AD 38 E4             lda     sysdef+1        ;get clear to eol
  1354 00:E2A9: 20 C2 E1             jsr     nolist          ;send it
  1355 00:E2AC: 4C 18 E2             jmp     bufinp          ;and start over
  1356 00:E2AF: C9 12        ntctlx  cmp     #ctlr           ;if not ctl-r
  1357 00:E2B1: D0 09                bne     ntctlr          ;then jump
  1358 00:E2B3: 20 F6 E1             jsr     spcovr          ;restart
  1359 00:E2B6: 20 F4 E2             jsr     rptlne          ;retype line
  1360 00:E2B9: 4C 27 E2             jmp     nxtinp          ;and start over
  1361 00:E2BC: C8           ntctlr  iny                     ;next position
  1362 00:E2BD: 91 C0                sta     (addinp),y      ;store char
  1363 00:E2BF: 48                   pha                     ;and save
  1364 00:E2C0: 8C 9F E3             sty     bufpsn          ;index
  1365 00:E2C3: A0 01                ldy     #1              ;point to count
  1366 00:E2C5: 98                   tya                     ;set a to 1
  1367 00:E2C6: 18                   clc                     ;then
  1368 00:E2C7: 71 C0                adc     (addinp),y      ;add count
  1369 00:E2C9: 91 C0                sta     (addinp),y      ;and save
  1370 00:E2CB: 68                   pla                     ;restore char
  1371 00:E2CC: 20 82 E1             jsr     output          ;send char
  1372 00:E2CF: AC 9F E3             ldy     bufpsn          ;get index
  1373 00:E2D2: B1 C0                lda     (addinp),y      ;get char
  1374 00:E2D4: C9 03                cmp     #ctlc           ;if not ctl-c
  1375 00:E2D6: D0 0B                bne     ignrcc          ;ignore
  1376 00:E2D8: A0 01                ldy     #1              ;get count
  1377 00:E2DA: B1 C0                lda     (addinp),y      ;from buffer
  1378 00:E2DC: C9 01                cmp     #1              ;if not at start
  1379 00:E2DE: D0 03                bne     ignrcc          ;ignore
  Tue Apr 29 2025  4:23                                                                                                    Page 48


  1380 00:E2E0: 4C 9D DA             jmp     xwboot          ;else do warm boot
  1381 00:E2E3: A0 01        ignrcc  ldy     #1              ;get
  1382 00:E2E5: B1 C0                lda     (addinp),y      ;count
  1383 00:E2E7: 88                   dey                     ;point to max
  1384 00:E2E8: D1 C0                cmp     (addinp),y      ;if length
  1385 00:E2EA: B0 03                bcs     lineen          ;at max jump
  1386 00:E2EC: 4C 27 E2             jmp     nxtinp          ;else loop
  1387                        ;
  1388 00:E2EF: A9 0D        lineen  lda     #cr             ;and a
  1389 00:E2F1: 4C BA E1     endlin  jmp     pchrot          ;cr
  1390                        ;
  1391                        ;retype line
  1392 00:E2F4: AD 9F E3     rptlne  lda     bufpsn          ;get pointer
  1393 00:E2F7: 8D B8 E3             sta     numcnt          ;save as count
  1394 00:E2FA: A9 01                lda     #1              ;set start position
  1395 00:E2FC: 48                   pha                     ;save to stack
  1396 00:E2FD: 68           mrerpt  pla                     ;get position (from stack)
  1397 00:E2FE: CE B8 E3             dec     numcnt          ;count down
  1398 00:E301: D0 01                bne     retym           ;continue if more
  1399 00:E303: 60                   rts                     ;else done
  1400 00:E304: A8           retym   tay                     ;else make index
  1401 00:E305: C8                   iny                     ;and bump
  1402 00:E306: 5A                   phy                     ;save on stack
  1403 00:E307: B1 C0                lda     (addinp),y      ;get char
  1404 00:E309: 20 82 E1             jsr     output          ;send
  1405 00:E30C: 80 EF                bra     mrerpt          ;and loop
  1406                        ;check for printing and backspace if needed
  1407 00:E30E: C9 20        chkbs   cmp     #' '            ;compare to space
  1408 00:E310: 90 10                bcc     extprt          ;not printing so done
  1409                        ;do a backspace
  1410 00:E312: AD 37 E4     dobs    lda     sysdef+0        ;get backspace
  1411 00:E315: 48                   pha                     ;save it
  1412 00:E316: 20 C2 E1             jsr     nolist          ;send
  1413 00:E319: A9 20                lda     #' '            ;get space
  1414 00:E31B: 20 C2 E1             jsr     nolist          ;send
  1415 00:E31E: 68                   pla                     ;get backspace
  1416 00:E31F: 4C C2 E1             jmp     nolist          ;send it
  1417 00:E322: 60           extprt  rts                     ;return
  1418                        ;
  1419                        ;messages
  1420 00:E323: 3A 2C 20 52  romsg   .DB     ":, READ-ONLY$"
       00:E327: 45 41 44 2D 
       00:E32B: 4F 4E 4C 59 
       00:E32F: 24 
  1421 00:E330: 3A 2C 20 42  bdsmsg  .DB     ":, BAD BLOCK, <Ret> IGNORE, <Other> ABORT$"
       00:E334: 41 44 20 42 
       00:E338: 4C 4F 43 4B 
       00:E33C: 2C 20 3C 52 
       00:E340: 65 74 3E 20 
       00:E344: 49 47 4E 4F 
       00:E348: 52 45 2C 20 
       00:E34C: 3C 4F 74 68 
       00:E350: 65 72 3E 20 
       00:E354: 41 42 4F 52 
       00:E358: 54 24 
  1422 00:E35A: 0D 0A 50 45  pemmsg  .DB     cr,lf,"PEM ERROR on $"
       00:E35E: 4D 20 45 52 
       00:E362: 52 4F 52 20 
       00:E366: 6F 6E 20 24 
  1423 00:E36A: 3A 2C 20     sltmsg  .DB     ":, "
  1424 00:E36D: 49 4E 56 41  rngmsg  .DB     "INVALID DRIVE$"
       00:E371: 4C 49 44 20 
       00:E375: 44 52 49 56 
  Tue Apr 29 2025  4:23                                                                                                    Page 49


       00:E379: 45 24 
  1425                        ;
  1426                        ;dummy fcb
  1427 00:E37B: E5           empty   .DB     $E5
  1428                        ;
  1429                        ;bit mask table
  1430 00:E37C: 80 40 20 10  bitmsk  .DB     128,64,32,16,8,4,2,1
       00:E380: 08 04 02 01 
  1431                        ;
  1432                        ;bit map table
  1433 00:E384: 01 02 04 08  bitmap  .DB    1,2,4,8,16,32,64,128
       00:E388: 10 20 40 80 
  1434                        ;
  1435                        ;extent mask table (also uses 3 bytes in sabtbl)
  1436 00:E38C: 00 01 03     exmtbl  .DB     0,1,3
  1437                        ;
  1438                        ;sab table
  1439 00:E38F: 07 0F 1F 3F  sabtbl  .DB     7,15,31,63,127
       00:E393: 7F 
  1440                        ;
  1441                        ;variable storage
  1442 00:E394: 00           drvcmd  .DB     0               ;new commanded drive
  1443 00:E395: 00           usrcde  .DB     0               ;user code
  1444 00:E396: 00           skpdir  .DB     0               ;positive if no change
  1445 00:E397: 00           fcbind  .DB     0               ;index to block number
  1446 00:E398: 00           savext  .DB     0               ;save extent
  1447 00:E399: 00           frscol  .DB     0               ;first col
  1448 00:E39A: 00           pndkey  .DB     0               ;pending input
  1449 00:E39B: 00           lstflg  .DB     0               ;printer flag
  1450 00:E39C: 00           positn  .DB     0               ;print position
  1451 00:E39D: 00 00        addout  .DW     0               ;output address
  1452             0000E39D   bytout  .EQU    addout          ;output value
  1453 00:E39F: 00           bufpsn  .DB     0               ;input buffer position
  1454 00:E3A0: 00           tmpdrv  .DB     0               ;temporary drive flag & number
  1455 00:E3A1: 00 00        simrec  .DW     0               ;record number sent to SIM
  1456 00:E3A3: 00 00        lkdown  .DW     0               ;down pnt. for block search
  1457 00:E3A5: 00 00        lookup  .DW     0               ;up pnt. for block search
  1458 00:E3A7: 00           olddrv  .DB     0               ;old drive number
  1459 00:E3A8: 00           curdrv  .DB     0               ;current drive
  1460 00:E3A9: 00           lginvc  .DB     0               ;log in status
  1461 00:E3AA: 00           ronlst  .DB     0               ;read write status
  1462 00:E3AB: 00 00        dirnum  .DW     0               ;directory number
  1463 00:E3AD: 00           subrec  .DB     0               ;directory offset
  1464 00:E3AE: 00 00        recnum  .DW     0               ;record number
  1465             0000E3AE   blknum  .EQU    recnum          ;block number
  1466 00:E3B0: 00                   .DB     0               ;overflow
  1467 00:E3B1: 00           chrcnt  .DB     0               ;character count
  1468 00:E3B2: 00           cmppnt  .DB     0               ;comparison pointer
  1469 00:E3B3: 00           nxtrec  .DB     0               ;next record
  1470 00:E3B4: 00           numrec  .DB     0               ;number records
  1471 00:E3B5: 00 00        dirrec  .DW     0               ;directory record
  1472 00:E3B7: 00           dirmod  .DB     0               ;directory mod 4
  1473 00:E3B8: 00           numcnt  .DB     0               ;counter
  1474 00:E3B9: 00           lstcol  .DB     0               ;last column
  1475 00:E3BA: 00           mpdrsy  .DB     0               ;save for y in mapdir
  1476 00:E3BB: 00           mpdrtm  .DB     0               ;temp in mapdir
  1477 00:E3BC: 00 00        maxdrc  .DW     0               ;max directory record
  1478 00:E3BE: 00           sab     .DB     0               ;mask for block
  1479 00:E3BF: 00           sxb     .DB     0               ;shift for block
  1480 00:E3C0: 00 00 00     rtclk   .DB     0,0,0           ;real time clock
  1481 00:E3C3: 00 00        gpcnt   .DW     0               ;gp counter
  1482                        ;
  1483                        ;following memory region is used to capture DCB
  Tue Apr 29 2025  4:23                                                                                                    Page 50


  1484                        ;
  1485                        dcb
  1486 00:E3C5: 00 00        maxblk  .DW     0               ;maximum block number
  1487 00:E3C7: 00 00        recblk  .DW     0               ;records per block
  1488 00:E3C9: 00 00        resrec  .DW     0               ;reserved records
  1489 00:E3CB: 00           blkscd  .DB     0               ;block size code
  1490 00:E3CC: 00 00        maxdir  .DW     0               ;maximum directory number
  1491 00:E3CE: 00 00        alcmap  .DW     0               ;address of allocation map
  1492                        ;
  1493 00:E3D0: 00           exm     .DB     0               ;extent mask
  1494 00:E3D1: 00           cexm1f  .DB     0               ;exm complemented and 1f
  1495                        ;
  1496                                end
   278                        ;
   279                                        .ORG    $/256*256+256           ;Align to Page address
   280                        ;
   281                                include         DOS65-SIM-V321.ASM      ;Include SIM Module
     1                        ;
     2                        ;----------------------------------------
     3                        ;DOS/65 system interface module (SIM)
     4                        ;----------------------------------------
     5                        ;
     6                        ; Version 3.21 - 6th March 2025
     7                        ;
     8                        ;This version is designed to work with the C02 Pocket SBC with RTC/CF-Card adapter:
     9                        ; - modified for 3.3V for 35-pin PATA MicroDrive, SC28L92 DUART and DS1511Y RTC
    10                        ;
    11                        ;Note: Updated disk configuration to 4KB block sizes.
    12                        ; Allocation tables are now half the size, 256 bytes vs 512 bytes.
    13                        ;
    14                        ;Microdrive Disk configuration:
    15                        ; a 8MB
    16                        ; b 8MB
    17                        ; c 8MB
    18                        ; d 8MB
    19                        ; e 8MB
    20                        ; f 8MB
    21                        ; g 8MB
    22                        ; h 8MB
    23                        ;
    24                        ;This SIM version no longer uses Track/Sector parameters to access the Microdrive!
    25                        ; - All calls and paraneters from PEM are now based on Record numbers.
    26                        ; - Records are still set as 128-bytes per record.
    27                        ; - Record number is a 16-bit value (0-65,535), so an 8MB limit still exists.
    28                        ;
    29                        ;The Disk Control Block parameter table has been modified.
    30                        ; This is done to accomodate the change from Track/Sector parameters to records, and
    31                        ; eliminates the checksum table, as IDE and other nonremovable block devices don't require it.
    32                        ; The new DCB table entry is configured as:
    33                        ;
    34                        ; Note: example shows an 8MB drive setup.
    35                        ; - A total of 2048 blocks, where each block is 4096 bytes
    36                        ; - the number of records per physical block is 4 (4*128=512)
    37                        ; - the total number of reserved records is 256 (256*128=32,768 bytes)
    38                        ; - Note: Reserved Records must be a multiple of 4!
    39                        ;
    40                        ;     .DW     2039            ;max block number
    41                        ;     .DW     4               ;records per physical block (LBA)
    42                        ;     .DW     256             ;number of reserved records (OS Boot area)
    43                        ;     .DB     2               ;block size = 4096
    44                        ;     .DW     1023            ;max directory
    45                        ;     .DW     almpa           ;address of allocation map
    46                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 51


    47                        ;A modified PEM module is required to use this new SIM version.
    48                        ; PEM 3.20 and later also contains the changes for using Record numbers only!
    49                        ;
    50                        ;Note:  02 January 2024 Update!
    51                        ; SIM Version 3.21 now receives Reserved Record count from PEM!
    52                        ; this requires that SIM calculates this into the Record request from PEM.
    53                        ; this calculation is done in the "get_lba" routine.
    54                        ; - this saves space and execution time in PEM.
    55                        ; - this adds some space to SIM but additional execution time in SIM is less overall.
    56                        ;
    57                        ;Note: This SIM version makes calls to the C02BIOS directly!
    58                        ; This results in a smaller code size and one less module to write and maintain.
    59                        ;
    60                        ;As this SIM supports a prototype C02 Pocket, the following devices exist:
    61                        ; - 35-pin PATA Microdrive (IDE Drive) - supports 8 drives at 8MB each
    62                        ; - Dual port UART - provides console and reader/punch functions
    63                        ; - Realtime Clock - not currently supported/used
    64                        ;
    65                        ;Note that this SIM version uses an additional 4-byte offset for LBA accesses!
    66                        ; - This is required due to being a bootable system. The Microdrive uses a Partition Record
    67                        ; - which will load the Boot Block from the active partition. The Boot Block and Boot Image are
    68                        ; - part of the allocated disk space that becomes the drive.
    69                        ;
    70                        ; - The Boot Block code will use the Load Header at the start of drive image to provide the offset
    71                        ; - to allocated space and update the Partition Offset variable in this SIM module (part_offset).
    72                        ; - This design allows the Boot Image to be easily moved to a new location on the drive and not
    73                        ; - have to worry about the disk access. Only the Boot Block needs to be updated.
    74                        ;
    75                        ;**************************************************************************************************
    76                        ;Include required constants/equates/tables for SIM to assemble
    77                        ;
    81                                LIST
    82                        ;
    83                        ;**************************************************************************************************
    84                        ;
    85                        ;Main program, Start of SIM
    86                        ; this is the cold start for DOS/65. The boot block code jumps to here.
    87                        ;
    88                        ; Note: The following calls are no longer needed or supported, but are still listed in SIM to
    89                        ;       maintain the SIM functions at the correct address offsets.
    90                        ;       Also, the Console Definition Table has a hard-coded section within SIM.
    91                        ;
    92                        ;       SIMRAM+24: Set Home Drive
    93                        ;       SIMRAM+51: Translate Sector
    94                        ;
    95                        ; Set Home Drive is specific to diskette based media.
    96                        ; - As multiple drive letters now exist on a single block device, there's no need to
    97                        ;   tell the drive to go to home (which would be cylinder zero).
    98                        ; 
    99                        ; Translate Sectors is obsolete.
   100                        ; - There are no diskette drives supported in this version of DOS/65.
   101                        ;
   102                        ; Note: Printer Output is not supported, but could be using additional hardware if required.
   103                        ;
   104 00:E400: 4C 80 E4     simram          jmp     sim_boot        ;Cold start SIM-DOS/65  simram+0 (3)
   105 00:E403: 4C E9 E4     sim_wboote      jmp     sim_wboot       ;Warm boot DOS/65       simram+3 (3)
   106 00:E406: 4C 26 E5                     jmp     mon_consts      ;Check for input        simram+6 (3)
   107 00:E409: 4C 29 E5                     jmp     mon_conrde      ;Get input              simram+9 (3)
   108 00:E40C: 4C 35 E5                     jmp     mon_conwrt      ;Send to terminal       simram+12 (3)
   109 00:E40F: 4C 55 E5                     jmp     print_output    ;Printer output         simram+15 (3)
   110 00:E412: 4C 4D E5                     jmp     mon_punch       ;Punch output           simram+18 (3)
   111 00:E415: 4C 50 E5                     jmp     mon_reader      ;Reader input           simram+21 (3)
   112 00:E418: 4C 41 E4                     jmp     dummy           ;Set home drive         simram+24 (3)
  Tue Apr 29 2025  4:23                                                                                                    Page 52


   113 00:E41B: 4C 59 E5                     jmp     sim_seldsk      ;Select active disk     simram+27 (3)
   114 00:E41E: 4C 6C E5                     jmp     sim_setres      ;Set reserved records   simram+30 (3)
   115 00:E421: 4C 73 E5                     jmp     sim_setrec      ;Set record number      simram+33 (3)
   116 00:E424: 4C 65 E5                     jmp     sim_setdma      ;Set buffer address     simram+36 (3)
   117 00:E427: 4C 7A E5                     jmp     sim_read        ;Read PEM record        simram+39 (3)
   118 00:E42A: 4C AD E5                     jmp     sim_write       ;Write PEM record       simram+42 (3)
   119 00:E42D: 4C 53 E5                     jmp     print_status    ;Printer always ready   simram+45 (3)
   120 00:E430: 4C 56 E5                     jmp     rtc_read        ;Clock entry            simram+48 (3)
   121 00:E433: 4C 41 E4                     jmp     dummy           ;Translate (obsolete)   simram+51 (3)
   122                        ;
   123                        ;console definition block - simram+54
   124 00:E436: 00                           .DB     0               ;Scratch
   125 00:E437: 08           sysdef          .DB     8               ;Backspace
   126 00:E438: 01                           .DB     1               ;Clear to end of line
   127 00:E439: 0C                           .DB     $0C             ;Forward space
   128 00:E43A: 00                           .DB     0               ;Normal video
   129 00:E43B: 5E                           .DB     '^'             ;Invert video
   130 00:E43C: 18                           .DB     24              ;Lines per screen
   131 00:E43D: 50                           .DB     80              ;Char per line
   132 00:E43E: 0C                           .DB     $0C             ;Form feed
   133 00:E43F: 1E                           .DB     $1E             ;Home
   134 00:E440: 02                           .DB     2               ;Clear to end of screen
   135                        ;
   136 00:E441: 60           dummy           rts                     ;Return (6)
   137                        ;
   138                        ;SIM Messages
   139 00:E442: 0D 0A 53 49  sim_opnmsg      .DB     CR,LF,"SIM Version 3.21"
       00:E446: 4D 20 56 65 
       00:E44A: 72 73 69 6F 
       00:E44E: 6E 20 33 2E 
       00:E452: 32 31 
   140 00:E454: 0D 0A 44 4F                  .DB     CR,LF,"DOS/65 Version 3.21",0
       00:E458: 53 2F 36 35 
       00:E45C: 20 56 65 72 
       00:E460: 73 69 6F 6E 
       00:E464: 20 33 2E 32 
       00:E468: 31 00 
   141                        ;
   142 00:E46A: 0D 0A 44 69  io_err_msg      .DB     CR,LF,"Disk I/O Error!",0
       00:E46E: 73 6B 20 49 
       00:E472: 2F 4F 20 45 
       00:E476: 72 72 6F 72 
       00:E47A: 21 00 
   143                        ;
   144 00:E47C: 0D 0A 2A 00  warm_msg        .DB     CR,LF,"*",0
   145                        ;
   146                        ;Start of SIM cold boot
   147 00:E480: 20 00 FF     sim_boot        jsr     b_ide_reset     ;Reset Microdrive (safety) (6)
   148                        ;
   149 00:E483: A9 42                        lda     #<sim_opnmsg    ;Point to message (2)
   150 00:E485: A0 E4                        ldy     #>sim_opnmsg    ; (2)
   151 00:E487: 20 3A E5                     jsr     mon_prompt      ;Send it to console (6)
   152                        ;
   153 00:E48A: A2 FF                        ldx     #$FF            ;Set stack pointer (2)
   154 00:E48C: 9A                           txs                     ; to top of stack space (2)
   155                        ;
   156                        ; To improve Disk I/O performance, the partition offset will be added
   157                        ; to the drive offsets. This has to be a one-time calculation when
   158                        ; SIM is started, otherwise the disk offset will be added each time
   159                        ; SIM is reset, which doesn't work! This will take some additional
   160                        ; memory space, but saves execution time in the get_lba routine.
   161                        ; Once added in, the partition offset values below are zeroed out.
   162                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 53


   163 00:E48D: A2 00                        ldx     #0              ;Zero index for drive offset (2)
   164 00:E48F: A0 08                        ldy     #maxdrv         ;Load index for Max drive count (2)
   165                        drv_update_lp
   166 00:E491: 18                           clc                     ;Clear carry for add (2)
   167 00:E492: BD AD E6                     lda     drv_offset+0,x  ;Get the drive offset (4)
   168 00:E495: 6D CD E6                     adc     part_offset+0   ;Add the partition offset (4)
   169 00:E498: 9D AD E6                     sta     drv_offset+0,x  ;Save it back (5)
   170                        ;
   171 00:E49B: BD AE E6                     lda     drv_offset+1,x  ;Get the drive offset (4)
   172 00:E49E: 6D CE E6                     adc     part_offset+1   ;Add the partition offset (4)
   173 00:E4A1: 9D AE E6                     sta     drv_offset+1,x  ;Save it back (5)
   174                        ;
   175 00:E4A4: BD AF E6                     lda     drv_offset+2,x  ;Get the drive offset (4)
   176 00:E4A7: 6D CF E6                     adc     part_offset+2   ;Add the partition offset (4)
   177 00:E4AA: 9D AF E6                     sta     drv_offset+2,x  ;Save it back (5)
   178                        ;
   179 00:E4AD: E8                           inx                     ;Increment drive offset (2)
   180 00:E4AE: E8                           inx                     ; by 4 bytes per drive (2)
   181 00:E4AF: E8                           inx                     ; (2)
   182 00:E4B0: E8                           inx                     ; (2)
   183                        ;
   184 00:E4B1: 88                           dey                     ;Decrement drive count (2)
   185 00:E4B2: D0 DD                        bne     drv_update_lp   ;Loop back for all drives (2/3)
   186                        ;
   187                        ;Now that all drive offsets have been updated with the partition offset,
   188                        ; we will zero out the partition offset data (which is in RAM) so that it
   189                        ; can't be added in again ;-) Ah... RAM based routines!
   190                        ;
   191 00:E4B4: 9C CD E6                     stz     part_offset+0   ;Zero out Partition Offset (4)
   192 00:E4B7: 9C CE E6                     stz     part_offset+1   ; (4)
   193 00:E4BA: 9C CF E6                     stz     part_offset+2   ; (4)
   194 00:E4BD: 9C D0 E6                     stz     part_offset+3   ; (4)
   195                        ;
   196                        ;Initialize iostat - resets to user 0 and drive 0
   197                        ; Note: this can be changed to a specific drive/user if needed.
   198 00:E4C0: 9C 06 01                     stz     iostat          ;Clear I/O status (4)
   199                        ;
   200                        ;SIM Setup
   201                        ;First clear disk access flags
   202 00:E4C3: 64 C7                        stz     sim_recflg      ;Clear SIM record flag byte (3)
   203                        ;
   204                        ;Setup PEM entry in Page 1
   205                        ; note that a warm boot also branches here to finish up
   206                        sim_wsetup
   207 00:E4C5: A0 06                        ldy     #6              ;Set index to 6 (2)
   208 00:E4C7: B9 E2 E4     simset_lp       lda     sim_inttbl-1,y  ;Get SIM table data (4)
   209 00:E4CA: 99 FF 00                     sta     $0100-1,y       ;Store into page $01 PEM area (5)
   210 00:E4CD: 88                           dey                     ;Decrement index (2)
   211 00:E4CE: D0 F7                        bne     simset_lp       ;Loop until done (2/3)
   212                        ;
   213                        ;Setup default buffer for PEM (128 bytes)
   214                        sim_finish
   215 00:E4D0: A9 28                        lda     #<dflbuf        ;Get default buffer (2)
   216 00:E4D2: A0 01                        ldy     #>dflbuf        ; address (2)
   217 00:E4D4: 20 65 E5                     jsr     sim_setdma      ;Then set DMA for DOS/65 (6)
   218                        ;
   219                        ;Setup the BIOS for the default host buffer and block count.
   220                        ; The BIOS reads or writes a single 512-byte block into it's own
   221                        ; Host Buffer. The SIM code calls the C02 Pocket BIOS for all hardware
   222                        ; access.
   223 00:E4D7: A9 00                        lda     #<hstbuf        ;Get host buffer address (2)
   224 00:E4D9: A0 06                        ldy     #>hstbuf        ; high byte (2)
   225 00:E4DB: A2 01                        ldx     #1              ;Block count =1 (2)
  Tue Apr 29 2025  4:23                                                                                                    Page 54


   226 00:E4DD: 20 12 FF                     jsr     b_ide_set_addr  ;Call BIOS (6)
   227                        ;
   228 00:E4E0: 4C 10 D0                     jmp     ccmram          ;Then jump to CCM to complete startup (3)
   229                        ;
   230                        ;Initialization table
   231 00:E4E3: 4C           sim_inttbl      .DB     $4C             ;JMP opcode
   232 00:E4E4: 03 E4                        .DW     sim_wboote      ;Warm Boot location
   233 00:E4E6: 4C                           .DB     $4C             ;JMP opcode
   234 00:E4E7: 00 DA                        .DW     pemram          ;PEM RAM location
   235                        ;
   236                        ;SIM Warm Boot - When any application exits, it should make a call to Warm Boot
   237                        ; the system. That call will be handled here. As CCM can be over-written by any
   238                        ; application to access additional memory if/when needed, the warm boot routine
   239                        ; is responsible for reloading CCM. The updated 3.21 Version does not require
   240                        ; that PEM is reloaded, so that can save a small fraction of time for warm boot.
   241                        ; note that SIM should never be reloaded once DOS/65 is booted.
   242                        ;
   243                        ;NOTE: IOSTAT and hence the default drive/user are not altered by Warm Boot.
   244                        ; After CCM is reloaded, the current user/drive will be restored to the
   245                        ; same as before a warm boot was initiated.
   246                        ;
   247                        ;Clear out the user space in Page Zero, this can cause intermittant crashes on
   248                        ; a warm start if leftover data from the last app is present.
   249                        ; Apps like the Basic Compiler and Runtime are good examples.
   250                        ; Granted, this is likely something specific in CCM, but clearing out page zero
   251                        ; is just a good idea and can be an aid in any application debugging.
   252                        ;
   253                        sim_wboot
   254 00:E4E9: A2 9F                        ldx     #pzend-1        ;Get page zero end of space as index (2)
   255                        clr_pg0
   256 00:E4EB: 74 00                        stz     $00,x           ;Clear page zero user space (4)
   257 00:E4ED: CA                           dex                     ;Increment index (2)
   258 00:E4EE: D0 FB                        bne     clr_pg0         ;Loop back till done (2/3)
   259                        ;
   260                        ; X Reg = 0 from above
   261 00:E4F0: CA                           dex                     ;Decrement X to $FF (2)
   262 00:E4F1: 9A                           txs                     ;To top of stack - safety (2)
   263                        ;
   264                        ;Show a simple asterisk when a warm boot is executed
   265 00:E4F2: A9 7C                        lda     #<warm_msg      ;Point to message (2)
   266 00:E4F4: A0 E4                        ldy     #>warm_msg      ; (2)
   267 00:E4F6: 20 3A E5                     jsr     mon_prompt      ;Send it to console (6)
   268                        ;
   269                        ;As this is a bootable version of DOS/65, we need to reload CCM from disk for warm boot.
   270                        ; CCM, PEM, SIM and the (cleared) disk allocation tables are stored in the Reserved Records
   271                        ; area of the bootable drive partition. This eliminates the need to clear the allocation maps
   272                        ; when the system is initially booted.
   273                        ;
   274                        ;The actual Cold Boot is handled by the Boot Record, which is loaded from the Drive.
   275                        ; This is the result of the Partition Loader loading and executing the active Boot Record.
   276                        ; All of this is setup outside of DOS/65 and SIM. A separate disk utility is used to setup
   277                        ; the drive and load the DOS/65 code to the drive in the reserved area of the disk.
   278                        ;
   279                        ;As the default boot drive is A:, we only need to load the first set of drive offsets and
   280                        ; set these up in the BIOS. Note that these values will contain the actual starting LBA
   281                        ; for the first drive, as the partition offset value has been added to all drive offsets.
   282                        ;
   283                        ;As Blocking/De-blocking is handled in SIM, we need to test the Dirty Block flag to see
   284                        ; if there is a pending block write. If there is, we'll flush the buffer to disk.
   285                        ;
   286 00:E4F9: 6F C7 0A                     bbr6    sim_recflg,no_flush     ;Check dirty block flag, branch if clear (5/6)
   287                        ;
   288                        ;SIM Flush Drive
  Tue Apr 29 2025  4:23                                                                                                    Page 55


   289                        ; When PEM calls SIM to read or write a Record, blocking and de-blocking is done
   290                        ; here in the routines below. To enhance performance for block writes, SIM will
   291                        ; delay a block write as there are four records per block. If a different record
   292                        ; is required by PEM, the current disk buffer will be checked via a dirty block
   293                        ; flag and flushed to disk before loading the new calculated block. It's also
   294                        ; important to check the dirty block flag via a warm boot, as applications don't
   295                        ; know about this SIM feature.
   296                        ;
   297                        ; Write the current LBA in the bufer to the disk.
   298                        ;
   299 00:E4FC: 20 0C FF                     jsr     b_ide_write_lba ;Call BIOS to Write LBA (6)
   300 00:E4FF: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   301 00:E501: 4A                           lsr     a               ;Shift error bit to carry (2)
   302 00:E502: B0 1F                        bcs     ide_rw_err      ;Branch if error (2/3)
   303                        ;
   304 00:E504: 67 C7                        rmb6    sim_recflg      ;Reset dirty block flag (5)
   305                        ;
   306                        no_flush
   307 00:E506: AD AD E6                     lda     drv_offset+0    ;Get LBA parameters (4)
   308 00:E509: AC AE E6                     ldy     drv_offset+1    ; (4)
   309 00:E50C: AE AF E6                     ldx     drv_offset+2    ; (4)
   310 00:E50F: 20 0F FF                     jsr     b_ide_set_lba   ;Call BIOS to set parameters (6)
   311                        ;
   312                        ;Next, set the load address for BIOS to reload the CCM module.
   313                        ; The X reg contains the number of blocks to load. CCM starts at
   314                        ; "ramstrt", which is defined in the main source file.
   315                        ; CCM uses 10 pages (256 bytes per page), 2560 bytes, which is 5 blocks from the Microdrive.
   316                        ;
   317 00:E512: A9 00                        lda     #<ramstrt       ;Get load address lo (2)
   318 00:E514: A0 D0                        ldy     #>ramstrt       ;Get load address hi (2)
   319 00:E516: A2 05                        ldx     #5              ;Get block count (2.5KB for CCM only) (2)
   320 00:E518: 20 12 FF                     jsr     b_ide_set_addr  ;Call BIOS to set address and size (6)
   321 00:E51B: 20 09 FF                     jsr     b_ide_read_lba  ;Call BIOS to load CCM to memory (6)
   322 00:E51E: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   323 00:E520: 4A                           lsr     a               ;Shift error bit to carry (2)
   324 00:E521: 90 A2                        bcc     sim_wsetup      ;If no error, reset PEM and start CCM (2/3)
   325                        ide_rw_err
   326 00:E523: 4C 7C E6                     jmp     get_lba_err     ;Else, use common error routine (3)
   327                        ;
   328                        ;**************************************************************************************************
   329                        ;
   330                        ;Console Input and Output Routines
   331                        ; There are three routines for Console I/O
   332                        ; 1- CONSTS - Console Status: tests to see if there is a character available
   333                        ; 2- CONRDE - Console Read: waits for a character to be available, then returns with it
   334                        ; 3- CONWRT - Console Write: sends a character to the console
   335                        ;
   336                        ;The console status routine does NOT read any data from the console itself.
   337                        ; It just checks to see if data has been entered. If no data is waiting, the A Reg has to be
   338                        ; zero. If data is waiting, the A Reg has to be a non-zero value, hence any or all bits set
   339                        ; active will work. The BIOS uses the page zero variable icnt_a to track the data count in
   340                        ; the input buffer. By simply loading the A Reg from icnt_a, the A reg will be either zero
   341                        ; or have a non-zero value. Note that the Z flag is also set if icnt_a is zero.
   342                        ;
   343                        ; Note: C02BIOS5 will include a routine to call for this function. This will eliminate the SIM
   344                        ; module from accessing BIOS variables directly.
   345                        ;
   346                        mon_consts
   347 00:E526: 4C 18 FF                     jmp     b_chr_stat      ;check console status
   348                        ;
   349                        ;The console read routine calls the C02BIOS routine to get a character from the console.
   350                        ; As the C02BIOS can transfer 8-bit binary data, the upper bit is masked off to ensure ASCII
   351                        ; only. Also, the standard Delete key code from the console is a Backspace ($08). The PEM
  Tue Apr 29 2025  4:23                                                                                                    Page 56


   352                        ; routine checks for the Delete key, so this routine will check for Backspace and replace it
   353                        ; with a Delete code.
   354                        ;
   355                        mon_conrde
   356 00:E529: 20 1E FF                     jsr     b_chrin         ;Call BIOS for character in (waits) (6)
   357 00:E52C: 29 7F                        and     #$7F            ;Strip off high bit (ASCII only) (2)
   358 00:E52E: C9 08                        cmp     #bs             ;Check for Backspace character (2)
   359 00:E530: D0 02                        bne     conrdx          ;If not, branch (2/3)
   360 00:E532: A9 7F                        lda     #delete         ;Else, replace with Delete code (2)
   361 00:E534: 60           conrdx          rts                     ;Return to Caller (6)
   362                        ;
   363                        ;The console write routine is straightforward. As per the System Interface Guide, the SIM
   364                        ; routine does not need to preserve the character being written to the console. We only take the
   365                        ; approach of stripping off the high bit to ensure ASCII only.
   366                        ;
   367                        mon_conwrt
   368 00:E535: 29 7F                        and     #$7F            ;Strip off high bit for ASCII (2)
   369 00:E537: 4C 21 FF                     jmp     b_chrout        ;Send to BIOS and return (3)
   370                        ;
   371                        ;Prompt routine for sending a string to the console:
   372                        ; To eliminate the ROM Monitor routine usage, this routine is the same code to
   373                        ; send a null terminated string to the console using the BIOS chrout call.
   374                        ;
   375 00:E53A: 85 FD        mon_prompt      sta     b_stringl       ;Store low byte (3)
   376 00:E53C: 84 FE                        sty     b_stringh       ;Store high byte (3)
   377                        ;
   378                        ;mon_prompt_lp routine: prints message at address (B_STRINGL) till null character found
   379 00:E53E: B2 FD        mon_prompt_lp   lda     (b_stringl)     ;Get string data (5)
   380 00:E540: F0 F2                        beq     conrdx          ;If null character, exit (borrowed RTS) (2/3)
   381 00:E542: 20 21 FF                     jsr     b_chrout        ;Send character to terminal (6)
   382 00:E545: E6 FD                        inc     B_stringl       ;Increment low byte index (5)
   383 00:E547: D0 F5                        bne     mon_prompt_lp   ;Loop back for next character (2/3)
   384 00:E549: E6 FE                        inc     B_stringh       ;Increment high byte index (5)
   385 00:E54B: 80 F1                        bra     mon_prompt_lp   ;Loop back and continue printing (3)
   386                        ;
   387                        ;**************************************************************************************************
   388                        ;
   389                        ;Additional routines for using the second serial port via C02BIOS routines
   390                        ; these are simple binary passthru routines, no data input or output is modified.
   391                        ;
   392                        mon_punch
   393 00:E54D: 4C 27 FF                     jmp     b_chrout2       ;Send data to serial port 2 (3)
   394                        ;
   395                        mon_reader
   396 00:E550: 4C 24 FF                     jmp     b_chrin2        ;Get data from serial port 2 (3)
   397                        ;
   398                        ;**************************************************************************************************
   399                        ;
   400                        ;Place holder for Printer Output routines
   401                        ; these are just simple dead end routines. One for Printer Status always showing available and
   402                        ; the second for printer output that just return without doing anything.
   403                        ;
   404                        print_status
   405 00:E553: A9 01                        lda     #1              ;Get active flag status (2)
   406                        print_output
   407 00:E555: 60                           rts                     ;Return (6)
   408                        ;
   409                        ;**************************************************************************************************
   410                        ;
   411                        ;Place holder for realtime clock routines
   412                        ; This routine simply returns with #128 in the X register, showing no clock present/
   413                        ;
   414                        rtc_read
  Tue Apr 29 2025  4:23                                                                                                    Page 57


   415 00:E556: A2 80                        ldx     #128            ;Get active flag status (2)
   416 00:E558: 60                           rts                     ;Eeturn (6)
   417                        ;
   418                        ;**************************************************************************************************
   419                        ;Start of Disk I/O Routines:
   420                        ; Note that these routines rely on the C02BIOS calls for physical access of the Microdrive!
   421                        ; 
   422                        ; Blocking/De-blocking is always used for IDE devices (default LBA size = 512 bytes)
   423                        ; All drives are configured with the same defaults as:
   424                        ;
   425                        ; - 2048 total blocks
   426                        ; - 4 records per LBA (drive physical block size)
   427                        ; - 32 records per block (DOS/65 Allocation size per extent)
   428                        ;
   429                        ; Records is a 16-bit field and record lengths are 128-bytes. These routines provide a simple
   430                        ; translation layer that will read and write blocks from the Microdrive. Each 512-byte block
   431                        ; contains 4- 128-byte records. This calculates to a total of 8MB of disk space allocated via
   432                        ; the 64K of records per drive letter.
   433                        ;
   434                        ; There are several routines which are required to support the SIM functions
   435                        ;
   436                        ;Record Move routines
   437                        ; there are two sets of Record Move routines;
   438                        ; - set one moves a Record from the LBA buffer to the DMA address specified by PEM
   439                        ; - set two moves a Record from the DMA address specified by PEM to the LBA buffer
   440                        ; In short, Set one is for reading a Record from disk and moving to memory, while
   441                        ; set two is for writing a Record from memory and moving to disk.
   442                        ;
   443                        ;Select disk
   444                        ; drive range is now validated by PEM before making this SIM call.
   445                        ;
   446                        sim_seldsk
   447 00:E559: 8D A0 E6                     sta     sim_seldrv      ;Save as current drive (4)
   448 00:E55C: 0A                           asl     a               ;Multiply by two (2)
   449 00:E55D: AA                           tax                     ;Make an index (2)
   450 00:E55E: BD 88 E6                     lda     sim_dcbtbl,x    ;Get DCB address (4)
   451 00:E561: BC 89 E6                     ldy     sim_dcbtbl+1,x  ; in A/Y (4)
   452 00:E564: 60                           rts                     ;Return (6)
   453                        ;
   454                        ;Set DOS/65 memory buffer address
   455                        ;
   456                        sim_setdma
   457 00:E565: 8D A1 E6                     sta     sim_dmaadr      ;Save address low (4)
   458 00:E568: 8C A2 E6                     sty     sim_dmaadr+1    ;Save address high (4)
   459 00:E56B: 60                           rts                     ;Return (6)
   460                        ;
   461                        ;Set Requested Reserved Records
   462                        ; Note that PEM uses the Reserved Records from the DCB for the active drive.
   463                        ;
   464                        sim_setres
   465 00:E56C: 8D A5 E6                     sta     sim_resrec      ;Save reserved record low (4)
   466 00:E56F: 8C A6 E6                     sty     sim_resrec+1    ;Save reserved record high (4)
   467 00:E572: 60                           rts                     ;Return (6)
   468                        ;
   469                        ;Set Requested Record
   470                        ; Note that PEM does NOT add the Reserved Record count to the requested Record.
   471                        ; this is handled in the get_lba routine below.
   472                        ;
   473                        sim_setrec
   474 00:E573: 8D A3 E6                     sta     sim_pemrec      ;Save record low (4)
   475 00:E576: 8C A4 E6                     sty     sim_pemrec+1    ;Save record high (4)
   476 00:E579: 60                           rts                     ;Return (6)
   477                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 58


   478                        ;*************************************************************************************************
   479                        ;
   480                        ;Read the selected DOS/65 record.
   481                        ;
   482                        sim_read
   483 00:E57A: D7 C7                        smb5    sim_recflg      ;Set read op flag (5)
   484 00:E57C: 20 E2 E5                     jsr     get_lba         ;Calculate/get LBA to read (6)
   485                        ;
   486                        ;Transfer the record from buffer to DMA
   487                        ;
   488 00:E57F: A5 C7                        lda     sim_recflg      ;Get recflg (4)
   489 00:E581: 29 03                        and     #%00000011      ;Mask for lower 2-bits (2)
   490 00:E583: 0A                           asl     a               ;Multiply by 2 for index (2)
   491 00:E584: AA                           tax                     ;Xfer to X reg as index (2)
   492                        ;
   493 00:E585: BD 98 E6                     lda     buff_offset,x   ;Get buffer offset address (4)
   494 00:E588: BC 99 E6                     ldy     buff_offset+1,x ; (4)
   495 00:E58B: 8D A0 E5                     sta     mover+1         ;Save to routine lo (4)
   496 00:E58E: 8C A1 E5                     sty     mover+2         ;Save to routine hi (4)
   497                        ;
   498 00:E591: AD A1 E6                     lda     sim_dmaadr+0    ;Get dma address lo (4)
   499 00:E594: AC A2 E6                     ldy     sim_dmaadr+1    ;Get dma address hi (4)
   500 00:E597: 8D A3 E5                     sta     mover+4         ;Save to routine lo (4)
   501 00:E59A: 8C A4 E5                     sty     mover+5         ;Save to routine hi (4)
   502 00:E59D: A0 00                        ldy     #0              ;Zero index (2)
   503                        ;
   504                        mover
   505 00:E59F: B9 FF FF                     lda     $FFFF,y         ;Get from source address (4)
   506 00:E5A2: 99 FF FF                     sta     $FFFF,y         ;Move to destination address (5)
   507 00:E5A5: C8                           iny                     ;Increment offset (2)
   508 00:E5A6: 10 F7                        bpl     mover           ;Loop back until done (2/3)
   509                        ;
   510 00:E5A8: 57 C7                        rmb5    sim_recflg      ;Reset read op flag (5)
   511 00:E5AA: A9 00                        lda     #0              ;Zero for no error (2)
   512 00:E5AC: 60                           rts                     ;Return (6)
   513                        ;
   514                        ;Write the selected DOS/65 record.
   515                        ;
   516                        sim_write
   517 00:E5AD: C7 C7                        smb4    sim_recflg      ;Set write op flag (5)
   518 00:E5AF: 20 E2 E5                     jsr     get_lba         ;Calculate/get LBA to write (6)
   519                        ;
   520                        ;Transfer the record from DMA to buffer
   521                        ;
   522 00:E5B2: A5 C7                        lda     sim_recflg      ;Get recflg (4)
   523 00:E5B4: 29 03                        and     #%00000011      ;Mask for lower 2-bits (2)
   524 00:E5B6: 0A                           asl     a               ;Multiply by 2 for index (2)
   525 00:E5B7: AA                           tax                     ;Xfer to X reg as index (2)
   526                        ;
   527 00:E5B8: BD 98 E6                     lda     buff_offset,x   ;Get buffer offset address (4)
   528 00:E5BB: BC 99 E6                     ldy     buff_offset+1,x ; (4)
   529 00:E5BE: 8D D6 E5                     sta     movew+4         ;Save to routine lo (4)
   530 00:E5C1: 8C D7 E5                     sty     movew+5         ;Save to routine hi (4)
   531                        ;
   532 00:E5C4: AD A1 E6                     lda     sim_dmaadr+0    ;Get dma address lo (4)
   533 00:E5C7: AC A2 E6                     ldy     sim_dmaadr+1    ;Get dma address hi (4)
   534 00:E5CA: 8D D3 E5                     sta     movew+1         ;Save to routine lo (4)
   535 00:E5CD: 8C D4 E5                     sty     movew+2         ;Save to routine hi (4)
   536 00:E5D0: A0 00                        ldy     #0              ;Zero index (2)
   537                        ;
   538                        movew
   539 00:E5D2: B9 FF FF                     lda     $FFFF,y         ;Get from source address (4)
   540 00:E5D5: 99 FF FF                     sta     $FFFF,y         ;Move to destination address (5)
  Tue Apr 29 2025  4:23                                                                                                    Page 59


   541 00:E5D8: C8                           iny                     ;Increment offset (2)
   542 00:E5D9: 10 F7                        bpl     movew           ;Loop back until done (2/3)
   543                        ;
   544 00:E5DB: E7 C7                        smb6    sim_recflg      ;Set dirty block flag (5)
   545                        ;
   546 00:E5DD: 47 C7                        rmb4    sim_recflg      ;Reset write op flag (5)
   547 00:E5DF: A9 00                        lda     #0              ;Zero for no error (2)
   548 00:E5E1: 60                           rts                     ;Return to caller (6)
   549                        ;
   550                        ;**************************************************************************************************
   551                        ;
   552                        ;Get LBA routine
   553                        ; This is a core routine for SIM and all disk level activity. Now that PEM
   554                        ; and SIM have been changed to a Record level access, the conversion between
   555                        ; 128-byte records and 512-byte LBA block sizes can be streamlined.
   556                        ;
   557                        ;This routine is common for both Reading and Writing of Records. As there
   558                        ; is still a requirement to perform blocking/de-blocking from PEM Records
   559                        ; to disk block sizes, this routine will perform the following tasks:
   560                        ;
   561                        ; 1- Add the Reserved Record count to the Requested Record number.
   562                        ; 2- Calculate the Block Number from the Record number.
   563                        ; 3- Save the Record offset within the calculated block number.
   564                        ; 4- Check to see if a valid disk block is loaded in the buffer.
   565                        ; 5- Perform a block read if there is no valid block loaded.
   566                        ; 6- Test the valid block loaded against the required block number.
   567                        ; 7- Test for a pending write for the valid block number.
   568                        ; 8- Write a pending block and clear the dirty block flag if required.
   569                        ; 9- Only load a block if needed, else return without disk I/O access.
   570                        ;
   571                        ;This is a fair amount of work, but this core routine ensures we have the
   572                        ; correct block in the default disk buffer on which to read or write
   573                        ; records to or from. This routine also simplifies the Record Read and Write
   574                        ; routines to focus only on handling the required 128-byte record.
   575                        ;
   576                        ;Another advantage is that this routine will only load a new block when
   577                        ; it needs to, i.e., if the calculated block is already loaded, it will
   578                        ; not reload it, but simply return and allow the Record Read and Write
   579                        ; routines to carry out their record level function.
   580                        ; This improves the overall disk I/O performance.
   581                        ;
   582                        ;Calculate the block number (LBA) based on the Record number.
   583                        ; The Record number is a 16-bit value (0-65,535) and is 128-bytes in size.
   584                        ; To calculate the LBA, we simply divide it by 4, as there are 4 records
   585                        ; per 512-byte block (LBA). We also save the lower 2-bits as this becomes
   586                        ; the offset of the requested record into the block (as binary, 00,01,10,11).
   587                        ;
   588                        ;First, we need to take the Record Number and do the following:
   589                        ; 1- Save the Record offset (the lower 2-bits of the Record number).
   590                        ; 2- Add the Reserved Records value to the requested Record.
   591                        ; 2- Perform a 16-bit Logical Right Shift by 2-bits (divide by 4).
   592                        ; 3- Add the Drive number offset to the required LBA.
   593                        ; 4- Save the calculated LBA, then check the flag byte for an LBA loaded.
   594                        ;
   595                        ;Second, we need to test for the following conditions:
   596                        ; 1- If a LBA is loaded, check to see if it is the same LBA that we need.
   597                        ; 2- If it is, just exit back to the calling routine, saving a disk read.
   598                        ; 3- If it it NOT, check the dirty block flag in case it's been altered.
   599                        ; 4- If the dirty block flag is set, write the current block and clear the flag,
   600                        ;    then update the parameters and load the new LBA.
   601                        ; 5- If the dirty block is not set, update the parameters and load the new LBA.
   602                        ;
   603                        ;The C02BIOS used here is Version 4.02.
  Tue Apr 29 2025  4:23                                                                                                    Page 60


   604                        ; This BIOS supports 24-bit LBA addressing.
   605                        ; Note: IDE uses 28-bit addressing, but the BIOS zeros the upper 4-bits,
   606                        ; resulting in a limit of 8GB for the attached IDE device.
   607                        ;
   608                        ;The SIM configuration is set for 8 drives (A thru H), each at 8MB.
   609                        ; Any of the defined drives can have Reserved Records, but in practical
   610                        ; use, only one drive should have Reserved Records to be use for holding
   611                        ; the bootable image for the OS (CCM, PEM, SIM, Allocation Tables).
   612                        ; The first drive will normally have the Reserved Records to hold the
   613                        ; bootable OS image, where a total of 256 Records will equate to 32KB.
   614                        ;
   615                        ;Once the Block number has been calculated from the Record number,
   616                        ; an offset must be added which is based on the Drive number (0-7).
   617                        ; Partition sizes are limited to 8MB
   618                        ; Number of drives is limited to 8 (A - H)
   619                        ; Maximum available Data is limited to 64MB
   620                        ;
   621                        ;The Offset table is 4 bytes per entry and adds an LBA count to
   622                        ; shift the absolute LBA numbers to the appropriate drive number
   623                        ; being acessed (16384 blocks per 8MB drive area).
   624                        ;
   625                        ;First, calculate the record number to LBA number and
   626                        ; store the LBA number to sim_pemrec (3 bytes).
   627                        ;
   628                        get_lba
   629 00:E5E2: A9 03                        lda     #%00000011      ;Get mask for record offset bits (2)
   630 00:E5E4: 14 C7                        trb     sim_recflg      ;Reset record offset bits in flag (5)
   631                        ;
   632                        ; next, we need to add the reserved record value to the PEM record requested.
   633                        ; the result will be stored in rectemp with high byte cleared.
   634                        ;
   635 00:E5E6: 18                           clc                     ;Clear carry flag for addition (2)
   636 00:E5E7: AD A3 E6                     lda     sim_pemrec+0    ;Get low byte PEM record (4)
   637 00:E5EA: 6D A5 E6                     adc     sim_resrec+0    ;Add in Reserve count low (4)
   638 00:E5ED: 8D A7 E6                     sta     sim_rectemp+0   ;Store to temp low byte (4)
   639 00:E5F0: AD A4 E6                     lda     sim_pemrec+1    ;Get high byte PEM record (4)
   640 00:E5F3: 6D A6 E6                     adc     sim_resrec+1    ;Add in Reserve count high (4)
   641 00:E5F6: 8D A8 E6                     sta     sim_rectemp+1   ;Store in temp high byte (4)
   642 00:E5F9: 9C A9 E6                     stz     sim_rectemp+2   ;Clear extended temp byte (4)
   643                        ;
   644 00:E5FC: AD A7 E6                     lda     sim_rectemp+0   ;Get low byte of requested record (4)
   645 00:E5FF: 29 03                        and     #%00000011      ;Mask off upper 6 bits (2)
   646 00:E601: 05 C7                        ora     sim_recflg      ;OR in other record flag bits (3)
   647 00:E603: 85 C7                        sta     sim_recflg      ;Update the record flag with new offset (3)
   648                        ;
   649                        ; now do the 16-bit shift to the right to divide by 4 and get the LBA number
   650                        ;
   651 00:E605: 4E A8 E6                     lsr     sim_rectemp+1   ;Shift high to right, LSB to carry (6)
   652 00:E608: 6E A7 E6                     ror     sim_rectemp     ;Rotate low to right, MSB from carry (6)
   653 00:E60B: 4E A8 E6                     lsr     sim_rectemp+1   ;Shift high to the right, LSB to carry (6)
   654 00:E60E: 6E A7 E6                     ror     sim_rectemp     ;Rotate low to right, MSB from carry (6)
   655                        ;
   656                        ; the sim_rectemp pointer now has the logical LBA number requested by PEM.
   657                        ; the sim_recflg also contains the record offset in the lower 2 bits,
   658                        ; plus the other flags, which have been preserved (very important).
   659                        ;
   660                        ; Note that the partition offset (common for all drives) has been added as
   661                        ; a one-time calculation during the first startup of SIM. As all drive
   662                        ; offsets have been updated with the parition offset, we only need to
   663                        ; apply the drive offset based on the current drive A-H (0-7).
   664                        ;
   665 00:E611: AD A0 E6                     lda     sim_seldrv      ;Get active drive number (4)
   666 00:E614: 0A                           asl     a               ;Multiply by two (2)
  Tue Apr 29 2025  4:23                                                                                                    Page 61


   667 00:E615: 0A                           asl     a               ;Multiply by two (now = 4) (2)
   668 00:E616: AA                           tax                     ;Xfer offset to X reg (2)
   669                        ;
   670 00:E617: 18                           clc                     ;Clear Carry for Add (2)
   671 00:E618: AD A7 E6                     lda     sim_rectemp+0   ;Get Low order LBA (4)
   672 00:E61B: 7D AD E6                     adc     drv_offset+0,x  ;Add in Low order offset (4)
   673 00:E61E: 8D A7 E6                     sta     sim_rectemp+0   ;Save to Low order LBA (4)
   674                        ;
   675 00:E621: AD A8 E6                     lda     sim_rectemp+1   ;Get Middle order LBA (4)
   676 00:E624: 7D AE E6                     adc     drv_offset+1,x  ;Add in Middle order offset (4)
   677 00:E627: 8D A8 E6                     sta     sim_rectemp+1   ;Save to Middle order LBA (4)
   678                        ;
   679 00:E62A: AD A9 E6                     lda     sim_rectemp+2   ;Get High order LBA (4)
   680 00:E62D: 7D AF E6                     adc     drv_offset+2,x  ;Add in High order offset (4)
   681 00:E630: 8D A9 E6                     sta     sim_rectemp+2   ;Save to High order LBA (4)
   682                        ;
   683                        ; now, the actual required LBA has been calculated and is stored as a 24-bit value.
   684                        ; this is stored in variable "sim_rectemp" (3 consecutive bytes).
   685                        ; We now need to compare the actual LBA needed to the currently loaded LBA, if there
   686                        ; is one. We first test for a valid LBA loaded by checking bit7 of the sim_recflg.
   687                        ;
   688 00:E633: 7F C7 26                     bbr7    sim_recflg,need_lba     ;Test sim_recflg for valid LBA (5/6)
   689                        ;
   690                        ; we have determined that a valid LBA is loaded, so we need to compare the LBA
   691                        ; that's been requested against the currently loaded LBA. If they are the same, we're
   692                        ; done and can return. If they are not, then we need to check the dirty block flag to
   693                        ; ensure the active block is written before we over-write it with the new one.
   694                        ;
   695 00:E636: AD A7 E6                      lda    sim_rectemp+0   ;Get low order requested LBA (4)
   696 00:E639: CD AA E6                      cmp    sim_curlba+0    ;Compare to current LBA (4)
   697 00:E63C: D0 11                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   698 00:E63E: AD A8 E6                      lda    sim_rectemp+1   ;Get middle order requested LBA (4)
   699 00:E641: CD AB E6                      cmp    sim_curlba+1    ;Compare to current LBA (4)
   700 00:E644: D0 09                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   701 00:E646: AD A9 E6                      lda    sim_rectemp+2   ;Get high order requested LBA (4)
   702 00:E649: CD AC E6                      cmp    sim_curlba+2    ;Compare to current LBA (4)
   703 00:E64C: D0 01                         bne    test_dirty      ;Bad compare, test for dirty block (2/3)
   704 00:E64E: 60                            rts                    ;Good compare, requested LBA is loaded (6)
   705                        ;
   706                        ;Test the dirty block flag.
   707                        ; the currently loaded LBA is not the one we need loaded. Before we
   708                        ; overwrite it, we'll test the dirty block flag. If it's set,
   709                        ; we'll write that block to disk to update it, clear the flag
   710                        ; then transfer the parameters for the new LBA and load it.
   711                        ;
   712                        test_dirty
   713 00:E64F: 6F C7 0A                     bbr6    sim_recflg,need_lba     ;Test sim_recflg for dirty block flag (5/6)
   714                        ;
   715                        ; we have a dirty block in the buffer... so we need to write the current LBA back
   716                        ; to the drive to ensure we don't get corrupted data on the drive!
   717                        ; note that the existing BIOS parameters still point to the currently loaded LBA.
   718                        ;
   719 00:E652: 20 0C FF                     jsr     b_ide_write_lba ;Call BIOS to Write LBA (6)
   720 00:E655: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   721 00:E657: 4A                           lsr     a               ;Shift error bit to carry (2)
   722 00:E658: B0 22                        bcs     get_lba_err     ;Branch if error (2/3)
   723 00:E65A: 67 C7                        rmb6    sim_recflg      ;Reset dirty block flag (5)
   724                        ;
   725                        ; now that the dirty block has been cleared, we can load the required LBA
   726                        ; into the disk buffer, update the flags and return.
   727                        ;
   728                        ; if we branched here from above, no valid LBA is loaded, so we just transfer the
   729                        ; LBA parameters to the BIOS and read the block into the default LBA buffer.
  Tue Apr 29 2025  4:23                                                                                                    Page 62


   730                        ;
   731                        need_lba
   732 00:E65C: AD A7 E6                     lda     sim_rectemp+0   ;Get required LBA parameters (Low byte) (4)
   733 00:E65F: AC A8 E6                     ldy     sim_rectemp+1   ; Middle byte (4)
   734 00:E662: AE A9 E6                     ldx     sim_rectemp+2   ; High byte (4)
   735                        ;
   736 00:E665: 8D AA E6                     sta     sim_curlba+0    ;Save as Current LBA (4)
   737 00:E668: 8C AB E6                     sty     sim_curlba+1    ; for checking the next (4)
   738 00:E66B: 8E AC E6                     stx     sim_curlba+2    ; time get_lba is called (4)
   739                        ;
   740 00:E66E: 20 0F FF                     jsr     b_ide_set_lba   ;Call BIOS to set LBA parameters (6)
   741                        ;
   742 00:E671: 20 09 FF                     jsr     b_ide_read_lba  ;Call BIOS to Read LBA (6)
   743 00:E674: A5 FC                        lda     ide_status_ram  ;Get Status from BIOS call (3)
   744 00:E676: 4A                           lsr     a               ;Shift error bit to carry (2)
   745 00:E677: B0 03                        bcs     get_lba_err     ;Branch if error (2/3)
   746 00:E679: F7 C7                        smb7    sim_recflg      ;Set valid LBA flag bit (5)
   747 00:E67B: 60                           rts                     ;Return to caller, we're done (6)
   748                        get_lba_err
   749 00:E67C: 77 C7                        rmb7    sim_recflg      ;Reset valid LBA flag bit (5)
   750 00:E67E: A9 6A                        lda     #<io_err_msg    ;Point to error message (2)
   751 00:E680: A0 E4                        ldy     #>io_err_msg    ; (2)
   752 00:E682: 20 3A E5                     jsr     mon_prompt      ;Send it to console (6)
   753 00:E685: 4C 80 E4                     jmp     sim_boot        ;Restart SIM (3)
   754                        ;
   755                        ;**************************************************************************************************
   756                        ;SIM Data area
   757                        ; All data pointers used by SIM disk routines are contained here. This includes:
   758                        ;  - Disk Contrl Block (DCB) addresses
   759                        ;  - Buffer offset addresses for Record to LBA Buffer
   760                        ;  - Parameter and Flags used for Record and LBA pointers
   761                        ;
   762                        ;Table of dcb addresses.
   763                        ; All 8 drives are accounted for, if not present, use a word value of "0000".
   764                        ;
   765 00:E688: D1 E6        sim_dcbtbl      .DW     dcb_a
   766 00:E68A: DC E6                        .DW     dcb_b
   767 00:E68C: E7 E6                        .DW     dcb_c
   768 00:E68E: F2 E6                        .DW     dcb_d
   769 00:E690: FD E6                        .DW     dcb_e
   770 00:E692: 08 E7                        .DW     dcb_f
   771 00:E694: 13 E7                        .DW     dcb_g
   772 00:E696: 1E E7                        .DW     dcb_h
   773                        ;
   774                        ;Buffer Offsets.
   775                        ; The offsets here point to the 4- 128-byte Records in the main Disk Buffer.
   776                        ;
   777                        buff_offset
   778 00:E698: 00 06                        .DW     LBA_BUFFER+0    ;Buffer offset 00
   779 00:E69A: 80 06                        .DW     LBA_BUFFER+128  ;Buffer offset 01
   780 00:E69C: 00 07                        .DW     LBA_BUFFER+256  ;Buffer offset 10
   781 00:E69E: 80 07                        .DW     LBA_BUFFER+384  ;Buffer offset 11
   782                        ;
   783                        ;Record level data area required by SIM
   784 00:E6A0:              sim_seldrv      DEFS    1               ;Current selected drive number (0-7)
   785 00:E6A1:              sim_dmaadr      DEFS    2               ;DMA address to Record transfer
   786 00:E6A3:              sim_pemrec      DEFS    2               ;Record number requested by PEM
   787 00:E6A5:              sim_resrec      DEFS    2               ;Reserved Records received from PEM
   788 00:E6A7:              sim_rectemp     DEFS    3               ;Calculated LBA required by PEM
   789 00:E6AA:              sim_curlba      DEFS    3               ;LBA number currently loaded in Buffer
   790                        ;
   791                        ;**************************************************************************************************
   792                        ;
  Tue Apr 29 2025  4:23                                                                                                    Page 63


   793                        ;Table of LBA offsets for all drives A thru H (8MB each, 16384 Blocks per drive)
   794                        ;
   795                        ;NOTE: These offsets are based on a non-partitioned drive!!! Relative to each other only!
   796                        ; The partition offset below as "part_offset" is added to the "drv_offset" values the first time
   797                        ; SIM is started. To ensure this only happens once, the "part_offset" data is zeroed out after it
   798                        ; is added to the "drv_offset". Once the new values are loaded, the active drive being accessed
   799                        ; is used as a base offset and the block offset calculated by the requested Record from PEM is
   800                        ; added to get the actual 512-byte block address on the drive.
   801                        ;
   802                        drv_offset
   803 00:E6AD: 00 00 00 00                  .LONG   0               ;Drive A default (w/OS boot image)
   804 00:E6B1: 00 40 00 00                  .LONG   16384           ;Drive B
   805 00:E6B5: 00 80 00 00                  .LONG   32768           ;Drive C
   806 00:E6B9: 00 C0 00 00                  .LONG   49152           ;Drive D
   807 00:E6BD: 00 00 01 00                  .LONG   65536           ;Drive E
   808 00:E6C1: 00 40 01 00                  .LONG   81920           ;Drive F
   809 00:E6C5: 00 80 01 00                  .LONG   98304           ;Drive G
   810 00:E6C9: 00 C0 01 00                  .LONG   114688          ;Drive H
   811                        ;
   812                        ;Partition Offset
   813                        ; this offset is patched in during boot time from the boot loader.
   814                        ; this compensates for the drive partition being located anywhere on the drive.
   815                        ;
   816                        part_offset
   817 00:E6CD: 00 00 02 00                  .LONG   131072          ;Partition offset for drive letters
   818                        ;
   819                        ;**************************************************************************************************
   820                        ;
   821                        ;Disk Control Blocks (DCBs)
   822                        ; Support for 8 drives is the default.
   823                        ;
   824                        ; Note: The Disk Control Block format has been changed starting with Version 3.20!
   825                        ;       The second parameter is now defined as the number of records per block.
   826                        ;       - this is the physical block size of the storage device. For any standard IDE device,
   827                        ;         the default block size is 512 bytes. This calculates to 4 records per block.
   828                        ;       The third parameter is now defined as the number of reserved records (128 bytes/record).
   829                        ;       The last two parameters have been deleted! These last two parameters are not needed
   830                        ;       for a standard block device, as the device itself can not be removed or ejected.
   831                        ;
   832                        ; The changes here frees up 3 bytes per DCB. Also note that the code that supports the checksum
   833                        ; functions in PEM have also been eliminated. This frees up space in PEM and also provides
   834                        ; a very slight performance improvement.
   835                        ;
   836                        ;drive a (Microdrive 8MB)
   837 00:E6D1: F7 07        dcb_a           .DW     2039            ;Max block number-1
   838 00:E6D3: 04 00                        .DW     4               ;Records per physical block
   839 00:E6D5: 00 01                        .DW     256             ;Number of reserved records (32KB OS-boot)
   840 00:E6D7: 02                           .DB     2               ;Block size = 4096
   841 00:E6D8: FF 03                        .DW     1023            ;Max directory-1
   842 00:E6DA: 00 E8                        .DW     almpa           ;Address of allocation map
   843                        ;
   844                        ;drive b (Microdrive 8MB)
   845 00:E6DC: FF 07        dcb_b           .DW     2047            ;Max block number-1
   846 00:E6DE: 04 00                        .DW     4               ;Records per physical block
   847 00:E6E0: 00 00                        .DW     0               ;Number of reserved records
   848 00:E6E2: 02                           .DB     2               ;Block size = 4096
   849 00:E6E3: FF 03                        .DW     1023            ;Max directory-1
   850 00:E6E5: 00 E9                        .DW     almpb           ;Address of allocation map
   851                        
   852                        ;
   853                        ;drive c (Microdrive 8MB)
   854 00:E6E7: FF 07        dcb_c           .DW     2047            ;Max block number-1
   855 00:E6E9: 04 00                        .DW     4               ;Records per physical block
  Tue Apr 29 2025  4:23                                                                                                    Page 64


   856 00:E6EB: 00 00                        .DW     0               ;Number of reserved records
   857 00:E6ED: 02                           .DB     2               ;Block size = 4096
   858 00:E6EE: FF 03                        .DW     1023            ;Max directory-1
   859 00:E6F0: 00 EA                        .DW     almpc           ;Address of allocation map
   860                        ;
   861                        ;drive d (Microdrive 8MB)
   862 00:E6F2: FF 07        dcb_d           .DW     2047            ;Max block number-1
   863 00:E6F4: 04 00                        .DW     4               ;Records per physical block
   864 00:E6F6: 00 00                        .DW     0               ;Number of reserved records
   865 00:E6F8: 02                           .DB     2               ;Block size = 4096
   866 00:E6F9: FF 03                        .DW     1023            ;Max directory-1
   867 00:E6FB: 00 EB                        .DW     almpd           ;Address of allocation map
   868                        ;
   869                        ;drive e (Microdrive 8MB)
   870 00:E6FD: FF 07        dcb_e           .DW     2047            ;Max block number-1
   871 00:E6FF: 04 00                        .DW     4               ;Records per physical block
   872 00:E701: 00 00                        .DW     0               ;Number of reserved records
   873 00:E703: 02                           .DB     2               ;Block size = 4096
   874 00:E704: FF 03                        .DW     1023            ;Max directory-1
   875 00:E706: 00 EC                        .DW     almpe           ;Address of allocation map
   876                        ;
   877                        ;drive f (Microdrive 8MB)
   878 00:E708: FF 07        dcb_f           .DW     2047            ;Max block number-1
   879 00:E70A: 04 00                        .DW     4               ;Records per physical block
   880 00:E70C: 00 00                        .DW     0               ;Number of reserved records
   881 00:E70E: 02                           .DB     2               ;Block size = 4096
   882 00:E70F: FF 03                        .DW     1023            ;Max directory-1
   883 00:E711: 00 ED                        .DW     almpf           ;Address of allocation map
   884                        ;
   885                        ;drive g (Microdrive 8MB)
   886 00:E713: FF 07        dcb_g           .DW     2047            ;Max block number-1
   887 00:E715: 04 00                        .DW     4               ;Records per physical block
   888 00:E717: 00 00                        .DW     0               ;Number of reserved records
   889 00:E719: 02                           .DB     2               ;Block size = 4096
   890 00:E71A: FF 03                        .DW     1023            ;Max directory-1
   891 00:E71C: 00 EE                        .DW     almpg           ;Address of allocation map
   892                        ;
   893                        ;drive h (Microdrive 8MB)
   894 00:E71E: FF 07        dcb_h           .DW     2047            ;Max block number-1
   895 00:E720: 04 00                        .DW     4               ;Records per physical block
   896 00:E722: 00 00                        .DW     0               ;Number of reserved records
   897 00:E724: 02                           .DB     2               ;Block size = 4096
   898 00:E725: FF 03                        .DW     1023            ;Max directory-1
   899 00:E727: 00 EF                        .DW     almph           ;Address of allocation map
   900                        ;
   901                        ;**************************************************************************************************
   902                        ;
   903                                        END
   282                        ;
   283                                        .ORG    $/256*256+256           ;Align to Page address
   284                        
   285                        ;**************************************************************************************************
   286                        ;
   287                        alloc_maps
   288                        ;drive allocation maps
   289                        ;
   290                        ;drive a
   291             0000E800   almpa           .EQU    alloc_maps
   292 00:E800: 00 00                        .BLKW   128
   293                        ;drive b
   294             0000E900   almpb           .EQU    almpa+256
   295 00:E900: 00 00                        .BLKW   128
   296                        ;drive c
  Tue Apr 29 2025  4:23                                                                                                    Page 65


   297             0000EA00   almpc           .EQU    almpb+256
   298 00:EA00: 00 00                        .BLKW   128
   299                        ;drive d
   300             0000EB00   almpd           .EQU    almpc+256
   301 00:EB00: 00 00                        .BLKW   128
   302                        ;drive e
   303             0000EC00   almpe           .EQU    almpd+256
   304 00:EC00: 00 00                        .BLKW   128
   305                        ;drive f
   306             0000ED00   almpf           .EQU    almpe+256
   307 00:ED00: 00 00                        .BLKW   128
   308                        ;drive g
   309             0000EE00   almpg           .EQU    almpf+256
   310 00:EE00: 00 00                        .BLKW   128
   311                        ;drive h
   312             0000EF00   almph           .EQU    almpg+256
   313 00:EF00: 00 00                        .BLKW   128
   314                        ;
   315             0000F000   mapend          .EQU    *
   316                        ;
   317                                END


      Lines assembled: 4508
      Errors: 0
